<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客暂时停更，对 Docker + PHP + CI/CD 感兴趣的开发者可以关注我的以下开源项目]]></title>
    <url>%2Fnews%2F2018%2Fwork.html</url>
    <content type="text"><![CDATA[今后业余时间，我将精力主要放在 PCIT 项目（一个使用 PHP 编写的与 GitHub 深度集成的 CI/CD 系统）。 对 Docker + LNMP 感兴趣的朋友可以关注 khs1994-docker/lnmp 我会将一些 Docker 新功能在 issues 中列出，也可能不定时同步到此博客中。 我的主要开源项目 khs1994-docker/lnmp khs1994-php/pcit 感谢您的关注。]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>PCIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webAssembly]]></title>
    <url>%2Fhtml%2Fjs%2FwebAssembly.html</url>
    <content type="text"><![CDATA[webAssembly https://www.ibm.com/developerworks/cn/web/wa-lo-webassembly-status-and-reality/index.html]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript]]></title>
    <url>%2Fhtml%2Fjs%2Ftypescript%2FREADME.html</url>
    <content type="text"><![CDATA[TypeScript 几个知识点。 当命令行上 指定了输入文件 时，tsconfig.json 文件会被忽略。 TypeScript 与 ECMAScript 2015 一样，任何包含顶级 import 或者 export 的文件 都被当成一个模块。相反地，如果一个文件不带有顶级的 import 或者 export 声明，那么它的内容被视为全局可见的（因此对模块也是可见的）。 要想描述非 TypeScript 编写的类库的类型，我们需要声明类库所暴露出的 API。我们叫它声明因为它 不是 外部程序 的 具体实现 type xxx 类型别名。]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCIT 社区 PHP 微服务大讨论]]></title>
    <url>%2Fci%2Fpcit%2Fmicroservice.html</url>
    <content type="text"><![CDATA[欢迎对 PHP 微服务感兴趣的 PHP 开发者加入社区讨论。 官方网站: https://ci.khs1994.com https://github.com/pcit-ce/microservice]]></content>
      <categories>
        <category>CI</category>
        <category>PCIT</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Style CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 PCIT 持续集成 Node.js 项目]]></title>
    <url>%2Fci%2Fpcit%2Fnodejs.html</url>
    <content type="text"><![CDATA[PCIT 是一整套 CI 工具集。 官方网站: https://ci.khs1994.com 123456789101112language: node_jspipeline: install: commands: - npm i script: commands: - npm test]]></content>
      <categories>
        <category>CI</category>
        <category>PCIT</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Style CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 PCIT 持续集成 PHP 项目]]></title>
    <url>%2Fci%2Fpcit%2FREADME.html</url>
    <content type="text"><![CDATA[PCIT 是一整套 CI 工具集。 官方网站: https://ci.khs1994.com 123456789101112language: phppipeline: install: commands: - composer install script: commands: - ./vendor/bin/phpunit]]></content>
      <categories>
        <category>CI</category>
        <category>PCIT</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Style CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PCIT]]></title>
    <url>%2Fci%2Fpcit%2Fwhy.html</url>
    <content type="text"></content>
      <categories>
        <category>CI</category>
        <category>PCIT</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Style CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pm2]]></title>
    <url>%2Fhtml%2Fjs%2Fpm2.html</url>
    <content type="text"></content>
      <categories>
        <category>Node_js</category>
      </categories>
      <tags>
        <tag>Node_js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 面向对象]]></title>
    <url>%2Fhtml%2Fjs%2Foop.html</url>
    <content type="text"><![CDATA[ES6 class 1234567891011121314151617181920212223class A&#123; constructor()&#123; this.type = 'a' &#125; says(say)&#123; console.log(say) &#125;&#125;let a = new A()a.says('hello');// 继承class B extends A&#123; constructor()&#123; super() this.type = 'cat' &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2Fhtml%2Fjs%2Fwebpack.html</url>
    <content type="text"><![CDATA[webpack 简介。 loaderwebpack 本身只能打包 Javascript 文件，对于其他资源例如 css，图片，或者其他的语法集比如 jsx，是没有办法加载的。 这就需要对应的 loader 将资源转化，加载进来。 More Information https://segmentfault.com/a/1190000014408973]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宣布 PCIT 项目]]></title>
    <url>%2Fnews%2F2018%2Fpcit.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-php/pcit PHP 编写的 CI/CD 系统。]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PCIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESLint]]></title>
    <url>%2Fhtml%2Fjs%2Feslint.html</url>
    <content type="text"><![CDATA[https://eslint.org/docs/user-guide/getting-started 123$ npm install -g eslint$ eslint --init .eslintrc 12345678910111213141516171819202122232425262728&#123; "env": &#123; "browser": true, "es6": true &#125;, "extends": "eslint:recommended", "parserOptions": &#123; "ecmaVersion": 2015 &#125;, "rules": &#123; "indent": [ "error", 4 ], "linebreak-style": [ "error", "unix" ], "quotes": [ "error", "single" ], "semi": [ "error", "never" ] &#125;&#125;]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯企业邮 PHP SDK]]></title>
    <url>%2Fnews%2F2018%2Ftencent-mail.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[腾讯 AI PHP SDK]]></title>
    <url>%2Fnews%2F2018%2Ftencent-ai.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-php/tencent-ai]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes 的包管理工具 Helm]]></title>
    <url>%2Fdocker%2Fk8s%2Fhelm.html</url>
    <content type="text"><![CDATA[yum apt 对于 Linux 是什么，Helm 对于 Kubernetes 就是什么。 下载二进制文件需要 特殊的网络，建议使用 Docker 镜像构建服务进行下载。 https://github.com/khs1994-docker/download https://github.com/khs1994-docker/lnmp-k8s/blob/master/docs/helm.md init 初始化服务端]]></content>
      <categories>
        <category>K8s</category>
        <category>Helm</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>Helm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ansible 自动化运维工具]]></title>
    <url>%2Flinux%2Fansible.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/ansible/ansible https://www.ansible.com/]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[私有的对象存储 Minio]]></title>
    <url>%2Fcloud%2Fminio.html</url>
    <content type="text"><![CDATA[搭建一个私有的对象存储。 GitHub: https://github.com/khs1994-docker/lnmp/blob/master/docs/minio.md More Information https://me.csdn.net/dingjs520]]></content>
      <categories>
        <category>Cloud</category>
      </categories>
      <tags>
        <tag>Cloud</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP CLI]]></title>
    <url>%2Fphp%2Fbasic%2Fcli.html</url>
    <content type="text"><![CDATA[PHP CLI 模式下简介。 长时间执行 https://github.com/khs1994-docker/lnmp/issues/484 12345Fatal error: Maximum execution time of 30 seconds exceededini_set('max_execution_time', '0');set_time_limit(0); 多进程pcntl_* 系列函数。]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于 CoreOS 手动部署 Kubernetes]]></title>
    <url>%2Fdocker%2Fk8s%2Finstall.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-docker/lnmp-k8s/tree/master/coreos 分为 master 和 worker 节点。 部署 Etcd 集群 flannel 将网络配置写入 Etcd 集群，并配置 Docker 网络设置 Docker 根据网络配置启动 启动 Kubernetes 组件]]></content>
      <categories>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Patch 详解]]></title>
    <url>%2Flinux%2Fshell%2Fpatch.html</url>
    <content type="text"><![CDATA[*.patch 可以给文件打补丁。]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codecov 展示代码覆盖率]]></title>
    <url>%2Fci%2Fcodecov%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：https://codecov.io GitHub：https://github.com/codecov/codecov-bash Example：https://github.com/codecov/example-php Example: https://github.com/khs1994-php/tencent-ai 由于网站部分资源从 google 加载，国内可能访问不畅！ 本文以 PHP 为例。 前置知识： PHPUnit Codecov 本身不做构建，其只是分析代码报告，然后展示出来，所以还是得配合 Travis CI 等构建工具来使用。 Travis CI 进行代码测试，生成报告 使用命令行上传这个报告 Codecov 分析报告，然后展示出来 123456789101112# 生成报告命令$ vendor/bin/phpunit --coverage-clover=coverage.xml$ export CODECOV_TOKEN=XXX# Travis CI 等 Codecov 支持的 CI 工具无需设置 Token，若在本地测试需要设置 Token# 注意此步不要写在构建脚本中，这里列出只是方便告诉大家需要的环境变量，具体的 Token 值请在仓库的设置中查看# 使用上传脚本，上传测试报告，当然也提供其他语言的脚本，自行查看文档$ bash &lt;(curl -s https://codecov.io/bash) 在 CI 的 Docker 中如何使用？ https://docs.codecov.io/docs/testing-with-docker 12345678# request codecov to detect CI environment to pass through to docker$ ci_env=`bash &lt;(curl -s https://codecov.io/env)`$ docker run $ci_env ...# exec tests$ bash &lt;(curl -s https://codecov.io/bash) More Information https://segmentfault.com/a/1190000007221668 https://blog.csdn.net/gdky005/article/details/73330337]]></content>
      <categories>
        <category>CI</category>
        <category>Codecov</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Codecov</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 多进程 pcntl]]></title>
    <url>%2Fphp%2Fbasic%2Fpcntl.html</url>
    <content type="text"><![CDATA[pcntl_* 系列函数介绍。 http://php.net/manual/zh/ref.pcntl.php $pid = pcntl_fork() 之后，当前进程和 fork 出来的子进程同时执行。 我们通过判断 $pid 来判断当前进程是哪个进程。 $pid 为 0 时为子进程，$pid 为 -1 时子进程创建失败。其他为当前进程。 pcntl_wait() 等待或返回 fork 的子进程状态 pcntl_wifexited() 检查子进程状态代码是否代表正常退出 123456789101112131415161718192021$ppid = posix_getppid();$pid = pcntl_fork();if ($pid === -1) &#123; echo "error";&#125;;if ($pid === 0) &#123; echo "子进程 ..."; sleep(10);&#125; else &#123; echo "父进程 $ppid ..."; // 等待或返回 fork 的子进程状态 pcntl_wait($status, WUNTRACED); // 检查状态代码是否代表一个正常的退出 if(pcntl_wifexited($status))&#123; return; &#125;;&#125;]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[svn 命令详解]]></title>
    <url>%2Fgit%2Fsvn.html</url>
    <content type="text"><![CDATA[本文简要介绍 SVN。]]></content>
      <categories>
        <category>SVN</category>
      </categories>
      <tags>
        <tag>SVN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 加密函数]]></title>
    <url>%2Fphp%2Fauth%2Fencrypt.html</url>
    <content type="text"><![CDATA[hash() password_hash() 1234567hash($algo, $data [, $raw_output])// algo 加密算法，可以通过 hash_algos() 函数查看password_hash ( string $password , int $algo [, array $options ] )// algo 加密算法，通过 PASSWORD_* 常量设置]]></content>
      <categories>
        <category>PHP</category>
        <category>Auth</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 输出控制]]></title>
    <url>%2Fphp%2Fbasic%2Foutcontrol.html</url>
    <content type="text"><![CDATA[本文介绍 PHP ob_* 系列函数。 http://php.net/manual/zh/ref.outcontrol.php ob_flush() 是刷新 PHP 自身的缓冲区 flush() 只有在 PHP 做为 Apache 的 Module 安装的时候, 才有实际作用。它是刷新 WebServer (可以认为特指 Apache )的缓冲区。 正确使用两者的顺序是。 先 ob_flush(), 然后 flush(), 为了保证你代码的可移植性, 建议配套使用。 NGINX可以增加响应头 header(&#39;X-Accel-Buffering: no&#39;);]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML5 Server-Sent Events + PHP]]></title>
    <url>%2Fphp%2Fbasic%2Fsse.html</url>
    <content type="text"><![CDATA[本文介绍 Server-Sent Events 服务器发送事件 SSE。 HTML5 SSE 事件允许网页获得来自服务器的更新。 12345678910var source = new EventSource("demo_sse.php");source.onmessage=function(event) // 当接收到消息&#123; document.getElementById("result").innerHTML += event.data + "&lt;br&gt;";&#125;;source.onopen(); // 当通往服务器的连接被打开source.onerror(); // 当发生错误 123456789101112131415ini_set('max_execution_time', '0');header('X-Accel-Buffering: no');header('Content-Type: text/event-stream');header('Cache-Control: no-cache');while(1)&#123; // id event retry data \n\n echo "id: 1\nevent: my_event\nretry: 100\ndata: my_data \n\n"; ob_flush(); flush(); sleep(1);&#125; retry 服务器端 N 秒内没有发送任何信息，则开始重连。 More Information https://blog.csdn.net/kkgbn/article/details/53159791 https://my.oschina.net/u/3095457/blog/1036952]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Websocket]]></title>
    <url>%2Fphp%2Fbasic%2Fwebsocket.html</url>
    <content type="text"><![CDATA[WebSocket 是一种在单个 TCP 连接上进行全双工通讯的协议。 123456789101112131415var ws = new WebSocket(url, [protocol] );var ws = new WebSocket("ws://example.com", [protocol] );ws.onopen = function ()&#123; ws.send('message');&#125;ws.onmessage = function (evt)&#123; var received = evt.data;&#125;ws.onclose = function ()&#123;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>HTML</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨平台终端 Hyper]]></title>
    <url>%2Ftools%2Fhyper.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/zeit/hyper 相关讨论：https://github.com/khs1994-docker/lnmp/issues/490]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Hyper</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sami -- PHP API 文档生成工具]]></title>
    <url>%2Fphp%2Flibrary%2Fsami.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/php-demo/blob/master/.sami.php 123$ curl -L http://get.sensiolabs.org/sami.phar -o sami# mv to path Edit .sami.php 1$ sami update]]></content>
      <categories>
        <category>PHP</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX Unit]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Funit.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/lnmp/tree/master/wsl#try-nginx-unit]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Crontab]]></title>
    <url>%2Flinux%2Fcrontab.html</url>
    <content type="text"><![CDATA[12345$ crontab -l$ crontab -e* * * * * * /path/command &gt;&gt; /tmp/crontab.log 1m h dom(day of month) month dow(day of week) command]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 存储 NoSQL 数据]]></title>
    <url>%2Fdatabase%2Fmysql%2Fnosql.html</url>
    <content type="text"><![CDATA[MySQL 存储 JSON 官方文档：https://dev.mysql.com/doc/refman/8.0/en/json-function-reference.html 1234567mysql&gt; CREATE TABLE tb1(c1 JSON);mysql&gt; INSERT INTO tb1 VALUSE('&#123;"key"=&gt;1&#125;');mysql&gt; SELECT json_array('a','b',now()); # ['a','b',time]mysql&gt; SELECT json_object('key1',1,'key2',2); # &#123;'ksy1':1,'key2',2&#125; 函数详解创建 json_array() json_merge() =&gt; JSON_MERGE_PRESERVE()(8.0) JSON_MERGE_PATCH() json_object() 查询 json_contains() json_contains_path() json_extract() json_keys() json_search() 修改 json_append()（8.0 废弃） =&gt; JSON_ARRAY_APPEND() json_array_insert() json_insert() 对于原文本中已存在的键值，采取跳过而不覆盖的策略。 json_remove() json_replace() json_set() json_quote() 转义引号 json_unquote() Mete json_depth() json_length() json_type() json_valid()]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Doctrine Cache -- PHP 缓存库]]></title>
    <url>%2Fphp%2Flibrary%2FdoctrineCache.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/doctrine/cache 官方文档：http://doctrine-orm.readthedocs.io/projects/doctrine-orm/en/latest/reference/caching.html 1$ composer require "doctrine/cache" 123$cache = new FilesystemCache(sys_get_temp_dir());$cache-&gt;save('k', 'v', $expire_time);]]></content>
      <categories>
        <category>PHP</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dotenv -- PHP .env 转变为 $_ENV]]></title>
    <url>%2Fphp%2Flibrary%2Fdotenv.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/vlucas/phpdotenv 1$ composer require vlucas/phpdotenv 12345$dotenv = new Dotenv\Dotenv(__DIR__);# $dotenv = new Dotenv\Dotenv(__DIR__, 'my_env_file_name');$dotenv-&gt;load();]]></content>
      <categories>
        <category>PHP</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pimple -- PHP 依赖注入容器]]></title>
    <url>%2Fphp%2Flibrary%2Fpimple.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/silexphp/Pimple]]></content>
      <categories>
        <category>PHP</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-CS-Fixer -- PHP 代码格式化工具]]></title>
    <url>%2Fphp%2Flibrary%2Fphp-cs-fixer.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/php-demo/blob/master/.php_cs 12345$ curl -L https://cs.sensiolabs.org/download/php-cs-fixer-v2.phar -o php-cs-fixer$ sudo mv php-cs-fixer /usr/local/bin$ sudo chmod +x /usr/local/bin/php-cs-fixer Edit .php_cs 1$ php-cs-fixer fix]]></content>
      <categories>
        <category>PHP</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Monolog -- PHP 日志库]]></title>
    <url>%2Fphp%2Flibrary%2Fmonolog.html</url>
    <content type="text"><![CDATA[官方网站：https://seldaek.github.io/monolog/ GitHub：https://github.com/Seldaek/monolog 1$ composer require monolog/monolog 12345678// create a log channel$log = new Logger('name');$log-&gt;pushHandler(new StreamHandler('/path/to/your.log', Logger::WARNING));// add records to the log// 之后只能调用 warning 以上级别$log-&gt;warning('Foo');$log-&gt;error('Bar');]]></content>
      <categories>
        <category>PHP</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Guzzle -- HTTP 客户端库]]></title>
    <url>%2Fphp%2Flibrary%2Fguzzle.html</url>
    <content type="text"><![CDATA[Guzzle 是 PHP HTTP 客户端库。 官方文档：http://docs.guzzlephp.org/en/stable/ 中文文档：http://guzzle-cn.readthedocs.io/zh_CN/latest/overview.html 1$ composer require guzzlehttp/guzzle 123456789$client = new \GuzzleHttp\Client();$res = $client-&gt;request('GET', 'http://baidu.com');$res-&gt;getStatusCode();$res-&gt;getHeaderLine('content-type');$res-&gt;getBody();]]></content>
      <categories>
        <category>PHP</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPMailer PHP 电子邮件库]]></title>
    <url>%2Fphp%2Flibrary%2Fphpmailer.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/PHPMailer/PHPMailer]]></content>
      <categories>
        <category>PHP</category>
        <category>Library</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 服务容器（资料聚合）]]></title>
    <url>%2Fphp%2Fdesign_pattern%2Fcontainer%2FREADME.html</url>
    <content type="text"><![CDATA[IOC 控制反转 DI 依赖注入 https://github.com/khs1994-php/php_di 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// 实现容器// DB 类 Session 类 FileSystem 类 省略class Container&#123; public $bindings; /** * 将 闭包 与 别名 对应起来，和注册树模式差不多 */ public function bind($abstract,$concrete)&#123; $this-&gt;bindings[$abstract]=$concrete; &#125; // 调用 public function make($abstract,$parameters=[])&#123; return call_user_func_array($this-&gt;bindings[$abstract],$parameters); // 参数传入 回调函数，完成类实例化（返回的是一个对象，即类的实例） &#125;&#125;// 服务注册$container=new Container();$container-&gt;bind('db',function($arg1,$arg2)&#123; // 回调函数中实例化类，即返回对象 return new DB($arg1,$arg2);&#125;);$container-&gt;bind('session',function($arg1,$arg2)&#123; return new Session($arg1,$arg2);&#125;);$container-&gt;bind('fs',function($arg1,$arg2)&#123; return new FileSystem($arg1,$arg2);&#125;);// 容器依赖class Writer&#123; protected $_db; protected $_filesystem; protected $_session; protected $container; public function Writer(Container $container)&#123; // 将对象赋值给对象属性 $this-&gt;_db=$container-&gt;make('db',[1,2]); $this-&gt;_filesystem=$container-&gt;make('session',[3,4]); $this-&gt;_session=$container-&gt;make('fs',[5,6]); &#125;&#125;$writer=new Writer($container); 依赖注入依赖注入是通过类的构造函数、方法、或者直接写入的方式，将所依赖的组件传递给类的方式。 1234567class User&#123; function __construct($storage) &#123; $this-&gt;storage = $storage; &#125;&#125; 1234567class User&#123; function setSessionStorage($storage) &#123; $this-&gt;storage = $storage; &#125;&#125; 123456class User&#123; public $sessionStorage;&#125;$user-&gt;sessionStorage = $storage; 只要不是由内部生产（比如初始化、构造函数中通过工厂方法、自行手动 new 的），而是由外部以参数或其他形式注入的，都属于 依赖注入（DI）。 根据经验，一般通过构造函数注入的是强依赖关系的组件，setter 方式用来注入可选的依赖组件。 反转所谓的反转，主要指由 主动依赖 到 被动依赖 。 123456789//主动依赖function __construct() &#123; $this-&gt;user = new UserModel();&#125;//被动依赖function __construct(UserModel $user) &#123; $this-&gt;user = $user;&#125; Links https://www.cnblogs.com/sweng/p/6430374.html https://laravel-china.org/topics/789/laravel-learning-notes-the-magic-of-the-service-container https://laravel-china.org/topics/1954/on-laravel-design-pattern]]></content>
      <categories>
        <category>PHP</category>
        <category>Design_Pattern</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Design_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代码风格统一工具 EditorConfig]]></title>
    <url>%2Ftools%2Feditorconfig.html</url>
    <content type="text"><![CDATA[官方网站：http://editorconfig.org/ GitHub：https://github.com/editorconfig More Information https://www.jianshu.com/p/270106f66c46]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>EditorConfig</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-pm]]></title>
    <url>%2Fphp%2Flibrary%2Fphp-pm.html</url>
    <content type="text"><![CDATA[PHP Process Manager 简称 PPM GitHub：https://github.com/php-pm/php-pm 不知道是个什么玩意儿，先记录一下。]]></content>
      <categories>
        <category>PHP</category>
        <category>Project</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPDoc tag 参考]]></title>
    <url>%2Fphp%2Fphpdoc%2Ftag.html</url>
    <content type="text"><![CDATA[官方文档: https://docs.phpdoc.org/references/phpdoc/index.html]]></content>
      <categories>
        <category>PHP</category>
        <category>PHPDoc</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[phpDocumentor 介绍]]></title>
    <url>%2Fphp%2Fphpdoc%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：https://www.phpdoc.org/ GitHub: https://github.com/phpDocumentor 123456/** * @version 18.06 * * @method static staticMethod() * @property property */]]></content>
      <categories>
        <category>PHP</category>
        <category>PHPDoc</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPDoc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX 编译选项]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Fconfigure.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-php/nginx-configure]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 编译选项]]></title>
    <url>%2Fphp%2Fdevelopment%2Fconfigure.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-php/configure]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 杂项记录]]></title>
    <url>%2Fphp%2Flibrary%2FREADME.html</url>
    <content type="text"><![CDATA[记录一些 PHP 知识。 系统环境变量php.ini 123; http://php.net/manual/zh/ini.core.php#ini.variables-ordervariables_order = "GPCS" 此时 $_ENV 数组为空，此时可以通过 getenv(&#39;var&#39;) 获取变量对应的值。当没有值传入时，返回包含全部系统变量的关联数组。 若设置为 EGPCS ，此时 $_ENV 包含有系统的环境变量。 eval() eval() 把字符串作为 PHP 代码执行 eval(&#39;echo 1;&#39;) fastcgi_finish_request() PHP-FPM 结束网页请求，但后台 PHP 脚本仍然在执行。 纯 PHP 文件末尾不加 ?&gt; https://github.com/khs1994-docker/lnmp/issues/578]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PowerShell 资源]]></title>
    <url>%2Fother%2Fpowershell%2FREADME.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/PowerShell GitHub：https://github.com/PowerShell/powerShell-Docs.zh-cn 文档：https://docs.microsoft.com/zh-cn/powershell/scripting/powershell-scripting?view=powershell-6 读取系统环境变量1$ echo $env:Temp 永久生效就像我们在图形界面设置的一样 1$ [environment]::SetEnvironmentvariable("a", "1", "User") https://www.pstips.net/powershell-environment-variables.html 常用变量$PSScriptRoot 文件所在路径]]></content>
      <categories>
        <category>PowerShell</category>
      </categories>
      <tags>
        <tag>PowerShell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis Memcached 对比]]></title>
    <url>%2Fcache%2Fcompare.html</url>
    <content type="text"><![CDATA[Redis Memcached 对比 数据结构 Memcached 只支持 String REDIS String hash list set zset 主从Redis 支持主从 持久化Memcached 不能持久化 事务REDIS 支持事务 存储容量 Redis 512 MB Memcached 1 Mb 线程 Memcached 是多线程非阻塞 IO 复用的网络模型，分为 监听主线程 和 worker 子线程，监听线程监听网络连接，接受请求后，将连接描述字 pipe 传递给 worker 线程，进行读写 IO, 网络层使用 libevent 封装的事件库，多线程模型可以发挥多核作用，但是引入了cache coherency和锁的问题 Redis 使用单线程的 IO 复用模型，单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），其他模块仍用了多个线程。 More Information https://www.cnblogs.com/qq78292959/archive/2012/12/28/2836868.html]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Redis</tag>
        <tag>Memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[缓存的使用场景]]></title>
    <url>%2Fcache%2FREADME.html</url>
    <content type="text"><![CDATA[来源：https://link.zhihu.com/?target=http%3A//my.oschina.net/ydsakyclguozi/blog/404625 显示最新的项目列表 删除与过滤 排行榜相关 按照用户投票和时间排序 处理过期项目 计数 特定时间内的特定项目 实时分析正在发生的情况，用于数据统计与防止垃圾邮件等 Pub/Sub 队列 缓存]]></content>
      <categories>
        <category>Cache</category>
      </categories>
      <tags>
        <tag>Cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 哨兵模式 Sentinel]]></title>
    <url>%2Fcache%2Fredis%2Fsentinel.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/lnmp/blob/master/docker-cluster.redis.sentinel.yml https://redis.io/topics/sentinel http://www.redis.cn/topics/sentinel.html 监控（Monitoring）：Sentinel 会不断地检查你的主服务器和从服务器是否运作正常。 提醒（Notification）：当被监控的某个 Redis 服务器出现问题时， Sentinel 可以通过 API 向管理员或者其他应用程序发送通知。 自动故障迁移（Automatic failover）：当一个主服务器不能正常工作时， Sentinel 会开始一次自动故障迁移操作， 它会将失效主服务器的其中一个从服务器升级为新的主服务器，并让失效主服务器的其他从服务器改为复制新的主服务器；当客户端试图连接失效的主服务器时，集群也会向客户端返回新主服务器的地址，使得集群可以使用新主服务器代替失效服务器。]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 集群 Cluster]]></title>
    <url>%2Fcache%2Fredis%2Fcluster.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/lnmp/blob/master/docker-cluster.redis.yml https://redis.io/topics/cluster-tutorial http://www.redis.cn/topics/cluster-tutorial.html]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 PowerShell 操控 Hyper-V]]></title>
    <url>%2Fvm%2Fhyperv%2FREADME.html</url>
    <content type="text"><![CDATA[必须使用系统自带的 PowerShell。 获取虚拟机 IP 1$ (( Get-VM vm-name ).networkadapters[0]).ipaddresses[0]]]></content>
      <categories>
        <category>VM</category>
        <category>Hyper-V</category>
      </categories>
      <tags>
        <tag>PowerShell</tag>
        <tag>Hyper-V</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[khs1994.com PHP 项目 Docker 化规范]]></title>
    <url>%2Fphp%2Fdevelopment%2Fdocker.html</url>
    <content type="text"><![CDATA[khs1994.com 开发 PHP 项目 Docker 化最佳实践。 请查看：https://github.com/khs1994-docker/php-demo]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yarn 使用详解]]></title>
    <url>%2Fnodejs%2Fyarn.html</url>
    <content type="text"><![CDATA[与 npm 一样的 Node.js 包管理工具。 GitHub：https://github.com/yarnpkg/yarn]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 设计模式]]></title>
    <url>%2Fphp%2Fdesign_pattern%2FREADME.html</url>
    <content type="text"><![CDATA[工厂模式、单例模式、注册树模式… 工厂模式工厂方法或者类生成对象，而不是直接 new 对象。 123456789101112131415161718192021222324class Factory&#123; public static function createFactory($arg)&#123; // return new Docker($arg); // 单例模式 $docker = Instance::getInstance($arg); // 注册树模式 Register::set('docker',$docker); // 返回对象 // return $docker; &#125;&#125;$docker = Factory::createFactory($arg);$docker = Register::get('docker');$docker-&gt;container-&gt;list(); 单例模式某个类的对象仅允许创建一次。 三私一公。 12345678910111213141516171819202122232425262728Class Instance&#123; private $instance; // 构造函数为私有，外部不能直接 new private function __construct($arg)&#123; echo $arg; &#125; // 禁止对象被克隆 private function __clone()&#123; &#125; public static function getInstance($arg)&#123; if (!(self::$instance instanceof self))&#123; // 静态函数中 new 对象 self::$instance=new self(); &#125; return self::$instance; &#125;&#125;$docker = Instance::getInstance($arg);$docker-&gt;container-&gt;list(); 注册树模式全局共享和交换对象。 12345678910111213141516class R&#123; private static $obj; public static function set($name, $obj)&#123; self::obj[$name]=$obj; &#125; public static function unset()&#123; unset(self::$obj); &#125; public static function get($name)&#123; return self::$obj[$name]; &#125;&#125; 观察者模式将 观察者实例 注入到 主题 中 1234567891011121314151617181920212223242526272829303132333435// 主题class Subject&#123; public $observers; public function register(ObServer $observer)&#123; $this-&gt;observers[]=$arg; &#125; public function notify()&#123; foreach ($this-&gt;observers as $key) &#123; $key-&gt;watch(); &#125; &#125;&#125;// 观察者接口interface Observer&#123; public function watch();&#125;// 观察者class Cat implements Observer&#123; public function watch()&#123; echo "cat watch"; &#125;&#125;$subject = new Subject();$subject-&gt;register(new Cat());$subject-&gt;notify();]]></content>
      <categories>
        <category>PHP</category>
        <category>Design_Pattern</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Design_Pattern</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker for Mac 开启 Docker API]]></title>
    <url>%2Fdocker%2Fmac_docker_api.html</url>
    <content type="text"><![CDATA[参考链接：https://segmentfault.com/q/1010000008458880 参考链接：https://my.oschina.net/u/2306127/blog/777695 任选一种。 12345$ docker run -d \ -v /var/run/docker.sock:/var/run/docker.sock \ -p 2375:2375 \ bobrik/socat \ TCP4-LISTEN:2375,fork,reuseaddr UNIX-CONNECT:/var/run/docker.sock 12345$ docker run -d \ -p 2375:2375 \ -v /var/run/docker.sock:/var/run/docker.sock \ -e PORT=2375 \ shipyard/docker-proxy 之后打开浏览器 127.0.0.1:2375/version。 More Information Docker API]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 16.04 使用 Swift]]></title>
    <url>%2Fother%2Fswift%2FREADME.html</url>
    <content type="text"><![CDATA[本文介绍了在 Ubuntu 16.04 上使用 Swift。 官方网站：https://swift.org/ 安装依赖1$ sudo apt install clang libicu-dev 下载解压请到官方网站复制链接下载。 之后将文件的 /swift_path/usr/bin 路径加入 PATH。 简单使用Hello World!编写 hello.swift 文件。 1printf("Hello, World!") 编译，执行 12345$ swiftc hello.swift$ ./helloHello, World!]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CFSSL 简介]]></title>
    <url>%2Flinux%2Fssl%2Fcfssl.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/cloudflare/cfssl 我们可以使用 CFSSL 简单的签署 TLS 相关证书。 签署网站证书GitHub：https://github.com/khs1994-website/https/tree/master/cfssl 签署 k8s Docker Daemon etcd 等证书请查看上方内容。]]></content>
      <categories>
        <category>Linux</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>cfssl</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MNAMP 开发环境配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fmnamp.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-docker/lnmp/tree/master/macos]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WNAMP 开发环境配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fwnamp.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-docker/lnmp/tree/master/windows]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Style CI PHP 持续集成工具]]></title>
    <url>%2Fci%2Fstyleci%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：https://styleci.io/ Style CI 是专门针对于 PHP 的持续集成工具，具有 代码格式化 功能。 当然也支持其他语言（收费），具体到官网了解。 在项目根目录增加 .styleci.yml 文件，并在 StyleCI 官网打开项目构建开关即可开始使用。 示例：https://github.com/khs1994-php/tencent-ai 更新日志 https://docs.styleci.io/change-log]]></content>
      <categories>
        <category>CI</category>
        <category>Style CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Style CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CI/CD 免费工具介绍]]></title>
    <url>%2Fci%2FREADME.html</url>
    <content type="text"><![CDATA[本文介绍了免费的 CI/CD 服务。 GitHub：https://github.com/khs1994-php/tencent-ai 本文只列出服务网址，一般流程为 关联 Git 仓库 设置构建步骤 设置构建通知 具体步骤请查看官方文档，示例请查看 https://github.com/khs1994-php/tencent-ai Drone私有化 CI/CD 平台 https://www.khs1994.com/categories/CI/Drone/ Travis CIhttps://travis-ci.org Style CIhttps://styleci.io Aliyun CodePipelinehttps://www.aliyun.com/product/codepipeline Tencent Cloud Continuous Integrationhttps://cloud.tencent.com/product/cci Docker Build Powered By Tencent Cloud Container Servicehttps://cloud.tencent.com/product/ccs Docker Build Powered By Docker Cloudhttps://cloud.docker.com Docker Build Powered By Aliyun Container Servicehttps://www.aliyun.com/product/containerservice]]></content>
      <categories>
        <category>CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Drone CI/CD 用法举例]]></title>
    <url>%2Fci%2Fdrone%2Fusage.html</url>
    <content type="text"><![CDATA[官方文档：http://docs.drone.io/getting-started/ 官方文档：http://docs.drone.io/zh/getting-started/ Drone 本质就是在指定的 Docker 容器中执行命令。 与其他 CI/CD 类似，项目中必须包含 .drone.yml 文件来定义工作流，才能开始使用。 命令行工具https://github.com/drone/drone-cli/releases 下载之后移入 PATH 用法举例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143clone: git: image: plugins/git # # 克隆深度 # depth: 50 recursive: true submodule_override: # # 重写 git 子模块地址 # # @link http://plugins.drone.io/drone-plugins/drone-git/ # tests/resource: http://192.168.199.100:3000/khs1994/image.git## 默认克隆到 /drone/src/github.com/username/hello-world#workspace: base: /go # # 克隆到了 /go/src/github.com/octocat/hello-world # path: src/github.com/octocat/hello-world # # 克隆到 /go # path: .pipeline: backend: # # 每次构建时总是拉取镜像 # pull: true # # 同一 group 会并行执行 # group: build image: golang image: gcr.io/custom/golang environment: - CGO=0 - GOOS=linux - GOARCH=amd64 commands: - export PATH=$PATH:/go # - export PATH=$&#123;PATH&#125;:/go # $&#123;VAR&#125; 这类变量不能被解析 - export PATH=$$&#123;PATH&#125;:/go - sleep 15 - go get - go build - go test # # 特定状态才构建 # # @link http://docs.drone.io/conditional-steps/ # when: branch: master event: [push, pull_request, tag, deployment] # # 指定平台 # platform: linux/amd64 status: changed volumes: - /var/run/docker.sock:/var/run/docker.sock volumes: [ /etc/ssl/certs:/etc/ssl/certs ] privileged: true frontend: # # 同一 group 会并行执行 # group: build image: node:6 commands: - npm install - npm test publish: # # http://plugins.drone.io/drone-plugins/drone-docker/ # image: plugins/docker registry: registry.heroku.com repo: foo/bar tags: latest when: # # $ drone deploy octocat/hello-world 24 staging # # 命令行执行 deploy 命令才会执行 # event: deployment environment: staging # username: username # password: password # # 密钥这里小写，实际系统引用的时候会自动变成大写 # secrets: [ docker_username, docker_password ] secrets: - source: docker_prod_password target: docker_password notify: image: plugins/slack channel: developers username: drone when: status: [ success, failure ] services: # # 服务使用 mysql 作为 host,下同 # mysql: image: mysql environment: - MYSQL_DATABASE=test - MYSQL_ALLOW_EMPTY_PASSWORD=yes redis: image: redis# 只构建以下分支branches: masterbranches: [ master, dev]branches: include: [ master, feature/* ]# 除了以下分支，都构建branches: exclude: [ develop, feature/* ] 跳过构建commit 信息加上 [ci skip]。 1$ git commit -m "updated README [CI SKIP]" 矩阵构建http://docs.drone.io/zh/matrix-builds/ 123456789101112pipeline: build: image: $&#123;IMAGE&#125; commands: - go build - go testmatrix: IMAGE: - golang:1.7 - golang:1.8 - golang:latest 密钥Docker 仓库相关密钥构建过程需要私有仓库镜像，这个配置来使得 drone 能够拥有相关权限 123456$ drone registry add \ --repository username/hello-world \ --hostname gcr.io \ # --hostname docker.io \ --username &lt;name&gt; \ --password &lt;value&gt; 增加密钥12345$ drone secret add \ -repository username/hello-world \ -image plugins/docker \ -name docker_username \ -value &lt;value&gt; 指定的事件才能使用这个密钥。 12345678$ drone secret add \ -repository username/hello-world \ -image plugins/docker \ -event pull_request \ -event push \ -event tag \ -name docker_username \ -value &lt;value&gt; 系统内置变量http://docs.drone.io/environment-reference/]]></content>
      <categories>
        <category>CI</category>
        <category>Drone</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 从入门到实践 PDF 下载地址]]></title>
    <url>%2Fdocker%2Fdocker_practice.html</url>
    <content type="text"><![CDATA[《Docker 从入门到实践》 GitHub：https://github.com/yeasy/docker_practice GitBook：https://www.gitbook.com/book/yeasy/docker_practice/details 《Docker 从入门到实践》是一本托管于 GitBook 的开源书籍。 国内访问 GitBook 有时会遇到困难，而百度的搜索结果中的 PDF 下载地址都是他人的二次传播，几乎都是过时内容。 作为 《Docker 从入门到实践》 的项目维护者，本人列出了 《Docker 从入门到实践》 官方提供的地址。 PDF 下载GitHub：https://github.com/yeasy/docker_practice/releases 码云：https://gitee.com/docker_practice/docker_practice/releases 百度文库： GitHub项目地址：https://github.com/yeasy/docker_practice 直接阅读：https://github.com/yeasy/docker_practice/blob/master/SUMMARY.md GitBook项目地址：https://www.gitbook.com/book/yeasy/docker_practice/details 直接阅读：https://yeasy.gitbooks.io/docker_practice/content/ 国内镜像 选择 码云 作为镜像的原因是其提供了一键同步的功能。 码云项目地址：https://gitee.com/docker_practice/docker_practice 直接阅读：https://docker_practice.gitee.io/ 百度文库直接阅读： 更多信息 https://github.com/justjavac/free-programming-books-zh_CN]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX 配置 TLSv1.3]]></title>
    <url>%2Flinux%2Fssl%2Fhttps%2FREADME.html</url>
    <content type="text"><![CDATA[将 即将 发布的 TLSv1.3 作为 https 系列的开篇。 GitHub：https://github.com/khs1994-website/tls-1.3 一键部署khs1994-docker/lnmp 原生支持 TLSv1.3。 PHP 开发者可以使用此项目一键部署 TLSv1.3。 本站其他相关文章 NGINX https 配置 Let’s Encrypt SSL 证书配置详解 Https 标签下的文章 浏览器环境 务必使用最新测试版浏览器测试 TLSv1.3，请首先升级浏览器版本，否则后边的做法没有任何意义。 Chrome dev 版本 FireFox beta 版本 Chrome Android dev 版本 从 GitHub 克隆 openssl 源码12345$ git clone -b master --depth=1 https://github.com/openssl/openssl /srv/openssl# 国内镜像$ git clone -b master --depth=1 https://gitee.com/mirrors/openssl.git /srv/openssl 你可能查看有的教程克隆了 tls1.3-draft-18 分支，注意此草案已经过了很久，最新草案 已经更新到了 24 版本。最新草案已集成到 master 分支，我们这里直接克隆 master 分支即可。 编译安装 NGINX主要添加以下两项 12--with-openssl=/srv/openssl--with-openssl-opt='enable-tls1_3' NGINX 编译安装请查看 https://www.khs1994.com/php/development/nginx/build.html Docker本人使用 Dockerfile 构建镜像，更多信息请查看这里 https://github.com/khs1994-website/tls-1.3 你可以很方便的 pull 我构建好的镜像测试 TLSv1.3 nginx 配置下面的配置很可能会发生变化，最新配置请查看 GitHub。 123456server &#123; # 为了测试各浏览器对 TLSv1.3 的支持，这里只保留 TLSv1.3 ssl_protocols TLSv1.3; ssl_ciphers TLS13-CHACHA20-POLY1305-SHA256:TLS13-AES-128-GCM-SHA256:TLS13-AES-256-GCM-SHA384:EECDH+CHACHA20:EECDH+CHACHA20-draft:EECDH+AES128:RSA+AES128:EECDH+AES256:RSA+AES256:EECDH+3DES:RSA+3DES:!MD5;&#125; 如果有多个子域名配置，必须保证每个配置项中 (server{ }) 都启用了 TLSv1.3。 浏览器访问测试。 Chrome 打开 Chrome://flags 搜索 TLS 选择 Enable ***，不同 Chrome 版本的选项不同，选一个 Enable 开头的就对了。 火狐 我用的 beta 版，默认已打开相关选项，无需配置。 我这里只记录相关操作需要注意的地方，细节等详细信息请查看下面的链接。 参考链接 https://imququ.com/post/enable-tls-1-3.html https://www.mf8.biz/nginx-tls1-3-draft/ 又拍云支持 TLSv1.3]]></content>
      <categories>
        <category>Linux</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>https</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自签名 SSL 网站证书]]></title>
    <url>%2Flinux%2Fssl%2Fhttps%2Fself-signed-ssl-certificates.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/tls 本站其他相关文章 NGINX https 配置 Let’s Encrypt SSL 证书配置详解 Https 标签下的文章 自签名证书详解这里假设想要签署 SSL 的网站为 docker.domain.com，下面我们介绍使用 openssl 自行签发 docker.domain.com 的站点 SSL 证书。 1. 创建 CA 私钥。1$ openssl genrsa -out "root-ca.key" 4096 2. 利用私钥创建 CA 根证书请求文件。1234$ openssl req \ -new -key "root-ca.key" \ -out "root-ca.csr" -sha256 \ -subj '/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=Your Company Name Docker Registry CA' 以上命令中 -subj 参数里的 /C 表示国家，如 CN；/ST 表示省；/L 表示城市或者地区；/O 表示组织名；/CN 通用名称。 3. 配置 CA 根证书，新建 root-ca.cnf。1234[root_ca]basicConstraints = critical,CA:TRUE,pathlen:1keyUsage = critical, nonRepudiation, cRLSign, keyCertSignsubjectKeyIdentifier=hash 4. 签发根证书。1234$ openssl x509 -req -days 3650 -in "root-ca.csr" \ -signkey "root-ca.key" -sha256 -out "root-ca.crt" \ -extfile "root-ca.cnf" -extensions \ root_ca 5. 生成站点 SSL 私钥。1$ openssl genrsa -out "docker.domain.com.key" 4096 6. 使用私钥生成证书请求文件。12$ openssl req -new -key "docker.domain.com.key" -out "site.csr" -sha256 \ -subj '/C=CN/ST=Shanxi/L=Datong/O=Your Company Name/CN=docker.domain.com' 7. 配置证书，新建 site.cnf 文件。1234567[server]authorityKeyIdentifier=keyid,issuerbasicConstraints = critical,CA:FALSEextendedKeyUsage=serverAuthkeyUsage = critical, digitalSignature, keyEnciphermentsubjectAltName = DNS:docker.domain.com, IP:127.0.0.1subjectKeyIdentifier=hash 8. 签署站点 SSL 证书。123$ openssl x509 -req -days 750 -in "site.csr" -sha256 \ -CA "root-ca.crt" -CAkey "root-ca.key" -CAcreateserial \ -out "docker.domain.com.crt" -extfile "site.cnf" -extensions server 这样已经拥有了 docker.domain.com 的网站 SSL 私钥 docker.domain.com.key 和 SSL 证书 docker.domain.com.crt。 将 root-ca.crt 导入浏览器中，之后配置好 Web 服务器并重启。]]></content>
      <categories>
        <category>Linux</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>https</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 WSL 操控 Docker for Windows]]></title>
    <url>%2Fdocker%2Fwsl-run-docker-cli.html</url>
    <content type="text"><![CDATA[当然，理论上可以操控任意的远程 Docker Daemon。 注意：不要误认为是在 WSL 运行 Docker,这是完全没有可能的。 Docker for Windows 设置设置中打开 2375 端口，这里不再赘述。 下载文件注意替换为最新版本号 国内地址 1$ curl -SL http://mirrors.ustc.edu.cn/docker-ce/linux/static/test/x86_64/docker-17.12.0-ce-rc4.tgz | tar -zxvf - 官方地址 1$ curl -SL https://download.docker.com/linux/static/test/x86_64/docker-17.12.0-ce-rc4.tgz | tar -zxvf - 移入 PATH12345$ sudo cp docker/docker /usr/local/bin/docker$ rm -rf docker$ docker --version 命令行补全1$ sudo curl -L https://raw.githubusercontent.com/docker/docker-ce/master/components/cli/contrib/completion/bash/docker -o /etc/bash_completion.d/docker 设置环境变量编辑 ~/.bash_profile 1export DOCKER_HOST="tcp://127.0.0.1:2375" 退出终端重新登录 1$ docker info 高级玩法完全在 WSL 中操控 Docker 123456789$ ln -sf /mnt/c /C$ cd /C$ docker run -it --rm -v $PWD:/C busybox sh$ cd /C$ ls 原理 Windows Docker 服务端将 C 盘挂载到了 /C 所以我们在 WSL 中也将 C 盘软链接到 /C,这样在 WSL /C 中使用 Docker 就可以使用 $PWD 变量挂载本地文件了。 当然也可以通过 WSL 的配置文件将 C 盘直接挂载到 /c，具体请查看下边的链接 https://github.com/khs1994-docker/lnmp/blob/master/wsl/config/wsl.conf]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSL 快速搭建 LNMP 环境]]></title>
    <url>%2Fphp%2Fdevelopment%2Fwsl.html</url>
    <content type="text"><![CDATA[Windows Subsystem for Linux（简称 WSL ）是一个为在 Windows 10 上能够原生运行 Linux 二进制可执行文件（ELF 格式）的兼容层。 注意。PHP-FPM 暂时只能通过监听 socket ,不能设置 listen 127.0.0.1:9000！ GitHub：https://github.com/khs1994-php/wsl 修订记录 PHP-FPM 与 NGINX 只能通过 socket 方式连接，之前页面打开太慢解决不了，查看 GitHub 解决了该问题。解决办法：https://github.com/Microsoft/WSL/issues/2100 Windows 支持 Debian 9 我们可以在 Docker 中编译 PHP 之后将编译好的文件复制出来即可，本人目前采用此方法。 如何启用 WSL 这里不再赘述，下方执行命令过程中出错，可以使用 sudo 再次尝试执行。 软件列表基于如下软件 WSL Debian 9 nginx 1.13.9 PHP 7.2.3 Mysql 5.7.20 nginx编辑 /etc/apt/sources.list.d/nginx.list 文件。 1deb http://nginx.org/packages/mainline/ubuntu/ xenial nginx 添加密钥 1$ curl -fsSL http://nginx.org/packages/keys/nginx_signing.key | sudo apt-key add - 安装 12345$ sudo apt update$ sudo apt install nginx$ sudo nginx 打开 127.0.0.1 看到 nginx 默认页面。 新增配置文件apt 安装的 nginx 没有 fastcgi.conf 配置文件，我们必须手动加入 123$ cd /etc/nginx$ sudo wget https://raw.githubusercontent.com/khs1994-docker/lnmp/master/config/etc/nginx/fastcgi.conf 修改主配置文件https://github.com/Microsoft/WSL/issues/2100 解决 PHP 页面打开缓慢 123456789$ sudo vi /etc/nginx/nginx.confhttp &#123; ... fastcgi_buffering off; # 新加入此项 ...&#125; PHP详细编译说明请查看：https://www.khs1994.com/php/development/build.html 从 Docker 复制编译好的 PHP 请查看 GitHub，有疑问请提出 issue. MySQL使用 Docker for Windows1$ docker run -it -d --name wsl-lnmp-mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD=mytest -e MYSQL_DATABASE=test --mount src=wsl-lnmp-mysql-data,target=/var/lib/mysql mysql 使用 WSL1$ sudo apt install mysql-server nginx 配置编辑 /etc/nginx/conf.d/php.conf 12345678910111213141516171819202122server &#123; server_name 127.0.0.1; listen 80; root /app/test; index index.html index.php; location / &#123; try_files $uri $uri/ /index.php?$query_string; &#125; location ~ .*\.php(\/.*)*$ &#123; # fastcgi_pass 127.0.0.1:9000; # # WSL 中请勿使用该配置 # fastcgi_pass unix:/run/php-fpm.sock; fastcgi_index index.php; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; include fastcgi_params; &#125;&#125; 尝试通过 pecl 安装 PHP 扩展执行过程中若提示错误，请使用 sudo 123$ sudo pecl update-channels$ sudo pecl install redis memcached ... 编辑配置文件 /usr/local/php/etc/php.ini 在文件开头添加 123extension=redisextension=memcached]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>LNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 桌面版支持 kubernetes]]></title>
    <url>%2Fdocker%2Fdocker-with-k8s.html</url>
    <content type="text"><![CDATA[Docker for Mac &amp; Windows 支持 k8s。 修订记录 稳定版已经支持 k8s 网络环境需要从 gcr.io 拉取镜像，国内网络一般不能够拉取到镜像！ 解决办法请查看 https://github.com/khs1994-docker/lnmp/issues/520 相关文章 bring Kubernetes support to the Docker Docker blog k8s 视频：https://www.bilibili.com/video/av17307986/ kubectl之前使用 brew 安装了 kubectl 请先卸载。 1$ brew remove kubernetes-cli 之前你可能使用了 minikube ，使用以下命令切换到 docker-for-desktop。 1234567891011$ kubectl config get-contextsCURRENT NAME CLUSTER AUTHINFO NAMESPACE docker-for-desktop docker-for-desktop-cluster docker-for-desktop* minikube minikube minikube$ kubectl config use-context docker-for-desktop# 切换回 minikube 的命令$ kubectl config use-context minikube 启用在 Docker 设置中启用 k8s，具体图解请查看 官方文档。 查看集群详情123456$ kubectl cluster-infoKubernetes master is running at https://localhost:6443KubeDNS is running at https://localhost:6443/api/v1/namespaces/kube-system/services/kube-dns/proxyTo further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. 查看节点1234$ kubectl get nodeNAME STATUS ROLES AGE VERSIONdocker-for-desktop Ready master 8h v1.8.2 使用虽然 Docker 桌面版上的 k8s 支持使用 compose 文件进行部署。 但为了更好的学习，建议使用 kubectl 及 *.yaml 文件进行学习。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kubectl 国内镜像]]></title>
    <url>%2Fdocker%2Fk8s%2Fkubectl-cn-mirror.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/khs1994-docker/kubectl-cn-mirror 浏览器直接下载：https://code.aliyun.com/khs1994-docker/kubectl-cn-mirror/tree/master 要下载不同的版本，请切换左上角的标签。]]></content>
      <categories>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQLECTRON 一个轻量的 SQL 图形客户端]]></title>
    <url>%2Ftools%2Fsqlectron.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/sqlectron/sqlectron-gui 官方网站：http://sqlectron.github.io/ SQLECTRON 是一个轻量的 SQL 图形客户端。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.2 废弃 mcrypt]]></title>
    <url>%2Fphp%2Frelease%2F7.2%2Fmcrypt.html</url>
    <content type="text"><![CDATA[官方文档说明：http://php.net/manual/zh/migration71.deprecated.php mcrypt 文档：http://php.net/manual/zh/ref.mcrypt.php openssl 文档：http://php.net/manual/zh/book.openssl.php 使用 openssl 来替代 mcrypt More Information http://www.oschina.net/news/91144/php-adds-support-for-next-gen-password-hashing-algorithm-argon2 http://www.ptbird.cn/mcrypt-wxxcx-php7.html]]></content>
      <categories>
        <category>PHP</category>
        <category>Release</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kubernetes 概念总览]]></title>
    <url>%2Fdocker%2Fk8s%2FREADME.html</url>
    <content type="text"><![CDATA[k8s 已经成为容器集群编排、管理工具的事实领导者。 PodPod 是一组紧密关联的容器集合 ConfigMapSecretServiceDeploymentPersistentVolumeClaim而 PVC 和 Pod 是资源的使用者，根据业务服务的需求变化而变化，由 K8s 集群的使用者即服务的管理员来配置 PersistentVolumePV 和 Node 是资源的提供者，根据集群的基础设施变化而变化，由K8s集群管理员配置 API 对象 metadata spec status]]></content>
      <categories>
        <category>K8s</category>
      </categories>
      <tags>
        <tag>K8s</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内使用 minikube]]></title>
    <url>%2Fdocker%2Fk8s%2Fminikube.html</url>
    <content type="text"><![CDATA[OS：macOS GitHub：https://github.com/khs1994-docker/minikube GitHub: https://github.com/kubernetes/minikube 本文基于 0.25.0 版本 修订记录 2018-01-27：Minikube 0.25.0 已经发布，请查看阿里云文章：https://yq.aliyun.com/articles/221687 2018-01-15：请在之前看过我文章的务必按照本文重新安装配置 minikube 2018-01-15：由于阿里云的 localkube 出现问题（已反馈给相关人员），暂时只能使用我编译的 localkube。 特别注意请直接查看 阿里云文章 不要再按本文方法使用。 镜像列表1234567gcr.io/google_containers/kubernetes-dashboard-amd64 v1.8.0 55dbc28356f2 6 weeks ago 119MBgcr.io/k8s-minikube/storage-provisioner v1.8.1 4689081edb10 2 months ago 80.8MBgcr.io/google_containers/k8s-dns-sidecar-amd64 1.14.5 fed89e8b4248 3 months ago 41.8MBgcr.io/google_containers/k8s-dns-kube-dns-amd64 1.14.5 512cd7425a73 3 months ago 49.4MBgcr.io/google_containers/k8s-dns-dnsmasq-nanny-amd64 1.14.5 459944ce8cc4 3 months ago 41.4MBgcr.io/google-containers/kube-addon-manager v6.4-beta.2 0a951668696f 7 months ago 79.2MBgcr.io/google_containers/pause-amd64 3.0 99e59f495ffa 20 months ago 747kB 本人也是初学 minikube，本文基于 minikube 0.24.1 版本。 如果我们直接使用从 https://github.com/kubernetes/minikube 下载的 minikube 你可能会发现根本不能运行成功。 这是因为它要从 gcr.io 拉取镜像，而国内网络问题导致镜像下载不了，当然也就不能启动了。 知道为什么成功不了，那我们就替换源码中的国外镜像为国内镜像源（阿里云）。 具体要变更哪些文件请看 GitHub 我已经把变更过的文件上传到了 GitHub，本文以这个 git 仓库为源码，重新编译 minikube 安装 kubectl 注意，由于网络问题，从官网下载极有可能下载失败。你可以使用浏览器在国内镜像下载之后移入 PATH https://github.com/khs1994-docker/kubectl-cn-mirror 使用 minikube 必须先安装好 k8s 命令行工具 kubectl。 macOSDocker for Mac 17.12+ 启用 k8s 之后会在 /usr/local/bin 放入 kubectl，所以你无需安装。 Docker for Mac 自带的 k8s 会与 minikube 冲突，请以下命令进行切换。 1234567891011121314$ kubectl config get-contextsCURRENT NAME CLUSTER AUTHINFO NAMESPACE docker-for-desktop docker-for-desktop-cluster docker-for-desktop* minikube minikube minikube# 切换到 docker 自带的 k8s$ kubectl config use-context docker-for-desktop# 切换到 minikube$ kubectl config use-context minikube 如果你没启用 k8s 那么请使用下面的方法。 1$ brew install kubectl curl或者使用 curl 下载。 bash12345678# OS X$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl# Linux$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl# Windows$ curl -LO https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/windows/amd64/kubectl.exe fish12345678# OS X$ curl -LO https://storage.googleapis.com/kubernetes-release/release/(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/darwin/amd64/kubectl# Linux$ curl -LO https://storage.googleapis.com/kubernetes-release/release/(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl# Windows$ curl -LO https://storage.googleapis.com/kubernetes-release/release/(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/windows/amd64/kubectl.exe 重新安装 minikube 国内版 注意：国内从 GitHub 下载文件可能较慢，你可以在国内镜像下载之后移入 PATH https://code.aliyun.com/khs1994-docker/minikube/tree/v1.8.0 你可以选择 编译安装 或者 下载安装。为了避免混乱，编译安装的方法，放到了文章最后。 直接下载安装你可以根据你的操作系统，下载对应的二进制文件。你也可以在命令行使用 curl 下载。 https://github.com/khs1994-docker/minikube/releases bash12345$ curl -LO https://github.com/khs1994-docker/minikube/releases/download/v0.24.1/minikube-`uname -s`-`uname -m`$ chmod +x minikube-`uname -s`-`uname -m`$ sudo cp minikube-`uname -s`-`uname -m` /usr/local/bin/minikube fish12345$ curl -LO https://github.com/khs1994-docker/minikube/releases/download/v0.24.1/minikube-(uname -s)-(uname -m)$ chmod +x minikube-(uname -s)-(uname -m)$ sudo cp minikube-(uname -s)-(uname -m) /usr/local/bin/minikube 虚拟机驱动https://github.com/kubernetes/minikube/blob/master/docs/drivers.md macOS 上默认的驱动是 VirtualBox，但是我们这里选择 hyperkit。 注意，你可能看到一些旧教程使用了 xhyve，如果你使用这个驱动，启动时 minikube 会提示你该驱动已经废弃。 12WARNING: The xhyve driver is now deprecated and support for it will be removed in a future release.Please consider switching to the hyperkit driver, which is intended to replace the xhyve driver. 123456789$ curl -LO https://github.com/kubernetes/minikube/releases/download/v0.24.1/docker-machine-driver-hyperkit$ chmod +x docker-machine-driver-hyperkit$ sudo mv docker-machine-driver-hyperkit /usr/local/bin/$ sudo chown root:wheel /usr/local/bin/docker-machine-driver-hyperkit$ sudo chmod u+s /usr/local/bin/docker-machine-driver-hyperkit 这样我们就安装好了驱动。 启动1$ minikube start --vm-driver=hyperkit --alsologtostderr --v 10 选择一种驱动之后，不要再改变，否则可能会启动失败。 错误排查若启动时出现错误，请执行以下命令删除本地集群，再重新执行启动命令。 1$ minikube delete 如果仍然出现错误请删除 ~/.minikube，再重新执行启动命令。 使用方法打开控制面板123$ minikube dashboardOpening kubernetes dashboard in default browser... 之后会自动打开浏览器页面。 查看 IP123$ minikube ip192.168.64.12 查看状态12345$ minikube statusminikube: Runningcluster: Runningkubectl: Correctly Configured: pointing to minikube-vm at 192.168.64.12 查看集群12345$ kubectl cluster-infoKubernetes master is running at https://192.168.64.12:8443To further debug and diagnose cluster problems, use 'kubectl cluster-info dump'. 更多方法请查看后续文章。 关闭1$ minikube stop 附录Windows 启动 minikube自行在上面提到的 GitHub 或 国内镜像 下载好 kubectl.exe minikube.exe,并加入 PATH 配置 Hyper-V，具体图解请查看：https://yq.aliyun.com/articles/221687 1$ minikube.exe start --registry-mirror=https://registry.docker-cn.com --vm-driver="hyperv" --memory=4096 --hyperv-virtual-switch="minikube" 编译安装 minikube 注意：编译安装适用于对 Go 有一定了解的人。 安装 Go1$ brew install go 设置 Go 相关环境变量，自行修改为你自己的路径。 12GOROOT="/usr/local/opt/go/libexec"GOPATH="/Users/khs1994/go" 编译安装1234567$ git clone -b 0.24.1 --depth=1 git@github.com:khs1994-docker/minikube.git $GOPATH/src/k8s.io/minikube$ cd $GOPATH/src/k8s.io/minikube$ make$ sudo cp out/minikube /usr/local/bin More Information https://github.com/kubernetes/minikube https://github.com/AliyunContainerService/minikube https://yq.aliyun.com/articles/221687 https://github.com/oucb/minikube http://wiselyman.iteye.com/blog/2381738]]></content>
      <categories>
        <category>K8s</category>
        <category>Minikube</category>
      </categories>
      <tags>
        <tag>K8s</tag>
        <tag>Minikube</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 镜像多阶段构建]]></title>
    <url>%2Fdocker%2Fmultistage-builds.html</url>
    <content type="text"><![CDATA[本文内容来自我参与维护的 《Docker 从入门到实践》 项目。 之前的做法在 Docker 17.05 版本之前，我们构建 Docker 镜像时，通常会采用两种方式： 全部放入一个 Dockerfile一种方式是将所有的构建过程编包含在一个 Dockerfile 中，包括项目及其依赖库的编译、测试、打包等流程，这里可能会带来的一些问题： Dockerfile 特别长，可维护性降低 镜像层次多，镜像体积较大，部署时间变长 源代码存在泄露的风险 例如 编写 app.go 文件，该程序输出 Hello World! 1234567package main import "fmt" func main()&#123; fmt.Printf("Hello World!");&#125; 编写 Dockerfile.one 文件 123456789101112131415FROM golang:1.9-alpineRUN apk --no-cache add git ca-certificatesWORKDIR /go/src/github.com/go/helloworld/COPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \ &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . \ &amp;&amp; cp /go/src/github.com/go/helloworld/app /rootWORKDIR /root/CMD ["./app"] 构建镜像 1$ docker build -t go/helloworld:1 -f Dockerfile.one . 分散到多个 Dockerfile另一种方式，就是我们事先在一个 Dockerfile 将项目及其依赖库编译测试打包好后，再将其拷贝到运行环境中，这种方式需要我们编写两个 Dockerfile 和一些编译脚本才能将其两个阶段自动整合起来，这种方式虽然可以很好地规避第一种方式存在的风险，但明显部署过程较复杂。 例如 编写 Dockerfile.build 文件 12345678910FROM golang:1.9-alpineRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworldCOPY app.go .RUN go get -d -v github.com/go-sql-driver/mysql \ &amp;&amp; CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app . 编写 Dockerfile.copy 文件 123456789FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY app .CMD ["./app"] 新建 build.sh 12345678910111213#!/bin/shecho Building go/helloworld:builddocker build -t go/helloworld:build . -f Dockerfile.builddocker create --name extract go/helloworld:builddocker cp extract:/go/src/github.com/go/helloworld/app ./appdocker rm -f extractecho Building go/helloworld:2docker build --no-cache -t go/helloworld:2 . -f Dockerfile.copyrm ./app 现在运行脚本即可构建镜像 123$ chmod +x build.sh$ ./build.sh 对比两种方式生成的镜像大小 12345$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEgo/helloworld 2 f7cf3465432c 22 seconds ago 6.47MBgo/helloworld 1 f55d3e16affc 2 minutes ago 295MB 使用多阶段构建为解决以上问题，Docker v17.05 开始支持多阶段构建 (multistage builds)。使用多阶段构建我们就可以很容易解决前面提到的问题，并且只需要编写一个 Dockerfile： 例如 编写 Dockerfile 文件 123456789101112131415161718192021FROM golang:1.9-alpineRUN apk --no-cache add gitWORKDIR /go/src/github.com/go/helloworld/RUN go get -d -v github.com/go-sql-driver/mysqlCOPY app.go .RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .FROM alpine:latestRUN apk --no-cache add ca-certificatesWORKDIR /root/COPY --from=0 /go/src/github.com/go/helloworld/app .CMD ["./app"] 构建镜像 1$ docker build -t go/helloworld:3 . 对比三个镜像大小 123456$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEgo/helloworld 3 d6911ed9c846 7 seconds ago 6.47MBgo/helloworld 2 f7cf3465432c 22 seconds ago 6.47MBgo/helloworld 1 f55d3e16affc 2 minutes ago 295MB 很明显使用多阶段构建的镜像体积小，同时也完美解决了上边提到的问题。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.2 新特性]]></title>
    <url>%2Fphp%2Frelease%2F7.2%2FREADME.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/php/php-src/releases/tag/php-7.2.0 官方文档：http://cn2.php.net/manual/zh/migration72.php 部分列出 允许重写抽象方法当一个抽象类继承于另外一个抽象类的时候，继承后的抽象类可以重写被继承的抽象类的抽象方法。 重写方法和接口实现的参数类型现在可以省略了允许分组命名空间的尾部逗号]]></content>
      <categories>
        <category>PHP</category>
        <category>Release</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drone 部署 PHP]]></title>
    <url>%2Fci%2Fdrone%2Fphp.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-php/tencent-ai Github: https://github.com/khs1994-docker/php-demo]]></content>
      <categories>
        <category>CI</category>
        <category>Drone</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Drone</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drone 部署 Gitbook]]></title>
    <url>%2Fci%2Fdrone%2Fgitbook.html</url>
    <content type="text"><![CDATA[Github: https://github.com/khs1994-php/gitbook]]></content>
      <categories>
        <category>CI</category>
        <category>Drone</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Drone 部署 Hexo]]></title>
    <url>%2Fci%2Fdrone%2Fhexo.html</url>
    <content type="text"><![CDATA[Github: https://github.com/khs1994-php/hexo]]></content>
      <categories>
        <category>CI</category>
        <category>Drone</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Postman api 调试工具]]></title>
    <url>%2Ftools%2Fpostman.html</url>
    <content type="text"><![CDATA[请使用客户端，不要再使用浏览器插件。 官方网站：https://www.getpostman.com/ 视频教程：https://ke.qq.com/course/246722]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Postman</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 容器 Rkt 简单介绍]]></title>
    <url>%2Fdocker%2Frkt%2FREADME.html</url>
    <content type="text"><![CDATA[由于 Docker 已经成为事实上的容器老大，这里暂且将 rkt 内容放入 docker 文件夹。哈哈 官方网站：https://coreos.com/rkt/ 官方文档：https://coreos.com/rkt/docs/latest/ GitHub：https://github.com/rkt/rkt/ 这里使用 CoreOS 来学习 Rkt，其他 Linux 系统上 Rkt 的安装方法很简单，这里不再赘述。 Rkt 目前只支持 Linux 系统。 先看一下命令列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051NAME: rkt - rkt, the application container runnerUSAGE: rkt [command]VERSION: 1.29.0COMMANDS: api-service Run API service (experimental) cat-manifest Inspect and print the pod manifest completion Output shell completion code for the specified shell config Print configuration for each stage in JSON format enter Enter the namespaces of an app within a rkt pod export Export an app from an exited pod to an ACI file fetch Fetch image(s) and store them in the local store gc Garbage collect rkt pods no longer in use image cat-manifest Inspect and print the image manifest image export Export a stored image to an ACI file image extract Extract a stored image to a directory image gc Garbage collect local store image list List images in the local store image render Render a stored image to a directory with all its dependencies image rm Remove one or more images with the given IDs or image names from the local store image verify Verify one or more rendered images in the local store list List pods metadata-service Run metadata service prepare Prepare to run image(s) in a pod in rkt rm Remove all files and resources associated with an exited pod run Run image(s) in a pod in rkt run-prepared Run a prepared application pod in rkt status Check the status of a rkt pod stop Stop a pod trust Trust a key for image verification version Print the version and exit help Help about any commandDESCRIPTION: A CLI for running app containers on Linux. To get the help on any specific command, run &quot;rkt help command&quot;.OPTIONS: --debug[=false] print out more debug information to stderr --dir=/var/lib/rkt rkt data directory --insecure-options=none comma-separated list of security features to disable. Allowed values: &quot;none&quot;, &quot;image&quot;, &quot;tls&quot;, &quot;ondisk&quot;, &quot;http&quot;, &quot;pubkey&quot;, &quot;capabilities&quot;, &quot;paths&quot;, &quot;seccomp&quot;, &quot;all-fetch&quot;, &quot;all-run&quot;, &quot;all&quot; --local-config=/etc/rkt `local` configuration directory --system-config=/usr/lib/rkt system configuration directory --trust-keys-from-https[=false] automatically trust gpg keys fetched from https --user-config= user configuration directory rkt 使用的是 pod 的概念，与 k8s 联系紧密，可能对应 docker 中的容器概念。 下载 Docker 镜像rkt 比 docker 多了一个验证的功能，下载 Docker 镜像必须加上不要验证的参数。 123$ rkt fetch --insecure-options=image docker://ubuntu# fetch 与 git 中的 fetch 含义差不多，对应 docker pull 查看镜像123456$ rkt image listID NAME SIZE IMPORT TIME LAST USEDsha512-bea6e5210d47 registry-1.docker.io/library/ubuntu:latest 98MiB 1 minute ago 1 minute ago# 与 docker 中的命令一致，可能遵循了某种标准。哈哈，别和我说 docker images 那是旧命令了，好吧！ 运行一个 pod12345678$ sudo rkt --insecure-options=image \ run \ --interactive \ docker://ubuntu# docker run XXX$ rkt run --help --interactive 与 docker -it 对应 --volume data,kind=host,source=/srv/data,readOnly=false 挂载文件 --volume data,kind=empty,readOnly=false --mount volume=VOL,target=PATH 1234567$ sudo rkt --insecure-options=image \ run \ --interactive \ --volume data,kind=host,source=/srv/data \ --mount volume=data,target=/srv/data \ docker://ubuntu \ --exec /bin/sh --port=80-tcp:80 暴露端口 1234$ sudo rkt --insecure-options=image \ run \ docker://nginx:alpine \ --port=80-tcp:80 --set-env=KEY=VALUE 设置 pod 环境变量 --environment=foo=bar 设置 pod 环境变量 --exec /bin/sh --name=name --net=host | default | none --net=&quot;net1:IP=1.2.3.4&quot; 后台运行systemd-runhttps://coreos.com/rkt/docs/latest/using-rkt-with-systemd.html#systemd-run 1234567$ sudo systemd-run \ --slice=machine \ rkt \ --insecure-options=image \ run \ --net=host \ docker://nginx:alpine daemonhttp://www.libslack.org/daemon/ 查看 pods 信息12345$ rkt listUUID APP IMAGE NAME STATE CREATED STARTED NETWORKSea4b9fe5 nginx registry-1.docker.io/library/nginx:alpine running 9 seconds ago 9 seconds ago default:ip4=172.16.28.5# docker ps -a 进入 pod123$ sudo rkt enter ea sh# docker exec 停止 pod123$ sudo rkt stop ea# docker stop 删除 pod123$ sudo rkt rm ea# docker rm More information http://www.infoq.com/cn/articles/coreos-rkt-container-part-01 http://www.infoq.com/cn/articles/coreos-rkt-container-part-02]]></content>
      <categories>
        <category>Rkt</category>
      </categories>
      <tags>
        <tag>Rkt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 相关概念总览]]></title>
    <url>%2Fdocker%2Foverview.html</url>
    <content type="text"><![CDATA[Docker 概念总览 Docker EngineDocker 引擎 Docker architectureDocker 架构 Docker daemonDocker 守护进程，dockerd 命令 Docker clientDocker 客户端，docker 命令 Docker registriesDocker 仓库 Docker objectsDocker 对象 IMAGES镜像 CONTAINERS容器 SERVICES服务 Services allow you to scale containers across multiple Docker daemons, which all work together as a swarm with multiple managers and workers. Each member of a swarm is a Docker daemon, and the daemons all communicate using the Docker API. A service allows you to define the desired state, such as the number of replicas of the service that must be available at any given time. By default, the service is load-balanced across all worker nodes. To the consumer, the Docker service appears to be a single application. Docker Engine supports swarm mode in Docker 1.12 and higher. 底层技术Docker is written in Go and takes advantage of several features of the Linux kernel to deliver its functionality. Namespaces命名空间 Docker uses a technology called namespaces to provide the isolated workspace called the container. When you run a container, Docker creates a set of namespaces for that container. These namespaces provide a layer of isolation. Each aspect of a container runs in a separate namespace and its access is limited to that namespace. Docker Engine uses namespaces such as the following on Linux: The pid namespace: Process isolation (PID: Process ID). The net namespace: Managing network interfaces (NET: Networking). The ipc namespace: Managing access to IPC resources (IPC: InterProcess Communication). The mnt namespace: Managing filesystem mount points (MNT: Mount). The uts namespace: Isolating kernel and version identifiers. (UTS: Unix Timesharing System). Control groups控制组 cgroups Docker Engine on Linux also relies on another technology called control groups (cgroups). A cgroup limits an application to a specific set of resources. Control groups allow Docker Engine to share available hardware resources to containers and optionally enforce limits and constraints. For example, you can limit the memory available to a specific container. Union file systems联合文件系统 Union file systems, or UnionFS, are file systems that operate by creating layers, making them very lightweight and fast. Docker Engine uses UnionFS to provide the building blocks for containers. Docker Engine can use multiple UnionFS variants, including AUFS, btrfs, vfs, and DeviceMapper. Container format容器格式 Docker Engine combines the namespaces, control groups, and UnionFS into a wrapper called a container format. The default container format is libcontainer. In the future, Docker may support other container formats by integrating with technologies such as BSD Jails or Solaris Zones.]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 远程连接 -- dockerd 命令详解]]></title>
    <url>%2Fdocker%2Fdockerd.html</url>
    <content type="text"><![CDATA[配置 TLS 实现安全的 Docker 远程连接。 GitHub：https://github.com/khs1994-docker/lnmp-k8s 本机：macOS 远程机：使用 VirtualBox 虚拟 CoreOS (IP 192.168.57.110) 目标：能在 macOS 远程操作 CoreOS。（注意不是 SSH 远程登录）。dockerd 命令仅能在 Linux 下使用。 官方文档：https://docs.docker.com/edge/engine/reference/commandline/dockerd/ 官方文档：https://docs.docker.com/engine/admin/ 本文适合有一定 Linux 基础的读者阅读，如果出现错误，请将各种操作之前修改过的文件恢复原状并删除新增的环境变量。 我们已经知道 Docker 是客户端/服务端架构。一般情况下我们使用的 Docker 客户端/服务端都在本机（macOS、Windows 实际上是在本机启动了一个虚拟机，这里指 Linux）。本文所指的情况是 Docker 客户端与服务端不在同一主机上。 Dokcer 架构 Typically, you start Docker using operating system utilities. For debugging purposes, you can start Docker manually using the dockerd command. You may need to use sudo, depending on your operating system configuration. When you start Docker this way, it runs in the foreground and sends its logs directly to your terminal. 非安全的连接方式先介绍 非安全 的连接方式。 服务端配置CoreOS 请使用第二种方法，其他 Linux 系统配置时选择以下两种方法之一 通常的配置方法docker.service 中 dockerd 的 -H 参数不能与 daemon.json 中的 hosts 键值对冲突。(其他参数同理) 新建 /etc/systemd/system/docker.service.d/docker.conf 文件。 123[Service]ExecStart=ExecStart=/usr/bin/dockerd 在 /etc/docker/daemon.json （下文统一简称 daemon.json）中写入以下内容 123456&#123; "hosts":[ "unix:///var/run/docker.sock", "tcp://0.0.0.0:2375" ]&#125; 该文件必须符合 json 规范写法，否则 Docker 将不能启动。 重新启动 Docker。 12$ sudo systemctl daemon-reload$ sudo systemctl restart docker CoreOS 官方文档提供的方法官方文档：https://coreos.com/os/docs/latest/customizing-docker.html 新建 /etc/systemd/system/docker-tcp.socket 文件 1234567891011[Unit]Description=Docker Socket for the API[Socket]# ListenStream=127.0.0.1:2375ListenStream=2375BindIPv6Only=bothService=docker.service[Install]WantedBy=sockets.target 重新启动服务 12345$ sudo systemctl daemon-reload$ sudo systemctl enable docker-tcp.socket$ sudo systemctl stop docker$ sudo systemctl start docker-tcp.socket$ sudo systemctl start docker 注意：这种方法必须先启动 docker-tcp.socket，再启动 Docker，一定要注意启动顺序！ systemd socket 详情请查看：http://www.jinbuguo.com/systemd/systemd.socket.html 在客户端测试连接在 macOS （下文中 macOS一律代指 Docker 客户端）上使用以下命令 1$ docker -H 192.168.57.110:2375 info 成功输出信息，证明客户端可以成功连接到远程的服务端。 在 macOS 上远程操作 CoreOS 上的 Docker 每次执行命令时必须加上 -H 参数(这样太麻烦，我们可以通过将 Docker 命令 参数 配置成 环境变量 来简化命令)。 在 macOS 上执行如下命令。 123$ export DOCKER_HOST="tcp://0.0.0.0:2375"$ docker info 这里写入的变量是临时生效的，重新登录环境变量就消失了（下文同理，之后不再赘述），让环境变量永久生效请写入 ~/.bashrc。 fish shell本人 macOS 上使用的 shell 是 fish，这里记录一下 fish 中的操作，使用 bash 的读者请忽略 fish 相关内容。 12345$ set -Ux DOCKER_HOST "tcp://0.0.0.0:2375"# 以上命令写入的环境变量是永久存在的，通过以下命令删除环境变量$ set -Ue DOCKER_HOST 配置安全连接官方文档：https://docs.docker.com/engine/security/https/ 上面我们配置的远程连接是不安全的，只能用于测试环境中。在生产环境中需要配置 TLS 安全连接，只有拥有密钥的客户端，才能连接到远程的服务端。 服务端配置只能使用 Linux 下的 openssl 生成密钥，macOS 下的不可以。在 CoreOS 下执行以下操作 手动执行命令生成证书（不推荐）这一步较复杂，你可以跳过这一方法，使用容器生成证书。此方法来自 Docker 官方文档 https://docs.docker.com/engine/security/https/。 文件总览 12345678910├── ca-key.pem # 妥善保管，连接时用不到├── ca.pem # clent &amp; server├── ca.srl # 用不到├── cert.pem # client├── client.csr # 请求文件├── extfile.cnf # 配置文件├── key.pem # client├── server-cert.pem # server├── server.csr # 请求文件└── server-key.pem # server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263# 生成 CA 私钥$ openssl genrsa -aes256 -out ca-key.pem 4096# 需要输入两次密码(自定义)# 生成 CA 公钥$ openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem# 输入上一步中设置的密码，然后需要填写一些信息# 下面是服务器证书生成# 生成服务器私钥$ openssl genrsa -out server-key.pem 4096# 用私钥生成证书请求文件$ openssl req -subj "/CN=localhost" -sha256 -new -key server-key.pem -out server.csr$ echo subjectAltName = DNS:localhost,DNS:www.khs1994.com,DNS:tencent,IP:192.168.199.100,IP:192.168.57.110,IP:127.0.0.1 &gt;&gt; extfile.cnf# 允许服务端哪些 IP 或 host 能被客户端连接，下文会进行测试。# DNS 我也不是很理解，这里配置 localhost ，公共 DNS 解析的域名，/etc/hosts 文件中的列表进行测试。$ echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf# 用 CA 来签署证书$ openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \ -CAcreateserial -out server-cert.pem -extfile extfile.cnf# 再次输入第一步设置的密码# 下面是客户端证书文件生成# 生成客户端私钥$ openssl genrsa -out key.pem 4096# 用私钥生成证书请求文件 $ openssl req -subj '/CN=client' -new -key key.pem -out client.csr$ echo extendedKeyUsage = clientAuth &gt;&gt; extfile.cnf# 用 CA 来签署证书$ openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \ -CAcreateserial -out cert.pem -extfile extfile.cnf# 再次输入第一步设置的密码# 删除文件，更改文件权限$ rm -v client.csr server.csr$ chmod -v 0400 ca-key.pem key.pem server-key.pem$ chmod -v 0444 ca.pem server-cert.pem cert.pem 把 ca.pem server-cert.pem server-key.pem 三个文件移动到 /etc/docker/ 文件夹中。 使用容器生成证书（推荐）GitHub：https://github.com/khs1994-docker/lnmp-k8s 方法来自 CoreOS 官方文档：https://coreos.com/os/docs/latest/generate-self-signed-certificates.html 既然使用容器那就可以在任何系统运行，只要把生成的证书文件对应的放到 Docker 客户端和服务端即可。 123456$ git clone --depth=1 https://github.com/khs1994-docker/lnmp-k8s$ cd lnmp-k8s# 初始化$ ./lnmp-k8s 在 ./systemd/.env 中配置 1server_hosts=127.0.0.1,localhost,1.1.1.1 值为 Docker 服务端所在 IP 或 域名。多个值用逗号分隔 1$ docker-compose up cfssl-single 命令执行完毕之后在 ./systemd/certs 文件夹中可以看到证书文件，修改文件权限。 123$ chmod -v 0400 ca-key.pem key.pem server-key.pem$ chmod -v 0444 ca.pem server-cert.pem cert.pem 把 ca.pem server-cert.pem server-key.pem 三个文件移动到服务端 /etc/docker/ 文件夹中。 CoreOS 请使用第二种方法，其他 Linux 系统根据上文选择的方法，这里选择对应的方法 通常的配置方法修改 daemon.json 文件。 注意：非安全连接使用的是 2375 端口，安全连接使用的是 2376 端口。当然这是推荐的端口配置，你可以配置任何端口！ 12345678910&#123; "tlsverify": true, "tlscert": "/etc/docker/server-cert.pem", "tlskey": "/etc/docker/server-key.pem", "tlscacert": "/etc/docker/ca.pem", "hosts":[ "unix:///var/run/docker.sock", "tcp://0.0.0.0:2376" ]&#125; 重新启动 Docker 1$ sudo systemctl restart docker CoreOS 官方文档的方法首先需要修改 /etc/systemd/system/docker-tcp.socket 文件内容 12345ListenStream=2375# 修改为ListenStream=2376 修改 CoreOS 上的 daemon.json 文件。 123456&#123; "tlsverify": true, "tlscert": "/etc/docker/server-cert.pem", "tlskey": "/etc/docker/server-key.pem", "tlscacert": "/etc/docker/ca.pem"&#125; 重新启动服务。 1234$ sudo systemctl daemon-reload$ sudo systemctl stop docker$ sudo systemctl restart docker-tcp.socket$ sudo systemctl restart docker 上文已经提到了启动顺序，这里提示一下，不再赘述。 客户端远程安全连接将 ca.pem cert.pem key.pem 三个文件通过 scp 下载到 macOS。 在 macOS 执行以下命令，密钥路径请根据实际情况填写。 123456$ docker --tlsverify \ --tlscacert=/Users/khs1994/test/ca.pem \ --tlscert=/Users/khs1994/test/cert.pem \ --tlskey=/Users/khs1994/test/key.pem \ -H=192.168.57.110:2376 \ info 把密钥放入 ~/.docker 文件夹中每次操作需要跟那么多参数，太麻烦了。我们可以把 ca.pem cert.pem key.pem 三个文件放入客户端 ~/.docker 中，然后配置环境变量就可以简化命令了。 123$ export DOCKER_HOST=tcp://192.168.57.110:2376 DOCKER_TLS_VERIFY=1$ docker info 你也可以选择其他路径，请通过环境变量 DOCKER_CERT_PATH 指定。 报错详情不使用安全连接123$ docker -H 192.168.57.110:2376 infoGet http://192.168.57.110:2376/v1.34/containers/json?all=1: malformed HTTP response "\x15\x03\x01\x00\x02\x02".* Are you trying to connect to a TLS-enabled daemon without TLS? 在非允许列表 IP 中登录假如远程服务器还有一个 IP 10.141.20.83 ，现在我们尝试使用这个 IP 作为服务端地址，看看客户端能否连接到。 12$ docker -H 10.141.20.83:2376 infoerror during connect: Get https://10.141.20.83:2376/v1.34/info: x509: certificate is valid for 192.168.57.110, 192.168.199.100, 127.0.0.1, not 10.141.20.83 在非允许列表 Host 中登录12$ docker -H localhost:2376 infoerror during connect: Get https://localhost:2375/v1.34/info: x509: certificate is valid for coreos1, not localhost fish shell123456$ set -Ux DOCKER_HOST tcp://192.168.57.110:2376$ set -Ux DOCKER_TLS_VERIFY 1# 以上命令写入环境变量是永久存在的，通过以下命令删除环境变量$ set -Ue DOCKER_HOST ; set -Ue DOCKER_TLS_VERIFY 服务端验证模式 tlsverify, tlscacert, tlscert, tlskey set: Authenticate clients tls, tlscert, tlskey: Do not authenticate clients 客户端验证模式 tls: Authenticate server based on public/default CA pool tlsverify, tlscacert: Authenticate server based on given CA tls, tlscert, tlskey: Authenticate with client certificate, do not authenticate server based on given CA tlsverify, tlscacert, tlscert, tlskey: Authenticate with client certificate and authenticate server based on given CA 测试远程构建 Docker 镜像在 macOS 新建 demo 文件夹并进入。 我们首先建一个文本文件 test.txt 1hello! 然后新建一个简单的 Dockerfile 文件 12345FROM busyboxCOPY ./test.txt /CMD cat /test.txt 按照前面的方法设置好环境变量，这里不再赘述。 1$ docker -H 192.168.57.110:2376 --tlsverify build -t khs1994/busybox . 在远程服务端查看SSH 登录到 CoreOS（这里为了便于理解，SSH 到远程服务器操作）。 123$ docker image lsREPOSITORY TAG IMAGE ID CREATED SIZEkhs1994/busybox latest 368d23df8500 10 seconds ago 1.13MB 我们已经查看到了镜像。 12$ docker run -it --rm khs1994/busyboxhello! 运行成功。 客户端恢复原状你如果想在 macOS 操作本地的服务端，请将上面配置的环境变量删除，这里不再赘述。 More Information https://deepzz.com/post/dockerd-and-docker-remote-api.html]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Registry v2 配置文件详解]]></title>
    <url>%2Fdocker%2Fregistry-config.html</url>
    <content type="text"><![CDATA[/etc/docker/registry/config.yml 详解。 你可以在 docker run 时通过 -e 参数设置环境变量来配置。为了避免命令的繁杂，推荐大家通过挂载配置文件来进行配置。 123storage: filesystem: rootdirectory: /var/lib/registry 对应着 1REGISTRY_STORAGE_FILESYSTEM_ROOTDIRECTORY=/somewhere 通过挂载配置文件来修改配置 123456$ docker run -d \ -p 5000:5000 \ --restart=always \ --name registry \ -v `pwd`/config.yml:/etc/docker/registry/config.yml \ registry 简单配置文件请查看：https://github.com/docker/distribution/blob/master/cmd/registry/config-example.yml 示例配置文件：https://docs.docker.com/registry/configuration/#list-of-configuration-options 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182version: 0.1log: accesslog: disabled: true level: info | debug | error | warn formatter: text | json | logstash fields: service: registry environment: staging hooks: - type: mail disabled: true levels: - panic options: smtp: addr: smtp.exmail.qq.com:465 username: docker@xc725.wang password: password insecure: true from: docker@xc725.wang to: - docker@khs1994.com# loglevel: debug # deprecated: use "log" 已废弃# 存储storage: # 存入本地文件中 filesystem: rootdirectory: /var/lib/registry maxthreads: 100 # 存入 阿里云 OSS ,其他国外云服务这里不再列举 oss: accesskeyid: accesskeyid accesskeysecret: accesskeysecret region: OSS region name endpoint: optional endpoints internal: optional internal endpoint bucket: OSS bucket encrypt: optional data encryption setting secure: optional ssl setting chunksize: optional size valye rootdirectory: optional root directory inmemory: # This driver takes no parameters delete: enabled: false redirect: disable: false cache: blobdescriptor: redis maintenance: uploadpurging: enabled: true age: 168h interval: 24h dryrun: false readonly: enabled: false# 用户名 密码 验证功能，提供三种验证方式，我比较熟悉 htpasswd auth: silly: realm: silly-realm service: silly-service token: realm: token-realm service: token-service issuer: registry-token-issuer rootcertbundle: /root/certs/bundle htpasswd: realm: basic-realm path: /path/to/htpasswdmiddleware: registry: - name: ARegistryMiddleware options: foo: bar repository: - name: ARepositoryMiddleware options: foo: bar storage: - name: cloudfront options: baseurl: https://my.cloudfronted.domain.com/ privatekey: /path/to/pem keypairid: cloudfrontkeypairid duration: 3000s storage: - name: redirect options: baseurl: https://example.com/reporting: bugsnag: apikey: bugsnagapikey releasestage: bugsnagreleasestage endpoint: bugsnagendpoint newrelic: licensekey: newreliclicensekey name: newrelicname verbose: truehttp: addr: localhost:5000 prefix: /my/nested/registry/ host: https://myregistryaddress.org:5000 secret: asecretforlocaldevelopment relativeurls: false tls: certificate: /path/to/x509/public key: /path/to/x509/private clientcas: - /path/to/ca.pem - /path/to/another/ca.pem letsencrypt: cachefile: /path/to/cache-file email: emailused@letsencrypt.com debug: addr: localhost:5001 headers: X-Content-Type-Options: [nosniff] http2: disabled: false# 类似 github webhooks ,给特定网址 post 一个 json 数据 notifications: endpoints: - name: alistener disabled: false url: https://my.listener.com/event headers: &lt;http.Header&gt; timeout: 500 threshold: 5 backoff: 1000 ignoredmediatypes: - application/octet-stream#配置 Redis redis: addr: redis:6379 # password: asecret db: 0 dialtimeout: 10ms readtimeout: 10ms writetimeout: 10ms pool: maxidle: 16 maxactive: 64 idletimeout: 300s# 健康检查 health: storagedriver: enabled: true interval: 10s threshold: 3 file: - file: /path/to/checked/file interval: 10s http: - uri: http://server.to.check/must/return/200 headers: Authorization: [Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==] statuscode: 200 timeout: 3s interval: 10s threshold: 3 tcp: - addr: redis-server.domain.com:6379 timeout: 3s interval: 10s threshold: 3# docker hub 镜像 proxy: remoteurl: https://registry-1.docker.io username: [username] password: [password]compatibility: schema1: signingkeyfile: /etc/registry/key.jsonvalidation: enabled: true manifests: urls: allow: - ^https?://([^/]+\.)*example\.com/ deny: - ^https?://www\.example\.com/]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Cloud 简介]]></title>
    <url>%2Fdocker%2Fcloud.html</url>
    <content type="text"><![CDATA[Docker Cloud 是官方推出的构建、测试镜像，管理 Swarm mode，自动以镜像方式部署服务的地方。 构建镜像和我们熟悉的 Dockr Hub 一样，关联 GitHub 或者 Bitbucket 即可开始自动构建镜像。 构建镜像详情只有自己能够看到。 自动测试https://docs.docker.com/docker-cloud/builds/automated-testing/ https://docs.docker.com/docker-cloud/builds/advanced/ 每次源代码提交 Pr 时，Docker Cloud 会自动测试 Pr。 在构建配置选项打开自动测试，并在构建目录下新增 docker-compose.test.yml 123sut: build: . command: run_tests.sh 可以通过 depends_on 增加服务，也可以使用多个 compose 文件，只要以 .test.yml 结尾就行。 命令返回 0 则表示测试通过，其他均为失败。 示例：https://github.com/khs1994-docker/hexo/blob/dev/alpine/docker-compose.test.yml Swarm modehttps://docs.docker.com/docker-cloud/cloud-swarm/connect-to-swarm/ 切换到 Swarms beta 标签，按照提示在 Docker 主机执行命令，即可在 Docker 桌面版方便的查看集群详情。 其他功能链接特定云服务商才能使用，这里不再说明。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Store 简介]]></title>
    <url>%2Fdocker%2Fstore.html</url>
    <content type="text"><![CDATA[可以看做升级版的 Docker Hub，是 Docker 镜像的 App Store。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在生产环境使用 Docker]]></title>
    <url>%2Fdocker%2Fproduction.html</url>
    <content type="text"><![CDATA[本文是对官方文档的总结与备注。 官方文档：https://docs.docker.com/engine/userguide/ 配置 Docker手动启动 Docker这一部分内容详情可以查看：https://www.khs1994.com/docker/dockerd.html 1$ sudo docked 自动启动容器https://docs.docker.com/engine/admin/start-containers-automatically/ 1$ docker run --restart no | on-failure | unless-stopped | always 限制容器资源https://docs.docker.com/engine/admin/resource_constraints/ 内存-m 或 --memory=4m --memory-swap --memory-swappiness --memory-reservation --kernel-memory --oom-kill-disable CPU--cpus --cpu-period --cpu-quota --cpuset-cpus --cpu-shares 清除无用数据https://docs.docker.com/engine/admin/pruning/ https://www.khs1994.com/docker/prune.html Keep containers alive during daemon downtimehttps://docs.docker.com/engine/admin/live-restore/ systemdhttps://docs.docker.com/engine/admin/systemd/ 使用本地私有 Docker 仓库https://www.khs1994.com/docker/registry.html 容器日志https://docs.docker.com/engine/admin/logging/view_container_logs/ 123$ docker logs CONTAINER_NAME$ docker service logs SERVICE_NAME 日志驱动安全https://docs.docker.com/engine/security/security/ Swarm mode服务创建 docker service create ... 一个服务 docker stack deploy ... 多个服务 服务详情12345$ docker service ls ps inspect logs$ docker stack ps STACK_NAME$ docker stack services STACK_NAME 存储配置数据https://docs.docker.com/engine/swarm/configs/ docker config 命令 以 redis 为例 123456789101112131415$ echo "This is a config" | docker config create my-config -# 配置文件默认挂载到 /my-config ，也可以通过 target 进行配置$ docker service create \ --name redis \ # --config my-config \ --config source=my-config,target=/config/path \ redis:alpine$ docker config ls# 当配置文件被使用时，不能删除$ docker config rm my-config 存储敏感数据https://docs.docker.com/engine/swarm/secrets/ docker secret 命令 以 nginx 为例 123456789101112131415161718$ docker secret create site.key site.key$ docker secret create site.crt site.crt$ docker secret create site.conf site.conf$ docker secret ls# 默认挂载到 /run/secrets/*** ，你可以通过 target 配置$ docker service create \ --name nginx \ --secret site.key \ --secret site.crt \ --secret source=site.conf,target=/etc/nginx/conf.d/site.conf \ --publish target=3000,port=443 \ nginx:latest \ sh -c "exec nginx -g 'daemon off;'" 服务更新https://docs.docker.com/edge/engine/reference/commandline/service_update/ 1$ docker service update ... 服务回退https://docs.docker.com/edge/engine/reference/commandline/service_rollback/#related-commands 1$ docker service rollback 删除服务123$ docker service rm ...$ docker stack rm ... 服务容器数量伸缩1$ docker service scale backend=3 frontend=5 跨节点数据管理讨论 https://github.com/khs1994-docker/lnmp/issues/275 NFS https://github.com/vieux/docker-volume-sshfs ceph 网络讨论 https://github.com/khs1994-docker/lnmp/issues/279 在一个容器中运行多个服务https://docs.docker.com/engine/admin/multi-service_container/]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在开发环境使用 Docker]]></title>
    <url>%2Fdocker%2Fdevelopment.html</url>
    <content type="text"><![CDATA[本文是对官方文档的总结与备注。 官方文档：https://docs.docker.com/develop/ 镜像选择 alpine:3.7 (首选) debian:stretch-slim （次选） 常见系统镜像大小对比1234567REPOSITORY TAG IMAGE ID CREATED SIZEfedora latest 9110ae7f579f 4 weeks ago 235MBcentos 7.4.1708 3afd47092a0e 5 months ago 197MBubuntu 16.04 f975c5035748 4 weeks ago 112MBdebian stretch 2b98c9851a37 3 weeks ago 100MBdebian stretch-slim dd99abd0503e 3 weeks ago 55.3MBalpine latest 3fd9065eaf02 2 months ago 4.15MB 根据官方文档的层次，分为 容器 (Containers) 使用 Docker run 服务 (Services) 使用 Docker Compose Defines how containers behave in production 服务栈 (Stack) 使用 Swarm mode Defining the interactions of all the services 必须知道 使用 Dockerfile 构建镜像 使用 multistage builds 保持镜像最小 使用 Volume 和 bind mounts 管理数据 使用 docker swarm 部署服务 使用 docker stack 部署服务栈 compose 文件 普遍的应用开发最佳实践 Docker development best practicesDocker 开发最佳实践 如何保持镜像最小 Start with an appropriate base image. 如果你需要 JDK，则直接使用官方的 openjdk 镜像，而不要基于 ubuntu 安装 openjdk Use multistage builds. 使用多阶段构建，如果你的 Docker 版本不支持 多阶段构建，请请尽可能减少镜像层数。 使用你自己的基础镜像 保持生产环境镜像尽可能小，但允许调试 使用有明确含义的镜像标签 prod 或者 test，尽量不使用 latest 标签。 Where and how to persist application data应用数据如何存储，存放在哪里 避免 将数据存放在镜像中 使用 volumes 存放数据 在开发环境使用 bind mounts ，在生产环境使用 volume 在生产环境中使用 secrets 存储敏感数据，使用 configs 存储非敏感数据，比如配置文件 Use swarm services when possible 在可能的情况下使用 Swarm mode 哪怕仅需要运行一个容器，Swarm mode 能提供更多的功能 通过 Swarm 服务，网络和数据卷能够连接和断开 一些功能只在 服务 中可用,比如 secrets config，上一部分已经提到 使用 docker stack deploy pull 镜像，而不是使用 docker pull Use CI/CD for testing and deployment 当程序源码改变（commit、tag）或创建了一个 Pull request，使用 Docker Cloud 或者其他 CI/CD 自动构建镜像和创建镜像标签并自动测试镜像。Docker cloud 可以把测试通过的镜像部署到生产环境中。 使用 Docker EE ，安全团队 sign 一个镜像，之后部署到生产环境中。 Differences in development and production environments Development Production Use bind mounts to give your container access to your source code. Use volumes to store container data. Use Docker for Mac or Docker for Windows. Use Docker EE if possible, with userns mapping for greater isolation of Docker processes from host processes. Don’t worry about time drift. Always run an NTP client on the Docker host and within each container process and sync them all to the same NTP server. If you use swarm services, also ensure that each Docker node syncs its clocks to the same time source as the containers. 镜像管理Docker HubDcoekr Registry 私有仓库https://www.khs1994.com/docker/registry.html Docker Trusted Registry (Docker EE)]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 清理命令 prune]]></title>
    <url>%2Fdocker%2Fprune.html</url>
    <content type="text"><![CDATA[Docker 1.13.0+ 引入了清理命令。 官方文档：https://docs.docker.com/engine/admin/pruning/ 清理镜像1$ docker image prune 清理容器1$ docker container prune 清理网络1$ docker network prune 清理 Volume1$ docker volume prune 清理所有123$ docker system prune$ docker system prune --volumes More Information https://segmentfault.com/a/1190000007822648]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 数据管理]]></title>
    <url>%2Fdocker%2Fmanage-application-data.html</url>
    <content type="text"><![CDATA[我们已经熟悉了 -v 或者 --volume，官方最近建议( Docker 17.06+ ) 使用 --mount。 官方文档：https://docs.docker.com/engine/admin/volumes/ 修订说明 务必弃用 -v 参数，为了方便对比，本文以注释方式提供 -v 参数示例。 类型 bind volume tmpfs sourcesource 或 src destinationdestination 或 dst 或 target volumes创建 volume不创建也可以，使用时若不存在，Docker 会自动新建。 1234567$ docker volume create VOLUME_NAME$ docker volume ls# 删除$ docker volume rm VOLUME_NAME $ docker runtype=volume，可以省略，默认为该类型。 12345$ docker run \ --mount type=volume,src=VOLUME_NAME,target=/app # -v VOLUME_NAME:/app \ --mount source=nginx-vol,destination=/usr/share/nginx/html,readonly # -v nginx-vol:/usr/share/nginx/html:ro $ docker service12345$ docker service create -d \ --replicas=4 \ --name SERVICE_NAME \ --mount source=VOLUME_NAME,target=/app \ nginx:latest readonly将数据卷挂载为只读文件夹。 12345--mount source=nginx-vol,destination=/usr/share/nginx/html,readonly# 进入容器，尝试新建文件夹，会提示错误$ mkdir: can&apos;t create directory &apos;a.txt&apos;: Read-only file system bind mounts官方文档：https://docs.docker.com/engine/admin/volumes/bind-mounts/ -v 参数挂载的文件或目录路径如果不存在，Docker 会默认创建一个文件夹。 --mount 参数挂载的文件或目录路径如果不存在，Docker 不会自动创建，并且会报错。 type 为 bind 12345$ docker run \ --mount type=bind,src=$PWD/app,target=/app \ # -v "$(pwd)"/target:/app \ --mount type=bind,source=$PWD/app,target=/app,readonly \ # -v "$(pwd)"/target:/app:ro macOS该选项仅用于 macOS 1--mount type=bind,source=$PWD/target,destination=/app,consistency=cached consistent or default: The default setting with full consistency, as described above. delegated: The container runtime’s view of the mount is authoritative. There may be delays before updates made in a container are visible on the host. cached: The macOS host’s view of the mount is authoritative. There may be delays before updates made on the host are visible within a container. These options are completely ignored on all host operating systems except macOS. tmpfs123--mount type=tmpfs,destination=/app--mount type=tmpfs,destination=/app,tmpfs-mode=1770 tmpfs 没有宿主机源文件。 注意事项当挂载一个 空的数据卷 时，若挂载的容器目标目录存在文件时，Docker 会把容器中的文件复制到数据卷中。若 监听主机目录 或 挂载非空数据卷 时，不会复制容器中原有文件，而是由原路径文件直接覆盖容器中的目标路径。下面通过具体的命令来进行说明。 123456789101112131415161718192021222324252627282930313233343536373839$ docker run -it --rm \ --mount src=new_vol,target=/etc/nginx/conf.d \ nginx:alpine \ ls /etc/nginx/conf.ddefault.conf# 以上说明 Docker 复制容器中的原有文件到了这个空的数据卷# 在数据卷写入数据$ docker run -it --rm \ --mount src=new_vol,target=/etc/nginx/conf.d \ nginx:alpine \ sh/ # cd /etc/nginx/conf.d//etc/nginx/conf.d # rm -rf */etc/nginx/conf.d # ls/etc/nginx/conf.d # touch test.txt# 退出，现在数据卷 new_vol 非空，下面测试挂载一个非空数据卷，看会不会复制容器中的文件到数据卷。$ docker run -it --rm \ --mount src=new_vol,target=/etc/nginx/conf.d \ nginx:alpine \ ls /etc/nginx/conf.dtest.txt# 以上说明没有复制# 现在测试一下监听主机目录$ docker run -it --rm \ --mount type=bind,src=$PWD,target=/etc/nginx/conf.d \ nginx:alpine \ ls /etc/nginx/conf.d# 没有看到 default.conf# 说明没有复制容器中的原有文件，主机中的文件直接覆盖掉了容器中的原有文件]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 网络]]></title>
    <url>%2Fdocker%2Fnetwork.html</url>
    <content type="text"><![CDATA[本文介绍 Docker 网络。 官方文档：https://docs.docker.com/engine/userguide/networking/ 网络类型bridge 桥接类型 是创建容器时默认连接的网络类型，用的比较多，这里不再详细介绍。 host容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口，容器可以和宿主机一样，使用宿主机的 eth0 实现和外界的通信。换言之容器的 IP 地址即为宿主机 eth0 的 IP 地址。 1$ docker run -dit --network host nginx:alpine 现在访问 主机 IP 即可看到 nginx 默认页面。 none这样创建出来的容器完全没有网络。 12345678910$ docker run -it --rm nginx:alpine ip addr1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN qlen 1000 link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00 inet 127.0.0.1/8 scope host lo valid_lft forever preferred_lft forever5: eth0@if6: &lt;BROADCAST,MULTICAST,UP,LOWER_UP,M-DOWN&gt; mtu 1500 qdisc noqueue state UP link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff inet 172.17.0.2/16 scope global eth0 valid_lft forever preferred_lft forever 后边可以通过 docker network connect bridge CONTAINER_ID 来将没有设置网络的容器连接到一个网络。 container:name or id--network=&quot;container:name or id 通过此参数启动的容器，拥有与被连接的容器相同的网络。 创建网络1$ docker network create -d bridge [ --subnet 172.25.0.0/16 ] NETWORK_NAME -d 指定网络驱动，默认为 bridge，在 Swarm mode 中也可以创建 overlay 类型的网络。 查看网络123456$ docker network lsNETWORK ID NAME DRIVER SCOPE369f1b30c236 bridge bridge local991412261a72 host host local269fb25e6d2d none null local 查看网络详情1$ docker network inspect bridge 容器连接网络可以固定容器 IP 12345$ docker run --network=NETWORK_NAME [ --ip=172.25.3.3 ] ...$ docker run --network="container:id or name"$ docker network connect NETWORK_NAME CONTAINER_NAME 断开网络1$ docker network disconnect NETWORK_NAME CONTAINER_NAME 移除网络123$ docker network rm NETWORK_NAME$ docker network prune Swarm mode12345678910$ docker network create \ --driver overlay \ --subnet 10.0.9.0/24 \ NETWORK_NAME$ docker service create \ --replicas 2 \ --network NETWORK_NAME \ --name my-web \ nginx Overlay networkingress networkThe ingress network is created automatically when you initialize or join a swarm. docker_gwbridgeThe docker_gwbridge network is created automatically when you initialize or join a swarm. 设置代理17.07+~/.config.json 12345678910&#123; "proxies": &#123; "default": &#123; "httpProxy": "http://127.0.0.1:3001", "noProxy": "*.test.example.com,.example2.com" &#125; &#125;&#125; other设置环境变量，请查看 官方文档]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jenkins 实践]]></title>
    <url>%2Fci%2Fjenkins%2FREADME.html</url>
    <content type="text"><![CDATA[OS: macOS 官方网站：https://jenkins.io/ 启动1$ jenkins 打开 127.0.0.1：8080]]></content>
      <categories>
        <category>CI</category>
        <category>Jenkins</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[静态网站部署之 Netlify]]></title>
    <url>%2Fcms%2Fnetlify.html</url>
    <content type="text"><![CDATA[我们知道可以把网站部署到 GitHub Pages 服务，Netlify 也提供类似的服务。 官方网站：https://www.netlify.com/ 关联 GitHub 仓库 输入分支名称 输入编译命令 完成部署]]></content>
      <categories>
        <category>CMS</category>
      </categories>
      <tags>
        <tag>Netlify</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fish Shell 命令补全]]></title>
    <url>%2Flinux%2Ffish-shell%2Fcompletion.html</url>
    <content type="text"><![CDATA[记录一下 complete 各个参数含义。 -c 要补全的命令 -p 命令路径 -e -s 短参数 -h -l 长参数 --help -o old style long option -a 添加子命令 -f 不列出文件 -r -x -f and -r -w -n 函数 -CSTRING -C -A -u -d 描述 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189 complete -- edit command specific tab-completionsSynopsis complete ( -c | --command | -p | --path ) COMMAND [( -c | --command | -p | --path ) COMMAND]... [( -e | --erase )] [( -s | --short-option ) SHORT_OPTION]... [( -l | --long-option | -o | --old-option ) LONG_OPTION]... [( -a | --arguments ) OPTION_ARGUMENTS] [( -f | --no-files )] [( -r | --require-parameter )] [( -x | --exclusive )] [( -w | --wraps ) WRAPPED_COMMAND]... [( -n | --condition ) CONDITION] [( -d | --description ) DESCRIPTION] complete ( -C[STRING] | --do-complete[=STRING] )Description For an introduction to specifying completions, see Writing your own completions in the fish manual. · COMMAND is the name of the command for which to add a completion. · SHORT_OPTION is a one character option for the command. · LONG_OPTION is a multi character option for the command. · OPTION_ARGUMENTS is parameter containing a space-separated list of possible option-arguments, which may contain command substitutions. · DESCRIPTION is a description of what the option and/or option arguments do. · -c COMMAND or --command COMMAND specifies that COMMAND is the name of the command. · -p COMMAND or --path COMMAND specifies that COMMAND is the absolute path of the program (optionally containing wildcards). · -e or --erase deletes the specified completion. · -s SHORT_OPTION or --short-option=SHORT_OPTION adds a short option to the completions list. · -l LONG_OPTION or --long-option=LONG_OPTION adds a GNU style long option to the completions list. · -o LONG_OPTION or --old-option=LONG_OPTION adds an old style long option to the completions list (See below for details). · -a OPTION_ARGUMENTS or --arguments=OPTION_ARGUMENTS adds the specified option arguments to the completions list. · -f or --no-files specifies that the options specified by this completion may not be followed by a filename. · -r or --require-parameter specifies that the options specified by this completion always must have an option argument, i.e. may not be followed by another option. · -x or --exclusive implies both -r and -f. · -w WRAPPED_COMMAND or --wraps=WRAPPED_COMMAND causes the specified command to inherit completions from the wrapped command (See below for details). · -n or --condition specifies a shell command that must return 0 if the completion is to be used. This makes it possible to specify completions that should only be used in some cases. · -CSTRING or --do-complete=STRING makes complete try to find all possible completions for the specified string. · -C or --do-complete with no argument makes complete try to find all possible completions for the current command line buffer. If the shell is not in interactive mode, an error is returned. · -A and --authoritative no longer do anything and are silently ignored. · -u and --unauthoritative no longer do anything and are silently ignored. Command specific tab-completions in fish are based on the notion of options and arguments. An option is a parameter which begins with a hyphen, such as '-h', '-help' or '--help'. Arguments are parameters that do not begin with a hyphen. Fish recognizes three styles of options, the same styles as the GNU version of the getopt library. These styles are: · Short options, like '-a'. Short options are a single character long, are preceded by a single hyphen and may be grouped together (like '-la', which is equivalent to '-l -a'). Option arguments may be specified in the following parameter ('-w 32') or by appending the option with the value ('-w32'). · Old style long options, like '-Wall'. Old style long options can be more than one character long, are preceded by a single hyphen and may not be grouped together. Option arguments are specified in the following parameter ('-ao null'). · GNU style long options, like '--colors'. GNU style long options can be more than one character long, are preceded by two hyphens, and may not be grouped together. Option arguments may be specified in the following parameter ('--quoting-style shell') or by appending the option with a '=' and the value ('--quoting-style=shell'). GNU style long options may be abbreviated so long as the abbreviation is unique ('--h') is equivalent to '--help' if help is the only long option beginning with an 'h'). The options for specifying command name and command path may be used multiple times to define the same completions for multiple commands. The options for specifying command switches and wrapped commands may be used multiple times to define multiple completions for the command(s) in a single call. Invoking complete multiple times for the same command adds the new definitions on top of any existing completions defined for the command. When -a or --arguments is specified in conjunction with long, short, or old style options, the specified arguments are only used as completions when attempting to complete an argument for any of the specified options. If -a or --arguments is specified without any long, short, or old style options, the specified arguments are used when completing any argument to the command (except when completing an option argument that was specified with -r or --require- parameter). Command substitutions found in OPTION_ARGUMENTS are not expected to return a space-separated list of arguments. Instead they must return a newline-separated list of arguments, and each argument may optionally have a tab character followed by the argument description. Any description provided in this way overrides a description given with -d or --description. The -w or --wraps options causes the specified command to inherit completions from another command. The inheriting command is said to 'wrap' the inherited command. The wrapping command may have its own completions in addition to inherited ones. A command may wrap multiple commands, and wrapping is transitive: if A wraps B, and B wraps C, then A automatically inherits all of C's completions. Wrapping can be removed using the -e or --erase options. Note that wrapping only works for completions specified with -c or --command and are ignored when specifying completions with -p or --path. When erasing completions, it is possible to either erase all completions for a specific command by specifying complete -c COMMAND -e, or by specifying a specific completion option to delete by specifying either a long, short or old style option.Example The short style option -o for the gcc command requires that a file follows it. This can be done using writing: complete -c gcc -s o -r The short style option -d for the grep command requires that one of the strings 'read', 'skip' or 'recurse' is used. This can be specified writing: complete -c grep -s d -x -a 'read skip recurse' The su command takes any username as an argument. Usernames are given as the first colon-separated field in the file /etc/passwd. This can be specified as: complete -x -c su -d 'Username' -a '(cat /etc/passwd | cut -d : -f 1)' The rpm command has several different modes. If the -e or --erase flag has been specified, rpm should delete one or more packages, in which case several switches related to deleting packages are valid, like the nodeps switch. This can be written as: complete -c rpm -n '__fish_contains_opt -s e erase' -d nodeps 'Don't check dependencies' where __fish_contains_opt is a function that checks the command line buffer for the presence of a specified set of options. To implement an alias, use the -w or --wraps option: complete -c hub -w git Now hub inherits all of the completions from git. Note this can also be specified in a function declaration.]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>fish shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenSSL 加密解密文件]]></title>
    <url>%2Flinux%2Fssl%2Ffile-enc.html</url>
    <content type="text"><![CDATA[加密解密文件。 1234567# 加密$ openssl enc -aes-128-cbc -e -a -in ~/.ssh/khs1994-robot -out ~/.ssh/khs1994-robot.enc -K c286696d887c9aa0611bbb3e2025a45a -iv 562e17996d093d28ddb3ba695a2e6f00# 解密$ openssl enc -aes-128-cbc -d -a -in ~/.ssh/khs1994-robot.enc -out ~/.ssh/id_rsa -K c286696d887c9aa0611bbb3e2025a45a -iv 562e17996d093d28ddb3ba695a2e6f00 -e 加密 -d 解密 -a 加密前/后使用 base64 编码 Key 和 IV 值是 16进制 More Information https://www.cnblogs.com/gordon0918/p/5317701.html]]></content>
      <categories>
        <category>Linux</category>
        <category>SSL</category>
      </categories>
      <tags>
        <tag>SSL</tag>
        <tag>OpenSSL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose 二进制文件国内镜像]]></title>
    <url>%2Fdocker%2Fcompose-mirror.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-docker/compose-cn-mirror 浏览器直接下载：https://code.aliyun.com/khs1994-docker/compose-cn-mirror/tree/master 要下载不同的版本，请切换左上角的标签。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS aria2 命令行使用详解]]></title>
    <url>%2Ftools%2Faria2.html</url>
    <content type="text"><![CDATA[aria2 是一个下载工具。 aria2 https://github.com/aria2/aria2 BaiduExporter https://github.com/acgotaku/BaiduExporter 安装1$ brew install aria2 配置参考 http://aria2c.com/usage.html 在 ~/.aria2/aria2.conf 中写入配置内容，主要修改 下载路径。 注意：将示例配置中的以下内容注释，不注释的话启动会报错。 1234# 从会话文件中读取下载任务input-file=/etc/aria2/aria2.session# 在Aria2退出时保存`错误/未完成`的下载任务到会话文件save-session=/etc/aria2/aria2.session 启动1$ aria2c 下载百度网盘里的文件Chrome 插件1git clone https://github.com/acgotaku/BaiduExporter 或者下载项目打包文件。 在 Chrome 扩展中加载该项目 chrome 文件夹 在百度网盘页面点击 导出下载 -&gt; ARIA2 PRC 回到命令行，看到开始下载]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>aria2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Virtualbox 安装 Alpine Linux]]></title>
    <url>%2Flinux%2Falpine.html</url>
    <content type="text"><![CDATA[本文介绍使用 VirtualBox 安装 Alpine Linux。 安装下载 iSO，挂载，配置网络，启动。 用户名 root，默认密码为空。 1$ setup-alpine 然后交互式输入信息，完成安装。不要无脑回车，注意一定要设置 DNS 服务器，否则会遇到网络问题而安装失败。 输入 $ poweroff 关机，移除安装 ISO 光盘。 SSH开机之后在虚拟机窗口登录，修改 SSH 配置之后，使用 SSH 来登录即可开始使用。 /etc/ssh/sshd_config 1PermitRootLogin yes More Information http://blog.csdn.net/freewebsys/article/details/53638227]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 镜像云端构建（官方+国内)]]></title>
    <url>%2Fdocker%2Fbuild-image.html</url>
    <content type="text"><![CDATA[将 Dockerfile 上传到代码仓库(GitHub, GitLab, Coding, 等)，云端开始构建并 push Docker 镜像到仓库中。 这里只列出免费服务。 Docker Hubhttps://hub.docker.com Docker Cloudhttps://cloud.docker.com Travis CIhttps://travis-ci.org 只支持与 GitHub 绑定 阿里云提供高性能本地化 Registry，上传/下载/构建及托管的全方位镜像服务。已经与(code.aliyun.com)/Github/Bitbucket 代码源打通，提供 Docker 镜像的持续集成服务。 提供国内、国外构建环境。 https://dev.aliyun.com/search.html?spm=5176.1971733.0.1.trlkKn 腾讯云https://console.cloud.tencent.com/ccs/registry 据 QQ 交流群 434653499 构建主机位于国外。 镜像前缀 ccr.ccs.tencentyun.com 七牛云https://hub.qiniu.com CI 构建支持 GitHub More Information https://developer.aliyun.com/index?spm=5176.8142029.388261.181.H1inl7#guid-850376]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub Pages 常见问题]]></title>
    <url>%2Fcms%2Fpages.html</url>
    <content type="text"><![CDATA[本文列举了一些使用 GitHub Pages 遇到的问题及其解决方法。 资源 404你可以使用以下方法中的一种来解决该问题。 禁用 jekyll以 _下划线 开头的文件及文件夹都会被提示 404，在根目录添加 .nojekyll 空白文件禁用 jekyll。 包含特定文件如果不想禁用 jekyll，你可以在项目根目录新建 _config.yml 文件，并增加以下内容： 12theme: jekyll-theme-slateinclude: [_images] 参考链接 https://post.zz173.com/detail/13522.html]]></content>
      <categories>
        <category>CMS</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派 3 Docker 详解]]></title>
    <url>%2Fraspberry-pi3%2Fdocker.html</url>
    <content type="text"><![CDATA[arm32v7 arm64v8 架构 Docker 全解析。 修订记录 Docker CE v17.12 + 开始支持 arm64 Debian 配置方法和 Linux 一样，由于和 x86_64 架构不同，不同之处仅是安装包、拉取 Docker 镜像的差别，配置加速器等操作和 Linux 相同，更多内容请查看本博客 Docker 分类下的文章。 安装之后需要做一些配置请查看这里：https://www.khs1994.com/docker/README.html arm32v7即运行官方的 Raspbian Stretch Lite ( 基于 Debian 9 ) 123$ uname -aLinux raspberrypi 4.12.3-v7 #1 SMP Mon Jul 24 10:40:40 CST 2017 armv7l GNU/Linux 直接添加如下源即可安装 Docker 1deb [arch=armhf] http://mirrors.aliyun.com/docker-ce/linux/raspbian stretch test 12345$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -$ sudo apt update$ sudo apt install docker-ce 请 pull arm32v7 镜像 arm64v8暂时没有 arm64 位的官方系统，本人使用的是 pi64 内核信息 1Linux raspberrypi 4.14.1-pi64+ #1 SMP PREEMPT Thu Nov 23 13:22:01 CST 2017 aarch64 GNU/Linux 直接添加如下源即可安装 Docker 1deb [arch=arm64] http://mirrors.aliyun.com/docker-ce/linux/debian stretch test 12345$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -$ sudo apt update$ sudo apt install docker-ce 请 pull arm64v8 镜像 Docker Compose使用 Docker Compose 可能会报错，使用以下命令设置字符集。 1234567# 安装方法，已经安装的请忽略$ sudo pip3 install docker-compose$ sudo localectl set-locale LANG=en_US.UTF-8$ sudo localectl set-keymap LANG=en_US.UTF-8$ sudo localectl set-x11-keymap LANG=en_US.UTF-8 其他操作系统上边的 pi64 本人感觉用的很顺手，大家可以尝试使用以下系统运行 Docker。 Rancher OS 64位GitHub：https://github.com/rancher/os 在 https://github.com/rancher/os/releases 下载 rancheros-raspberry-pi64.zip ，刷入 TF 卡。 SSH123$ ssh rancher@ip# 密码为 rancher 内核信息 1Linux rancher.lan 4.9.34-bee42-v8 #1 SMP PREEMPT Mon Jun 26 01:51:13 UTC 2017 aarch64 GNU/Linux 切换 Docker 版本123456789101112$ sudo ros engine listdisabled docker-1.12.6disabled docker-1.13.1enabled docker-17.03.1-cedisabled docker-17.03.2-cedisabled docker-17.04.0-cedisabled docker-17.05.0-cedisabled docker-17.06.1-ce# 切换指定版本$ sudo ros engine switch docker-17.05.0-ce HypriotOSGitHub：https://github.com/hypriot/image-builder-rpi More Information http://dockone.io/article/1676]]></content>
      <categories>
        <category>Raspberry Pi3</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Raspberry Pi3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinuxKit 使用]]></title>
    <url>%2Fdocker%2Flinuxkit.html</url>
    <content type="text"><![CDATA[OS：macOS GitHub：https://github.com/linuxkit/linuxkit 修订记录 2017/12/02: 官方开始支持 VirtualBox 2017/11/21: 不再需要 moby 准备此处以 macOS 下安装为例，其他系统请在 Go 环境下编译命令。 GitHub：https://github.com/linuxkit/homebrew-linuxkit 1234567$ brew tap linuxkit/linuxkit$ brew install --HEAD linuxkit# 下面的不是必须安装，我目前还不清楚它的作用$ brew install --HEAD rtf$ brew install --HEAD manifest-tool 这一步会安装好 linuxkit 命令。 工具升级 1$ brew reinstall --HEAD linuxkit 运行官方示例支持以下平台： HyperKit (macOS) Hyper-V (Windows) qemu (macOS, Linux, Windows) VMware (macOS, Windows) 云平台不再列举。 克隆源代码123$ git clone --depth=1 git@github.com:linuxkit/linuxkit.git$ cd linuxkit 使用 VirtualBox官方文档：https://github.com/linuxkit/linuxkit/blob/master/docs/platform-vbox.md 先以虚拟机方式启动，便于大家理解。 1$ linuxkit build -format iso-efi linuxkit.yml -format 参数指定输出格式，使用 linuxkit build --help 查看更多信息。 这样就生成了一个名为 linuxkit-efi.iso 的 ISO 文件。 使用 VirtualBox 挂载 ISO，勾选 启用EFI 并设置好网络后启动。浏览器访问虚拟机的 IP，即可看到 Nginx 默认页面。 或者使用命令运行。 1$ linuxkit run vbox --uefi linuxkit-efi.iso 打开 VirtualBox，可以看到启动的虚拟机，在网络高级配置中，配置端口转发（例如 8080），浏览器访问 宿主机IP:8080 即可看到 Nginx 默认页面。 执行 linuxkit run vbox --help 查看更多配置参数。 使用 HyperKit官方文档：https://github.com/linuxkit/linuxkit/blob/master/docs/platform-hyperkit.md HyperKit 是 macOS 上运行的轻量级虚拟化工具包。构建、运行命令如下 123$ linuxkit build linuxkit.yml$ linuxkit run -publish 8080:80/tcp linuxkit 这里将 LinuxKit 中的 80 端口映射到了 macOS 的 8080 端口，现在打开 127.0.0.1:8080，即可看到 Nginx 默认页面。 还有一种方法是使用 Docker for Mac 启动一个容器，在容器中可以连接到 LinuxKit 启动的系统。 连接到容器的方法：https://github.com/linuxkit/linuxkit/blob/master/docs/platform-hyperkit.md#networking 执行 linuxkit run hyperkit --help 查看更多配置参数。 注意：使用该驱动，LinuxKit 中的服务会继承 macOS 中 /etc/hosts 的配置。如果想要自定义 hosts 可以挂载配置文件。 macOS xhyve 虚拟引擎你查看的旧教程可能以 xhyve 为例讲解 Linuxkit。 不过目前官方已经删去对其的支持。我实际测试启动不起来，这里不再赘述。 关闭执行 halt 关闭 LinuxKit 启动的系统。 自定义运行 linuxkit help 查看更多使用方法。 参考示例 linuxkit.yml 编写自定义的 name.yml，然后构建、运行。 请参考 example 文件夹下的官方示例。 参考链接 http://blog.csdn.net/shenshouer/article/details/70251109 https://www.v2ex.com/t/359038 https://github.com/moby/tool/blob/master/docs/yaml.md https://zhuanlan.zhihu.com/p/26997981]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>LinuxKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 系统升级]]></title>
    <url>%2Fdocker%2Fcoreos%2Fupdate.html</url>
    <content type="text"><![CDATA[CoreOS 会自动检测升级，由于国内网络环境，下载升级包可能会失败。 官方文档：https://coreos.com/os/docs/latest/update-strategies.html 查看升级进度1$ systemctl status update-engine 手动升级1$ update_engine_client 参数如下 -status -watch_for_updates -update -check_for_update 设置升级代理服务器1$ sudo mkdir -p /etc/systemd/system/update-engine.service.d /etc/systemd/system/update-engine.service.d/50-proxy.conf 在该文件中写入以下内容(没有就新建)。 12[Service]Environment=HTTP_PROXY=http://your.proxy.address:port 12[Service]Environment=ALL_PROXY=socks://代理地址 参考链接 http://dockone.io/question/155]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 实践遇到的问题（持续更新）]]></title>
    <url>%2Fdocker%2Fissues.html</url>
    <content type="text"><![CDATA[本文列举了使用 Docker 过程中遇到的问题。 时区基于 Debian 的镜像通过设置 环境变量 改变时区，在 Dockerfile 中增加 ENV 或在启动容器时指定 $ docker run -e TZ=Asia/Shanghai ...。 1ENV TZ=Asia/Shanghai 基于 Alpine 的镜像先安装 tzdate，再设置环境变量 123RUN apk add --no-cache tzdataENV TZ=Asia/Shanghai 交叉运行https://github.com/justincormack/cross-docker x86_64 架构运行其他架构（ armhf 等）容器，原理是运用 QEMU。 macOS 不用以上脚本，实际测试中与树莓派对比，性能较差，毕竟是虚拟机。 网络macOSmacOS 不能 ping 通容器（Linux docker0 默认为 172.17.0.1），所以容器想要 ping 主机，必须填写路由器分配给主机的 IP（192.168.199.100，而不是 172.17.0.1）。 DNS、host不能在文件中写入配置，写入也不生效。在 daemon.json 中可以配置 DNS , 设置 hosts 请通过 docker build 、docker run 时的命令参数进行设置。 使用 Docker Compose本博客系列文章运行容器方式由 docker run 转变为 docker-compose。 必须使用 .env.example 文件来定义变量。使用时将 .env.example 复制为 .env 文件。 规范一个容器，一个服务比如不要在一个容器中安装 LNMP，可以使用 Docker Compose 分配到 3 个容器，集中启动、管理。 一个容器运行多个服务：https://docs.docker.com/engine/admin/multi-service_container/ 命令使用 docker image 管理镜像 代替 docker images 使用 docker container 管理容器 代替 docker ps 使用 docker volume 管理数据卷 使用 docker network 管理容器网络 数据管理详细内容请查看 Docker 数据管理 开发环境Use bind mounts to give your container access to your source code 生产环境Use volumes to store container data. 不赞成使用容器互联反对 --link，请使用自定义的 Docker 网络来连接多个容器 数据管理反对 -v 或 --volume，请使用 --mount 废弃功能https://docs.docker.com/engine/deprecated/ More Information http://dockone.io/question/362]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派 3 64 位系统体验]]></title>
    <url>%2Fraspberry-pi3%2Farm64v8.html</url>
    <content type="text"><![CDATA[国内关于 arm64位 系统的资料较少，我只在知乎里找到一篇关于此的 文章。 GitHub: https://github.com/bamarni/pi64 从 pi64 下载镜像，和以前一样将镜像刷入 TF 卡，开机。注意第一次系统启动时间较长并会重启一次，等待一会再通过 SSH 登录。 登录帐号： pi，密码： raspberry 内核信息1Linux raspberrypi 4.11.12-pi64+ #1 SMP PREEMPT Sun Aug 27 14:50:58 CEST 2017 aarch64 GNU/Linux 最新内核GitHub: https://github.com/khs1994/kernel 我参考作者编译内核步骤，使用 Travis CI 自动构建最新的内核，你可以在 releses 下载 arm64 开头的内核，替换 即可。 配置国内源直接使用 Debian9 源 12345678deb http://mirrors.ustc.edu.cn/debian stretch main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian stretch main contrib non-freedeb http://mirrors.ustc.edu.cn/debian stretch-updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian stretch-updates main contrib non-freedeb http://mirrors.ustc.edu.cn/debian-security stretch/updates main contrib non-freedeb-src http://mirrors.ustc.edu.cn/debian-security stretch/updates main contrib non-free]]></content>
      <categories>
        <category>Raspberry Pi3</category>
      </categories>
      <tags>
        <tag>Raspberry Pi3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker + Drone CI/CD 实践]]></title>
    <url>%2Fci%2Fdrone%2FREADME.html</url>
    <content type="text"><![CDATA[测试环境：macOS + Drone + Gogs + Docker Registry 生产环境：Debian 9 + Drone + GitHub + 腾讯云容器服务 官方网站：http://drone.io/ GitHub：https://github.com/drone GitHub: https://github.com/khs1994-docker/ci 安装请使用或升级到最新 0.8 版本。 编写 docker-compose.yml，示例文件请到 这里 查看。 注意：0.8 版本的 drone-server、drone-agent image 不同。 与 GitHub 或 Gogs 集成请参考官方文档 http://docs.drone.io 的配置。一些说明可以查看中文文档 http://docs.drone.io/zh/。 之后使用以下命令启动即可 1$ docker-compose up -d 安装详情请参考 https://github.com/yeasy/docker_practice/blob/master/cases/ci/drone.md 使用与 Travis CI 类似，项目中包含 .drone.yml 即可使用。 使用文档请查看 http://docs.drone.io/getting-started/ 本站介绍的使用方法请查看 https://www.khs1994.com/ci/drone/usage.html]]></content>
      <categories>
        <category>CI</category>
        <category>Drone</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Drone</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[宣布 Docker LNMP 项目]]></title>
    <url>%2Fnews%2F2017%2Flnmp-docker.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994-docker/lnmp 在 Docker 和 Kubernetes 上运行 LNMP 架构。]]></content>
      <categories>
        <category>News</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[国内 Git 服务商]]></title>
    <url>%2Fgit%2Fcn.html</url>
    <content type="text"><![CDATA[本文列举了国内 Git 服务提供商。 阿里云 Codehttps://code.aliyun.com/ 腾讯云 Githttps://git.cloud.tencent.com/ Codinghttps://coding.net/ 码云https://gitee.com/ More Information https://www.zhihu.com/question/24692145]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git svn 命令详解]]></title>
    <url>%2Fgit%2Fgit-svn.html</url>
    <content type="text"><![CDATA[Git SVN 配合使用 拉取 svn 项目123456$ git svn clone https://svn.code.sf.net/p/intelgraphicsfixup/svn/ intelgraphicsfixup -s --prefix=svn/$ git branch -av* master 8b54b14 ComputeLaneCount patch for Azul was removed. remotes/svn/trunk 8b54b14 ComputeLaneCount patch for Azul was removed. 克隆部分 commit123$ git svn clone -r&lt;开始版本号&gt;:&lt;结束版本号&gt; &lt;svn项目地址&gt; [其他参数]$ git svn clone -r2:HEAD file:///d/Projects/svn_repo proj1_git -s 拉取 svn 更新1$ git svn rebase 相关链接 http://www.cnblogs.com/h2zZhou/p/6136948.html]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 已废弃组件]]></title>
    <url>%2Fdocker%2Fcoreos%2FREADME.html</url>
    <content type="text"><![CDATA[CoreOS 已废弃组件 fleet =&gt; k8s cloud-config =&gt; Container Linux Config 转化为 ignition config 了解 CoreOS 请详细阅读本分类下的全部文章。 相关链接 https://coreos.com/blog/introducing-ignition.html https://github.com/coreos/ignition https://github.com/coreos/container-linux-config-transpiler https://github.com/coreos/coreos-cloudinit]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 安装服务本地服务器 Docker 化]]></title>
    <url>%2Fdocker%2Fcoreos%2Finstall-server.html</url>
    <content type="text"><![CDATA[由于网络问题，避免外网下载镜像占用时间。安装(请查看本博客 CoreOS 分类下的文章) CoreOS 过程中的所需文件全部放到自己搭建的内网服务器。 本博客 系列文章 CoreOS 节点全部基于 virtualbox 虚拟机。 GitHub：https://github.com/khs1994-docker/lnmp-k8s/tree/master/coreos 网卡设置如下： 网卡 模式 IP 网卡1 hostonly (静态IP) 192.168.57.* 网卡2 桥接 (DHCP) 192.168.199.* 本地服务器配置IP 192.168.57.1 位于本机，默认监听 8080 端口。 123$ git clone --depth=1 https://github.com/khs1994-docker/lnmp-k8s$ cd lnmp-k8s/coreos 下载所需文件配置修改 .env 文件来自定义配置。 启动1$ ./coreos server 这样安装 CoreOS 的内网服务器部署完成。]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS etcd3 集群实践]]></title>
    <url>%2Fdocker%2Fcoreos%2Fetcd.html</url>
    <content type="text"><![CDATA[集群搭建请查看 使用 Ignition 配置工具硬盘安装 CoreOS 三节点集群。 本文内容基于 etcd3。 CoreOS 中的 etcd 是以 rkt 容器方式启动的。自带的 etcd2 命令已经过时，操作请使用 etcdctl。 1234$ rkt listUUID APP IMAGE NAME STATE CREATED STARTED NETWORKS57581644 etcd quay.io/coreos/etcd:v3.2.10 running 1 minute ago 1 minute ago 先设置环境变量(不是必须)，经过我的验证，如果 etcd 启动成功，不用设置也行。 1$ export ETCDCTL_API=3 使用 Docker 模拟集群你也可以使用 Docker Compose 模拟一个集群 具体请查看：https://github.com/yeasy/docker_practice/blob/master/etcd/cluster.md 查看节点列表1234core@coreos1 ~ $ etcdctl member list3ce690f11cfd6851: name=97dd4eb227ed416989800aab22ebafc8 peerURLs=http://192.168.57.110:2380 clientURLs=http://192.168.57.110:2379 isLeader=false4ed7a4b9ff92a147: name=243618ffdf54437c9c278673e5ffac53 peerURLs=http://192.168.57.112:2380 clientURLs=http://192.168.57.112:2379 isLeader=true6eea525a76217d90: name=8ebb8cb013894c81b82d02f60e50e8f5 peerURLs=http://192.168.57.111:2380 clientURLs=http://192.168.57.111:2379 isLeader=false 在某一节点设置值12$ etcdctl put key "CoreOS testing"OK 在另一节点获取值123$ etcdctl get keykeyCoreOS testing 相关链接 http://blog.csdn.net/u010511236/article/details/52386229 http://benjr.tw/96404]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>Etcd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Swarm mode 详解]]></title>
    <url>%2Fdocker%2Fswarm.html</url>
    <content type="text"><![CDATA[使用 docker swarm Dcoker 内置的集群管理的工具，Docker CE 1.12+。注意与旧的 Docker Swarm 区分开来。 OS: CoreOS 1562.1.0 3个节点 OS: macOS + Docker Machine Docker Swarm 在 Docker 1.12 版本之前属于一个独立的项目，在 Docker 1.12 版本发布之后，该项目合并到了 Docker 中，成为 Docker 的一个子命令 docker swarm。 有关集群的 Docker 命令如下： docker swarm：集群管理，子命令有 init, join, join-token, leave, update docker node：节点管理，子命令有 demote, inspect, ls, promote, rm, ps, update docker service：服务管理，子命令有 create, inspect, ps, ls ,rm , scale, update docker stack/deploy：用于多应用部署 docker stack deploy ... 创建使用 Docker Machine 创建集群khs1994.com 备注：docker-machine create --swarm 等 --swarm* 是旧的 Docker Swarm，与本文提到的 Swarm mode 没有关系。 Docker Machine：https://www.khs1994.com/docker/machine.html 官方文档：https://docs.docker.com/machine/reference/create/#specifying-docker-swarm-options-for-the-created-machine 1234$ docker-machine create \ -d virtualbox \ --engine-registry-mirror https://registry.docker-cn.com \ swarm1 1234$ docker-machine create \ -d virtualbox \ --engine-registry-mirror https://registry.docker-cn.com \ swarm2 1234$ docker-machine create \ -d virtualbox \ --engine-registry-mirror https://registry.docker-cn.com \ swarm3 使用 docker-machine ssh MACHINE_NAME 通过 SSH 登录到机器。 CoreOS 集群创建一个 CoreOS 3 节点集群：https://www.khs1994.com/docker/coreos/install-disk-new.html 初始化集群在其中一个节点执行 1$ docker swarm init --advertise-addr 192.168.99.104 如果机器有多个网卡，请使用 --advertise-addr 参数指定 IP 之后执行 1$ docker swarm join-token [OPTIONS] (worker|manager) 按照提示在另外两个节点执行命令加入集群。 查看节点只能在管理节点使用此命令 123456$ docker node lsID HOSTNAME STATUS AVAILABILITY MANAGER STATUS1iukw9dq9ltg2qfich77yk31x * swarm1 Ready Active Leader3a63ymhnbh07vy54jnmn9j3ra swarm2 Ready Activervqgt0vsl3grhxlr0jdf2gnur swarm3 Ready Active 创建服务1$ docker service create --replicas 2 --name nginx nginx:alpine 查看服务状态1$ docker service ls 查看服务详情1$ docker service ps nginx 负载均衡1$ docker service create --replicas 2 --name nginx -p 7080:80 nginx:alpine 查看服务状态12345$ docker service ps nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTSjqo9c9h3x0kz nginx.1 nginx:alpine coreos2 Running Running 8 seconds agodbcy4z9jpj6k nginx.2 nginx:alpine coreos1 Running Running 8 seconds ago 退出一个节点12345$ docker service ps nginxID NAME IMAGE NODE DESIRED STATE CURRENT STATE ERROR PORTS6jxbotcy3q7y nginx.1 nginx:alpine coreos3 Running Running 2 seconds agojqo9c9h3x0kz \_ nginx.1 nginx:alpine coreos2 Shutdown Complete 3 minutes agodbcy4z9jpj6k nginx.2 nginx:alpine coreos1 Running Running 3 minutes ago coreos2 节点关机之后，原来空闲的 coreos3 节点自动启动了一个容器。 减少实例数量1$ docker service scale nginx=2 docker stack123456789$ docker stack deploy -c docker-stack.yml lnmp$ docker stack ls$ docker stack ps lnmp$ docker stack services lnmp$ docker stack rm lnmp More Information http://www.jianshu.com/p/9eb9995884a5]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker 私有仓库安装配置 (Registry v2)]]></title>
    <url>%2Fdocker%2Fregistry.html</url>
    <content type="text"><![CDATA[使用 Docker Compose + Docker machine 配置一个 Docker 私有仓库。 GitHub：https://github.com/khs1994-docker/registry 官方 GitHub：https://github.com/docker/distribution/releases 一种是使用 Docker Compose 一种是基于 registry 镜像 ，添加配置文件之后构建自己的镜像。具体查看 GitHub 准备申请 SSL 证书放到 ssl 文件夹，这里不进行详细说明。 编辑 config.yml，该文件详细配置讲解请查看 Docker Registry v2 配置文件详解 1234567891011121314151617181920212223242526272829303132333435version: 0.1log: accesslog: disabled: true level: debug formatter: text fields: service: registry environment: stagingstorage: delete: enabled: true cache: blobdescriptor: inmemory filesystem: rootdirectory: /var/lib/registryauth: htpasswd: realm: basic-realm path: /etc/docker/registry/auth/nginx.htpasswdhttp: addr: :443 host: https://docker.domain.com headers: X-Content-Type-Options: [nosniff] http2: disabled: false tls: certificate: /etc/docker/registry/ssl/docker.domain.com.crt key: /etc/docker/registry/ssl/docker.domain.com.keyhealth: storagedriver: enabled: true interval: 10s threshold: 3 添加登陆用户将以下命令中的 username password 替换为 用户名 和 密码 ，也可以添加多个用户更多内容请搜索 htpasswd 123456$ docker run --rm \ --entrypoint htpasswd \ registry \ # 部分 nginx 可能不能解密，你可以替换为下面的命令 # -mbn username password &gt; auth/nginx.htpasswd \ -Bbn username password &gt; auth/nginx.htpasswd 编辑 docker-compose.yml1234567891011121314151617version: '3'services: registry: image: registry# restart: always ports: - "443:443" # - "5000:443" volumes: - ./:/etc/docker/registry - registry-data:/var/lib/registry depends_on: # - nginx volumes: registry-data: 启动Swarm mode由于 Docker Machine 不包含 Compose，这里使用 Swarm mode。 123456789101112131415161718192021$ docker-machine create \ --driver virtualbox \ --engine-opt dns=114.114.114.114 \ --engine-registry-mirror https://registry.docker-cn.com \ --virtualbox-memory 2048 \ --virtualbox-cpu-count 2 \ registry$ docker-machine ip registry$ docker-machine ssh registry$ docker swarm init --advertise-addr=192.168.99.100$ git clone --depth=1 https://github.com/khs1994-docker/registry.git$ cd registry# 修改配置之后$ docker stack deploy -c docker-compose.yml registry 自定义镜像并运行配置好所需文件，构建镜像，运行容器 123456$ docker build -t username/registry .$ docker run -dit \ --mount src=registry-data,target=/var/lib/registry \ -p 443:443 \ username/registry Docker Compose1$ docker-compose up -d Nginx 代理配置https://docs.docker.com/registry/recipes/nginx/ 若使用外部 Nginx，在 docker-compose.yml 将端口配置为 5000:443。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960upstream docker-registry &#123; # 修改 IP server 127.0.0.1:5000;&#125; ## Set a variable to help us decide if we need to add the ## 'Docker-Distribution-Api-Version' header. ## The registry always sets this header. ## In the case of nginx performing auth, the header will be unset ## since nginx is auth-ing before proxying.map $upstream_http_docker_distribution_api_version $docker_distribution_api_version &#123; '' 'registry/2.0';&#125;server &#123; listen 443 ssl; # 修改域名 server_name docker.domain.com; # SSL # 修改 SSL 路径 ssl_certificate conf.d/ssl/docker.domain.com.crt; ssl_certificate_key conf.d/ssl/docker.domain.com.key; # Recommendations from https://raymii.org/s/tutorials/Strong_SSL_Security_On_nginx.html ssl_protocols TLSv1.1 TLSv1.2; ssl_ciphers 'EECDH+AESGCM:EDH+AESGCM:AES256+EECDH:AES256+EDH'; ssl_prefer_server_ciphers on; ssl_session_cache shared:SSL:1m; # disable any limits to avoid HTTP 413 for large image uploads client_max_body_size 0; # required to avoid HTTP 411: see Issue #1486 (https://github.com/moby/moby/issues/1486) chunked_transfer_encoding on; location /v2/ &#123; # Do not allow connections from docker 1.5 and earlier # docker pre-1.6.0 did not properly set the user agent on ping, catch "Go *" user agents if ($http_user_agent ~ "^(docker\/1\.(3|4|5(?!\.[0-9]-dev))|Go ).*$" ) &#123; return 404; &#125; # To add basic authentication to v2 use auth_basic setting. # nginx not support bcrypt. auth_basic "Registry realm"; auth_basic_user_file conf.d/auth/nginx.htpasswd; ## If $docker_distribution_api_version is empty, the header will not be added. ## See the map directive above where this variable is defined. add_header 'Docker-Distribution-Api-Version' $docker_distribution_api_version always; proxy_pass http://docker-registry; proxy_set_header Host $http_host; # required for docker client's sake proxy_set_header X-Real-IP $remote_addr; # pass on real client's IP proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto $scheme; proxy_read_timeout 900; &#125;&#125; 测试私有仓库功能修改 /etc/hosts，替换为对应 IP 1127.0.0.1 docker.domain.com 网页查看https://docker.domain.com/v2/_catalog 命令行登录12$ docker login docker.domain.com#接下来输入用户名、密码 命令行操作12345$ docker pull nginx:alpine$ docker tag nginx docker.khs1994.com/nginx:alpine$ docker push docker.khs1994.com/nginx:alpine$ docker rm docker.domain.com/nginx:alpine$ docker pull docker.domain.com/nginx:alpine 命令参考1$ docker exec &#123;docker-registry id&#125; registry [command] 垃圾回收https://docs.docker.com/registry/garbage-collection/ 12$ docker exec -it &#123;docker-registry id&#125; \ bin/registry garbage-collect [--dry-run] /etc/docker/registry/config.yml 搜索参考 API：https://docs.docker.com/registry/spec/api/ 查看版本123$ docker exec &#123;docker-registry id&#125; registry --versionregistry github.com/docker/distribution v2.6.0 帮助信息1$ docker exec [docker-registry id] registry help 相关链接 官方文档 Dockerfile Nginx 代理 http://www.jb51.net/os/other/369064.html http://www.tuicool.com/articles/fAbiYnN]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Compose version 3 使用详解]]></title>
    <url>%2Fdocker%2Fcompose.html</url>
    <content type="text"><![CDATA[Define application stacks built using multiple containers, services, and swarm configurations. GitHub: https://github.com/docker/compose installDocker CE for Windows 10 、Docker CE for Mac 自带 docker-compose，官方建议随 Docker 版本升级。 Linux 请在 GitHub releases 处下载二进制文件，移入 PATH 并赋予可执行权限。 或者执行以下命令进行下载安装。 123456789$ DOCKER_COMPOSE_VERSION=1.18.0$ curl -L https://github.com/docker/compose/releases/download/$&#123;DOCKER_COMPOSE_VERSION&#125;/docker-compose-`uname -s`-`uname -m` &gt; docker-compose$ chmod +x docker-compose$ sudo mv docker-compose /usr/local/bin$ docker-compose --version 或者通过 Python 包管理工具 pip 安装。 Command-line completionfish~/.config/fish/completions 1$ wget https://raw.githubusercontent.com/docker/compose/master/contrib/completion/fish/docker-compose.fish bash官方文档：https://docs.docker.com/compose/completion/ Compose file referencebuild12345678910111213141516171819202122232425version: '3'services: webapp: build: # Dockerfile 目录或 git 仓库网址 context: ./dir | . # Dockerfile 文件名称 dockerfile: Dockerfile-alternate # 3.2 cache_from: - alpine:latest - corp/web_app:3.14 # 3.3 labels: com.example.description: "Accounting webapp" com.example.department: "Finance" com.example.label-with-empty-value: "" # 构建时变量，相当于 docker build --build-arg list args: buildno: 1 args: - buildno=1 # 3.5 shm_size: '2gb' image: webapp:tag Dockerfile 中包含变量 12345ARG buildnoARG passwordRUN echo "Build number: $buildno"RUN script-requiring-password.sh "$password" cap_add, cap_drop没用过，不了解。 Add or drop container capabilities. See man 7 capabilities for a full list. 123456cap_add: - ALLcap_drop: - NET_ADMIN - SYS_ADMIN command12345678910command: bundle exec thin -p 3000command: ["bundle", "exec", "thin", "-p", "3000"]command: - bundle - exec - thin - -p - 3000 configs3.3 12345678910111213141516version: "3.3"services: redis: image: redis:latest deploy: replicas: 1 configs: - my_config - my_other_configconfigs: my_config: file: ./my_config.txt # 使用外部的 config，使用 docker config create 命令创建的 config my_other_config: external: true 12345678910111213141516171819version: "3.3"services: redis: image: redis:latest deploy: replicas: 1 configs: - source: my_config target: /redis_config uid: '103' gid: '103' mode: 0440configs: my_config: file: ./my_config.txt my_other_config: external: true cgroup_parentSpecify an optional parent cgroup for the container. 1cgroup_parent: m-executor-abcd container_name不建议使用，此项配置的话，服务将不能扩展。 1container_name: my-web-container credential_spec没用过，不了解。 3.3 仅用于 Windows 容器。 deploy仅用于 Swarm mode 12345678910111213141516version: '3'services: redis: image: redis:alpine deploy: # 集群中运行该服务的容器个数 mode: replicated replicas: 6 update_config: parallelism: 2 delay: 10s restart_policy: condition: on-failure labels: com.example.description: "This label will appear on the web service" endpoint_mode3.3 123deploy: endpoint_mode: vip endpoint_mode: dnsrr modehttps://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#replicated-and-global-services 12345deploy: # 每个节点一个容器 exactly one container per swarm node mode: global # 指定数量的容器 a specified number of containers mode: replicated placement12345678deploy: placement: constraints: # 运行在管理节点 - node.role == manager - engine.labels.operatingsystem == ubuntu 14.04 preferences: - spread: node.labels.zone resources资源限制 12345678deploy: resources: limits: cpus: '0.50' memory: 50M reservations: cpus: '0.25' memory: 20M restart_policy12345678910111213version: "3"services: redis: image: redis:alpine deploy: restart_policy: condition: none | on-failure | any (默认) # 等待时间 delay: 5s # 最大尝试次数 max_attempts: 3 # How long to wait before deciding if a restart has succeeded, specified as a duration (default: decide immediately) window: 120s update_config1234567891011121314151617version: '3.4'services: vote: image: dockersamples/examplevotingapp_vote:before depends_on: - redis deploy: replicas: 2 update_config: # 同时升级 config 的容器个数 parallelism: 2 delay: 10s failure_action: continue | rollback | pause (默认) monitor: max_failure_ration: # 3.4 order: stop-first (默认) | start-first docker stack deploy 不支持以下参数 build cgroup_parent container_name devices tmpfs external_links links network_mode security_opt stop_signal sysctls userns_mode devicesList of device mappings. Uses the same format as the –device docker client create option. 12devices: - "/dev/ttyUSB0:/dev/ttyUSB0" depends_on保证依赖的服务完全启动之后才启动 https://docs.docker.com/compose/startup-order/ 依赖关系 1234567891011121314version: '3'services: web: build: . depends_on: - db - redis redis: image: redis db: image: postgres dns12345dns: 8.8.8.8dns: - 8.8.8.8 - 9.9.9.9 dns_search12345dns_search: example.comdns_search: - dc1.example.com - dc2.example.com tmpfs12345tmpfs: /runtmpfs: - /run - /tmp entrypoint入口文件 123456789entrypoint: /code/entrypoint.shentrypoint: - php - -d - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so - -d - memory_limit=-1 - vendor/bin/phpunit env_file从文件读取变量写入镜像 环境变量 123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 若变量重复，后边文件的变量会覆盖后边的。 env 文件内容举例 12# 支持 # 号注释RACK_ENV=development environment设置环境变量 123456789environment: RACK_ENV: development SHOW: 'true' SESSION_SECRET:environment: - RACK_ENV=development - SHOW=true - SESSION_SECRET expose内部暴露端口 123expose: - "3000" - "8000" external_links链接外部容器。不建议使用，建议通过网络进行连接！ CONTAINER:ALIAS 1234external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql extra_hosts123extra_hosts: - "somehost:162.242.195.82" - "otherhost:50.31.209.229" 在容器内 /etc/hosts 写入下面的内容 12162.242.195.82 somehost50.31.209.229 otherhost healthcheck健康检查 12345678healthcheck: test: ["CMD", "curl", "-f", "http://localhost"] # 间隔 interval: 1m30s # 超时时间 timeout: 10s # 重试次数 retries: 3 123456# Hit the local web apptest: ["CMD", "curl", "-f", "http://localhost"]# As above, but wrapped in /bin/sh. Both forms below are equivalent.test: ["CMD-SHELL", "curl -f http://localhost &amp;&amp; echo 'cool, it works'"]test: curl -f https://localhost &amp;&amp; echo 'cool, it works' image12345image: redisimage: ubuntu:14.04image: tutum/influxdbimage: example-registry.com:4000/postgresqlimage: a4bc65fd isolationhttps://docs.docker.com/engine/reference/commandline/run/#specify-isolation-technology-for-container---isolation Specify a container’s isolation technology. On Linux, the only supported value is default. On Windows, acceptable values are default, processand hyperv. labels123456789labels: com.example.description: "Accounting webapp" com.example.department: "Finance" com.example.label-with-empty-value: ""labels: - "com.example.description=Accounting webapp" - "com.example.department=Finance" - "com.example.label-with-empty-value" links不建议使用！ 12345web: links: - db - db:database - redis logging日志配置 1234logging: driver: syslog options: syslog-address: "tcp://192.168.0.42:123" 123driver: "json-file"driver: "syslog"driver: "none" 123options: max-size: "200k" max-file: "10" 12345678services: some-service: image: some-service logging: driver: "json-file" options: max-size: "200k" max-file: "10" network_mode12345network_mode: "bridge"network_mode: "host"network_mode: "none"network_mode: "service:[service name]"network_mode: "container:[container name/id]" networks12345services: some-service: networks: - some-network - other-network aliases12345678910services: some-service: networks: some-network: aliases: - alias1 - alias3 other-network: aliases: - alias2 1234567891011121314151617181920212223242526version: '2'services: web: build: ./web networks: - new worker: build: ./worker networks: - legacy db: image: mysql networks: new: aliases: - database legacy: aliases: - mysqlnetworks: new: legacy: ipv4_address ipv6_address12345678910111213141516171819202122version: '2.1'services: app: image: busybox command: ifconfig networks: app_net: ipv4_address: 172.16.238.10 ipv6_address: 2001:3984:3989::10networks: app_net: driver: bridge enable_ipv6: true ipam: driver: default config: - subnet: 172.16.238.0/24 - subnet: 2001:3984:3989::/64 pid1pid: "host" ports123456789ports: - "3000" - "3000-3005" - "8000:8000" - "9090-9091:8080-8081" - "49100:22" - "127.0.0.1:8001:8001" - "127.0.0.1:5000-5010:5000-5010" - "6060:6060/udp" 3.2 开始支持长格式 12345ports: - target: 80 published: 8080 protocol: tcp mode: host secrets123456789101112131415version: "3.1"services: redis: image: redis:latest deploy: replicas: 1 secrets: - my_secret - my_other_secretsecrets: my_secret: file: ./my_secret.txt my_other_secret: # 使用外部 secret external: true 长格式 1234567891011121314151617version: "3.1"services: redis: image: redis:latest deploy: replicas: 1 secrets: - source: my_secret target: redis_secret uid: '103' gid: '103' mode: 0440secrets: my_secret: file: ./my_secret.txt my_other_secret: external: true security_opt123security_opt: - label:user:USER - label:role:ROLE stop_grace_period12stop_grace_period: 1sstop_grace_period: 1m30s stop_signal1stop_signal: SIGUSR1 sysctlsKernel parameters to set in the container. You can use either an array or a dictionary. 1234567sysctls: net.core.somaxconn: 1024 net.ipv4.tcp_syncookies: 0sysctls: - net.core.somaxconn=1024 - net.ipv4.tcp_syncookies=0 ulimitsOverride the default ulimits for a container. You can either specify a single limit as an integer or soft/hard limits as a mapping. 12345ulimits: nproc: 65535 nofile: soft: 20000 hard: 40000 userns_modeDisables the user namespace for this service, if Docker daemon is configured with user namespaces. See dockerd for more information. 1userns_mode: "host" volumes1234567891011121314151617181920212223version: "3.2"services: web: image: nginx:alpine volumes: - type: volume source: mydata target: /data volume: nocopy: true - type: bind source: ./static target: /opt/app/static db: image: postgres:latest volumes: - "/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock" - "dbdata:/var/lib/postgresql/data"volumes: mydata: dbdata: 12345678910111213141516171819volumes: # Just specify a path and let the Engine create a volume - /var/lib/mysql # Specify an absolute path mapping - /opt/data:/var/lib/mysql # Path on the host, relative to the Compose file - ./cache:/tmp/cache # User-relative path - ~/configs:/etc/configs/:ro # Named volume - datavolume:/var/lib/mysql # - source:/target:constraints (默认) | cached (宿主机优先)| delegated (容器优先) 12345678910111213141516171819version: "3.2"services: web: image: nginx:alpine ports: - "80:80"networks: webnet:volumes: - type: volume source: mydata target: /data volume: nocopy: true - type: bind source: ./static target: /opt/app/static restart1234restart: "no"restart: alwaysrestart: on-failurerestart: unless-stopped domainname, hostname, ipc, mac_address, privileged, read_only, shm_size, stdin_open, tty, user, working_dir123456789101112131415user: postgresqlworking_dir: /codedomainname: foo.comhostname: fooipc: hostmac_address: 02:42:ac:11:65:43privileged: trueread_only: trueshm_size: 64Mstdin_open: truetty: true Specifying durations123452.5s10s1m30s2h32m5h34m56s Volume configuration reference1234567891011121314version: "3"services: db: image: db volumes: - data-volume:/var/lib/db backup: image: backup-service volumes: - data-volume:/var/lib/backup/datavolumes: data-volume: 1driver: foobar 123driver_opts: foo: "bar" baz: 1 123volumes: data: external: true 123456789labels: com.example.description: "Database volume" com.example.department: "IT/Ops" com.example.label-with-empty-value: ""labels: - "com.example.description=Database volume" - "com.example.department=IT/Ops" - "com.example.label-with-empty-value" 1234volumes: data: external: name: actual-name-of-volume name1234version: '3.4'volumes: data: name: my-app-data 12345version: '3.4'volumes: data: external: true name: my-app-data Network configuration reference1driver: overlay host OR none用于 docker stack，如果使用 docker-compose 请使用 network_mode。 类似于 docker run --net=host 12345678910services: web: ... networks: hostnet: &#123;&#125;networks: hostnet: external: name: host 类似于 docker run --net=none 12345678910services: web: ... networks: nonet: &#123;&#125;networks: nonet: external: name: none driver_opts123driver_opts: foo: "bar" baz: 1 attachable1234networks: mynet1: driver: overlay attachable: true ipam1234ipam: driver: default config: - subnet: 172.28.0.0/16 name3.5 1234version: '3.5'networks: network1: name: my-app-net 12345version: '3.5'networks: network1: external: true name: my-app-net configs configuration reference12345configs: my_first_config: file: ./config_data my_second_config: external: true 3.5 123456configs: my_first_config: file: ./config_data my_second_config: external: name: redis_config secrets configuration reference12345secrets: my_first_secret: file: ./secret_data my_second_secret: external: true 3.5 123456secrets: my_first_secret: file: ./secret_data my_second_secret: external: name: redis_secret Variable substitution12db: image: "postgres:$&#123;POSTGRES_VERSION&#125;" 从 .env 文件或系统变量中读取变量，来替换 compose 文件中的变量。 docker stack deploy 不支持变量读取。 $VAR ${VAR} 这两种格式都支持。 ${VARIABLE:-default} 如果 VARIABLE 被 unset 或为空 (empty) 时设置为 default。 ${VARIABLE-default} 如果 VARIABLE 被 unset 时设置为 default。 使用 $$ 避免解析变量 123web: build: . command: "$$VAR_NOT_INTERPOLATED_BY_COMPOSE" Extension fields12345678version: '2.1'x-custom: items: - a - b options: max-size: '12m' name: "custom" 12345logging: options: max-size: '12m' max-file: '5' driver: json-fi 123456789101112131415version: '2.1'x-logging: &amp;default-logging options: max-size: '12m' max-file: '5' driver: json-fileservices: web: image: myapp/web:latest logging: *default-logging db: image: mysql:latest logging: *default-logging 123456789101112131415161718version: '2.1'x-volumes: &amp;default-volume driver: foobar-storageservices: web: image: myapp/web:latest volumes: ["vol1", "vol2", "vol3"]volumes: vol1: *default-volume vol2: &lt;&lt; : *default-volume name: volume02 vol3: &lt;&lt; : *default-volume driver: default name: volume-local More Information https://docs.docker.com/compose/install/ https://docs.docker.com/compose/compose-file/]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iPXE 模式启动 CoreOS（简单、推荐使用）]]></title>
    <url>%2Fdocker%2Fcoreos%2Fboot-ipxe.html</url>
    <content type="text"><![CDATA[iPXE 模式启动 CoreOS 方法比较简单，无需配置 PXE 所需的服务器，推荐大家使用。 准备下载 ipxe.iso1$ wget http://boot.ipxe.org/ipxe.iso 克隆示例配置克隆示例配置文件并启动内网安装服务器。 GitHub：https://github.com/khs1994-docker/lnmp-k8s/tree/master/coreos 12345$ git clone --depth=1 https://github.com/khs1994-docker/lnmp-k8s$ cd coreos$ ./coreos server # 默认监听 8080 端口 内网服务器详情请参见 CoreOS 安装服务本地服务器 Docker 化。 放入文件在 http://alpha.release.core-os.net/amd64-usr/ 点击版本号或 current ，下载以下文件: coreos_production_pxe.vmlinuz coreos_production_pxe_image.cpio.gz 放入 current 文件夹中。 ipxe.html打开示例中的 ipxe.html，按实际修改 IP 123456#!ipxeset base-url http://192.168.199.100:8080/currentkernel $&#123;base-url&#125;/coreos_production_pxe.vmlinuz initrd=coreos_production_pxe_image.cpio.gz coreos.first_boot=1 coreos.config.url=http://192.168.199.100:8080/pxe/pxe-config.ign console=tty0 console=ttyS0 coreos.autologin=tty1 coreos.autologin=ttyS0initrd $&#123;base-url&#125;/coreos_production_pxe_image.cpio.gzboot pxe-ignition.yaml进入示例中的 ./pxe/ 目录，在 ./pxe/pxe-ignition.yaml 中设置 SSH 公钥。 12345678910systemd: units: - name: etcd2.service enable: truepasswd: users: - name: core ssh_authorized_keys: - ssh-rsa AAAA... pxe-config.ign之后使用以下命令转换为 pxe-config.ign 1$ ct-v0.5.0-x86_64-apple-darwin -in-file pxe-ignition.yaml &gt; pxe-config.ign 格式转换之后可以验证 pxe-config.ign https://coreos.com/validate/ 启动虚拟机虚拟机添加 ipxe.iso ISO 镜像之后启动。 在启动界面按下 Ctrl+B ，依次输入以下命令。 12iPXE&gt; dhcpiPXE&gt; chain http://192.168.199.100:8080/ipxe.html 登录IPXE 方式启动的 CoreOS 默认没有密码，直接在本机登录。 1$ ssh core@ip 安装之后 安装到硬盘。]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PXE 模式启动 CoreOS]]></title>
    <url>%2Fdocker%2Fcoreos%2Fboot-pxe-new.html</url>
    <content type="text"><![CDATA[本文是对 CoreOS 官方文档 Booting with PXE 的翻译与补充。 安装配置 PXE 服务器安装配置 PXE 服务器请查看本博客文章 Linux 自动部署。 准备文件进入 http://alpha.release.core-os.net/amd64-usr/ 点击版本号或 current ，下载以下文件: coreos_production_pxe.vmlinuz coreos_production_pxe_image.cpio.gz PXE 服务器配置详情将以上两文件上传到 PXE 服务器的 /var/lib/tftpboot 目录下。并在 PXE 服务器中执行以下操作 12345678910111213$ cp /usr/share/syslinux/pxelinux.0 .$ mkdir /var/lib/tftpboot/pxelinux.cfg$ vi /var/lib/tftpboot/pxelinux.cfg/defaultdefault coreosprompt 1timeout 15label coreosmenu default kernel coreos_production_pxe.vmlinuz initrd coreos_production_pxe_image.cpio.gz append coreos.first_boot=1 coreos.config.url=https://192.168.199.100:8080/pxe/pxe-config.ign 克隆示例配置克隆示例配置文件并启动内网安装服务器。 GitHub：https://github.com/khs1994-docker/lnmp-k8s/tree/master/coreos 12345$ git clone --depth=1 hhttps://github.com/khs1994-docker/lnmp-k8s$ cd coreos$ ./coreos server # 默认监听 8080 端口 内网服务器详情请参见 CoreOS 安装服务本地服务器 Docker 化。 pxe-ignition.yaml进入示例中的 ./pxe/ 目录，在 ./pxe/pxe-ignition.yaml 中设置 SSH 公钥。 12345678910systemd: units: - name: etcd2.service enable: truepasswd: users: - name: core ssh_authorized_keys: - ssh-rsa AAAAB3N pxe-config.ign将 pxe-ignition.yaml 转化为 pxe-config.ign。 1$ ct-v0.5.0-x86_64-apple-darwin -in-file pxe-ignition.yaml &gt; pxe-config.ign 启动虚拟机VirtualBox 使用 PXE 启动，必须安装扩展包。 登录在本机登录 1$ ssh core@ip 之后 安装到硬盘 或挂载磁盘作为数据磁盘使用。]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[硬盘安装 CoreOS 三节点集群]]></title>
    <url>%2Fdocker%2Fcoreos%2Finstall-disk-new.html</url>
    <content type="text"><![CDATA[本例在 VirtualBox 虚拟机，以 ISO 或者 PXE 或者 iPXE 模式启动 CoreOS，然后安装到硬盘。 更新记录 2017/12：默认启用 Docker Daemon TLS 远程连接。 2017/8：CoreOS 配置工具使用新的 Ignition 代替 cloud-config，旧的安装方法已经删除，但 GitHub 仍保留该配置文件。 设置网卡模式VirtualBox 虚拟机网络设置如下 网卡 模式 IP 网卡1 host-only (DHCP) 192.168.57.* 网卡2 桥接 (DHCP) 192.168.199.* 本例中三个节点 IP 分别为： 192.168.57.110 192.168.57.111 192.168.57.112 VirtualBox 可以新建该网段，如果你的节点不是以上 IP 请按照 https://www.khs194.com/docker/dockerd.html 提供的方法，生成证书。 准备文件进入 http://alpha.release.core-os.net/amd64-usr/ 点击特定的版本号或最后的 current ，下载以下文件: iso 启动文件 coreos_production_iso_image.iso 下载链接 镜像文件 coreos_production_image.bin.bz2 下载链接 签名文件 coreos_production_image.bin.bz2.sig 下载链接 版本信息文件 version.txt 下载链接 注意 四个文件 缺一不可 克隆示例配置文件GitHub：https://github.com/khs1994-docker/lnmp-k8s/tree/master/coreos 123$ git clone --depth=1 https://github.com/khs1994-docker/lnmp-k8s$ cd coreos 修改 .env 文件中的变量值各项变量含义都已经注明，按实际修改即可 放入文件把 coreos_production_image.bin.bz2 coreos_production_image.bin.bz2.sig version.txt 放入 current 文件夹中（三者缺一不可）。 启动容器1$ ./coreos server 安装 CoreOS启动 虚拟机内存最低设置为 2G，否则将不能使用！ 新建虚拟机，添加按照文章开头设置两块网卡，选择加载 coreos_production_iso_image.iso ISO 镜像之后启动。 ISO 启动方式不支持 UEFI 1234567# 查看 IP 以便后边登录$ ip addr# 需要改密码 虚拟机里输入命令不方便,本机 ssh 登录操作$ sudo passwd core SSH 登录并安装本机登陆 123456789101112131415161718192021$ ssh core@IP$ wget http://192.168.57.1:8080/disk/ignition-1.json# 必须以 root 用户运行，安装脚本通过 `-i` 选项加载配置文件 `ignition.json`$ sudo coreos-install \ -d /dev/sda \ -C alpha \ -i ignition-1.json \ -b http://192.168.57.1:8080 \ -v# 该命令也提供了 -V 参数可以安装指定版本 -V 1590.0.0+ echo 'Success! CoreOS Container Linux alpha 1590.0.0 is installed on /dev/sda'Success! CoreOS Container Linux alpha 1590.0.0 is installed on /dev/sda# 执行成功后，关闭虚拟机$ sudo shutdown now 关闭虚拟机之后移除 ISO，在虚拟机设置 系统 里选择 启用 EFI，稍后启动。接下来在其他两个节点进行安装。 在另外两个节点安装重复上边两步，注意每次 wget 所下载的文件是不同的，coreos-install 命令 -i 参数后边跟着 wget 所下载的文件。 1234567891011$ ssh core@IP$ wget http://192.168.57.1:8080/disk/ignition-2.json# $ wget http://192.168.57.1:8080/disk/ignition-3.json$ sudo coreos-install -d /dev/sda -C alpha \ -i ignition-2.json -v -b http://192.168.57.1:8080# $ sudo coreos-install -d /dev/sda -C alpha \# -i ignition-3.json -v -b http://192.168.57.1:8080 参数说明1234567891011121314151617181920$ coreos-install -hUsage: /usr/bin/coreos-install [-C channel] -d /dev/deviceOptions: -d DEVICE Install Container Linux to the given device. -V VERSION Version to install (e.g. current) [default: 1590.0.0] -B BOARD Container Linux board to use [default: amd64-usr] -C CHANNEL Release channel to use (e.g. beta) [default: alpha] -o OEM OEM type to install (e.g. ami) [default: (none)] -c CLOUD Insert a cloud-init config to be executed on boot. -i IGNITION Insert an Ignition config to be executed on boot. -b BASEURL URL to the image mirror (overrides BOARD) -k KEYFILE Override default GPG key for verifying image signature -f IMAGE Install unverified local image file to disk instead of fetching -n Copy generated network units to the root partition. -v Super verbose, for debugging. -h This ;-)This tool installs CoreOS Container Linux on a block device. If you PXE bootedContainer Linux on a machine then use this tool to make a permanent install. 启动三个节点全部安装之后，依次启动虚拟机。 SSH 登录123456$ ssh core@192.168.57.110Last login: Wed Nov 29 11:52:26 UTC 2017 from 192.168.57.1 on pts/0Container Linux by CoreOS alpha (1590.0.0)core@coreos1 ~ $ docker --versionDocker version 17.10.0-ce, build afdb6d4 网络配置删除内网路由根据实际配置网络 12$ ip route show$ sudo ip route del default 相关链接 https://yq.aliyun.com/articles/42288 https://raw.githubusercontent.com/coreos/init/master/bin/coreos-install]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI 构建 GitBook 实践]]></title>
    <url>%2Fci%2Ftravis-ci%2Fgitbook.html</url>
    <content type="text"><![CDATA[本文只提供思路，具体实现请查看本人博客的其他文章。务必对 Travis CI 基础知识 了解之后再阅读本文。 刚开始在 Travis CI 中从零开始搭建环境，全部执行时间为 三分半，将环境部署进 Docker， docker run XXX 之后直接开始生成，时间缩短为 一分半。 准备 GitBook 项目文件新建 .travis 文件夹复制根目录 book.json 文件编写 Dockerfile 文件1234567891011121314151617181920212223242526FROM node:9-alpineENV TZ=Asia/ShanghaiWORKDIR /srv/gitbookCOPY book.json book.jsonCOPY docker-entrypoint.sh /usr/local/bin/RUN apk add --no-cache \ tzdata \ &amp;&amp; npm install -g gitbook-cli \ &amp;&amp; gitbook install \ &amp;&amp; ln -s /usr/local/bin/docker-entrypoint.sh / \ &amp;&amp; rm -rf /root/.npm /tmp/*EXPOSE 4000VOLUME /srv/gitbook-srcWORKDIR /srv/gitbook-srcENTRYPOINT ["docker-entrypoint.sh"]CMD server 编写 docker-entrypoint.sh 文件123456789101112131415161718192021222324#!/bin/shSTART=`date "+%F %T"`if [ $1 = "sh" ];then sh ; exit 0; firm -rf node_modules _bookcp -a . ../gitbookcd ../gitbookmain()&#123; if [ "$1" = build ];then gitbook build cp -a _book ../gitbook-src echo $START exec date "+%F %T" fi gitbook serve exit 0&#125;main $1 $2 $3 编写 docker-compose.test.yml 文件12345sut: build: . volumes: - ../:/srv/gitbook-srccommand: build 该文件用于 Docker Cloud 在每次提交 PR 时测试。 加密 SSH 私钥该文件一般为 id_rsa.enc 根目录文件编写 .travis.yaml123456789101112131415161718192021222324252627282930313233language: bashsudo: requiredservices:- dockerbefore_install:- openssl aes-256-cbc -K $encrypted_6cc8cff04075_key -iv $encrypted_6cc8cff04075_iv -in .travis/id_rsa.enc -out ~/.ssh/id_rsa -d- chmod 600 ~/.ssh/id_rsa- export TZ='Asia/Shanghai'- date- git config --global user.name "khs1994"- git config --global user.email "khs1994@khs1994.com"script:- docker run -it --rm -v $PWD:/srv/gitbook-src yeasy/docker_practice buildafter_success:- sudo chmod -R 777 _book- cd _book- git init- git remote add origin "$REPO"- git add .- COMMIT=`date "+%F %T"`- git commit -m "Travis CI Site updated $COMMIT"- git push -f origin master:"$DEPLOY_BRANCH"env: global: - DEPLOY_BRANCH: pages - REPO: git@github.com:yeasy/docker_practice.gitaddons: ssh_known_hosts: - github.combranches: only: - master 编写 docker-compose.yml123456789101112131415161718192021222324252627version: "3"services: server: # build: ./.travis image: username/project:latest ports: - 4000:4000 volumes: - ./:/srv/gitbook-src command: server build: image: username/project:latest volumes: - ./:/srv/gitbook-src command: build development: build: ./.travis image: username/project:latest ports: - 4000:4000 volumes: - ./:/srv/gitbook-src command: server # command: build 构键 Docker 镜像并推送1234# 根目录执行$ docker-compose build development$ docker-compose push development 不在本地构建镜像也行，在 Docker Cloud 关联 GitHub 仓库构建也可以。 推送 GitBook 项目到 GitHub示例如果不清楚文件夹结构，可以参考：https://github.com/yeasy/docker_practice 相关链接 https://github.com/steveklabnik/automatically_update_github_pages_with_travis_example http://blog.csdn.net/qq8427003/article/details/64921201]]></content>
      <categories>
        <category>CI</category>
        <category>Travis CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>GitBook</tag>
        <tag>Travis CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo + Travis CI 实践（整合优化）]]></title>
    <url>%2Fci%2Ftravis-ci%2Fhexo.html</url>
    <content type="text"><![CDATA[本文简要介绍了使用 Travis CI 构建 Hexo。务必对 Travis CI 基础知识 了解之后再阅读本文。 示例文件：https://github.com/khs1994/khs1994.github.io/blob/hexo/.travis.yml 使用 Travis CI 之前 本地编写 source/*.md hexo g 本地预览 hexo d 推送到 GitHub 和 aliyun 手动 完成后续操作：登录到服务器，pull 到网站根目录。 使用 Travis CI 本地编写 source/*.md hexo g 本地预览 将部署文件推送到 GitHub 和 aliyun 自动 完成后续操作： Travis CI 云端生成 HTML,并将其推送到 GitHub 和 aliyun 仓库的 master 分支 GitHub webhooks 通知服务器，服务器将 aliyun 仓库的代码 强制pull 调用 百度站长平台 完成URL 主动推送 调用 微信公众平台 模板消息 API 完成消息提醒 配置在 Travis CI 网站开启项目部署。 GitHub 仓库 hexo 分支 存放部署文件，master 分支 存放生成的静态 HTML 文件。 注意：用户名.github.io 仓库的 Pages 服务 只能使用 master 分支。 在项目根目录编写 .travis.yml，示例文件：https://github.com/khs1994/khs1994.github.io/blob/hexo/.travis.yml 使用 命令行工具 加密 SSH 私钥（也可以使用 github Token）注意去掉转义符。 最后推送项目到 GitHub。 相关链接 http://blog.csdn.net/woblog/article/details/51319364 https://segmentfault.com/a/1190000004667156]]></content>
      <categories>
        <category>CI</category>
        <category>Travis CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Travis CI</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI 使用详解]]></title>
    <url>%2Fci%2Ftravis-ci%2FREADME.html</url>
    <content type="text"><![CDATA[本文列举了使用 Travis CI 可能遇到的问题及其解决方法。 官方网站：https://travis-ci.com 官方文档：https://docs.travis-ci.com/ 更新说明 travis-ci 有两个网站 .com 和 .org，之前 .com 用于私有项目，.org 用于开源项目。随着 travis ci 逐步使用 GitHub App，.org 网站会被弃用新用户请使用 .com sudo: 指令废弃，移除容器接口，所有构建都在虚拟机中进行 注册登录在 https://travis-ci.com 直接通过 GitHub 登录。 项目同步 目前，travis 仅支持构建 GitHub 项目。 登录之后点击右上角用户名，再点击左上的 Sync account 来同步 GitHub 项目。 如果你名下的 GitHub 组织没有显示，请点击左下 Review and add 重新授予权限。 安装 Travis CI GitHub App。 使用 Travis CI在 Git 项目根目录增加 .travis.yml 文件，即可开始使用 travis， travis 会在项目每次提交（push），PR，tag 时自动构建项目。 使用示例 https://github.com/khs1994/khs1994.github.io/blob/hexo/.travis.yml https://github.com/travis-ci-examples 构建变量（环境变量）在每个项目的设置页面中，通过 K-V 形式设置环境变量。 变量分为加密变量（构建过程不可见）和普通变量。 加密变量在构建项目中他人的 PR 时将不能被使用。在构建项目内不同分支的 PR 时可以使用。这一点需要注意： 例如，项目的 dev 分支向 master 分支提交 PR，构建 PR 时就可以使用加密变量。 他人向 dev 分支提交 PR，构建 PR 时就不能使用加密变量。 命令行工具安装 Travis CI 命令行工具 123456$ sudo gem install travis# 登录# github-token 在 GitHub 设置页面生成，当然也可以使用密码登录$ sudo travis login --github-token 0abc23... SSH我们现在要让 Travis CI 能够通过 SSH 登录到 服务器，就将 ~/.ssh/id_rsa 「加密复制」 到 Travis CI。 加密 id_rsa进入项目根目录执行： 1$ travis encrypt-file ~/.ssh/id_rsa --add 请根据实际修改 SSH 密钥文件名，一般默认为 id_rsa。 解密 id_rsa命令执行之后，自动生成了 id_rsa.enc 文件，并自动在 .travis.yml 增加如下内容： 123before_install:- openssl aes-256-cbc -K $encrypted_023c3608ff03_key -iv $encrypted_023c3608ff03_iv -in id_rsa.enc -out ~\/.ssh/id_rsa -d 注意：请将上述内容的 转义符 去掉: -out ~\/.ssh/id_rsa -d 改为 -out ~/.ssh/id_rsa -d ssh_known_hosts首次 SSH 到某网址或 IP 需要输入 yes 来确认，你可以在 .travis.yml 文件中增加 ssh_known_hosts 来避免输入 yes 12345678after_success: - scp README.md ubuntu@123.206.62.18:~addons: ssh_known_hosts: - 123.206.62.18 - code.aliyun.com - github.com 构建规则指定分支构建12345678910branches: only: - master - /.*/ - /^deploy-.*$/branches: except: - legacy - experimental 这样 travis 只会构建 master 分支，dev 等其他分支提交(push)时不会构建。 部署GitHub Pages https://docs.travis-ci.com/user/deployment/pages 1234567891011deploy: provider: pages # 要 push 的文件夹 local-dir: _book # pages 所在分支 target-branch: master skip-cleanup: true # 若为 false （默认） 会运行 `git stash -all` 把 git 目录中更改的藏起来 # 意味着 在 deploy 之前会把 git 恢复到初始状态，所以当提交对象（新生成）在 git 仓库中，必须设置为 true，具体原理请查看 `git stash` github-token: $GH_TOKEN # Set in travis-ci.org settings on: branch: gitbook # 哪个分支构建的就推送 script123456deploy: provider: script script: .travis/deploy.sh skip-cleanup: true on: branch: gitbook 缓存 Cache123cache: directories: - node_modules 编程语言在 .travis.yml 文件开头首先指明编程语言 123language: phpos: osx 请查看 官方文档 加密文件https://docs.travis-ci.com/user/encrypting-files/ 构建生命周期123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115language: phpos: - linux - osxservices: - docker - mysqlcache: directories: - vendorgit: depth: 3 depth: false submodules: falseaddons: apt: sources: - deadsnakes - sourceline: 'ppa:ubuntu-toolchain-r/test' - sourceline: 'deb https://packagecloud.io/chef/stable/ubuntu/precise main' key_url: 'https://packagecloud.io/gpg.key' hosts: - travis.test - joshkalderimis.com ssh_known_hosts: - 123.206.62.18 - code.aliyun.com - github.commatrix: include: - os: linux dist: xenial env: K=V - os: osx allow_failures: - php: master fast_finish: trueenv: global: - TZ=Asia/Shanghai matrix: - APP_ENV = pro - APP_ENV = dev - APP_ENV = staging# env:# - APP_ENV = pro# - APP_ENV = dev# - APP_ENV = stagingphp: - 5.6 - 7.0 - 7.1 - 7.2before_install: - sudo apt-get update -qq# 安装构建依赖install: - composer install -qbefore_script: # 执行构建步骤script: - env after_script: # 构建成功之后执行的步骤after_success:# 构建失败之后执行的步骤after_failure:before_cache:before_deploy:deploy:after_deploy:jobs: include: - stage: test script: - stage: deploy script:# 指定 jobs 顺序，构建条件## @see https://docs.travis-ci.com/user/conditional-builds-stages-jobs/ stages: - test - name: deploy if: tag =~ ^[0-9.]+$# blocklistbranches: except: - legacy - experimental# safelistbranches: only: - master - stable - /^deploy-.*$/ 其他错误排查Travis CI 本质就是一台云上的 Linux（虚拟机），当执行错误时从以下两方面排查问题: 注意容器运行环境已废弃，即现在的构建环境都是在虚拟机中。 路径问题(使用 $ echo $PWD 调试) 权限问题(没有执行权限 $ chmod +x filename.sh) 时区12before_install:- export TZ='Asia/Shanghai' 相关链接 官方文档]]></content>
      <categories>
        <category>CI</category>
        <category>Travis CI</category>
      </categories>
      <tags>
        <tag>CI</tag>
        <tag>Travis CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[视频下载小工具 you-get 使用详解]]></title>
    <url>%2Ftools%2Fyouget.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/soimort/you-get 安装1$ pip3 install you-get 参考链接 http://www.jianshu.com/p/a3f8df948395]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[khs1994.com GitHub 使用规范]]></title>
    <url>%2Fgit%2Fgithub%2FREADME.html</url>
    <content type="text"><![CDATA[标准化 Git 使用 国内访问在 /etc/hosts 替换 hosts https://github.com/khs1994/github-chinese 规则 .gitignore 每个项目必须有 .gitignore 严禁包含二进制大文件 PDF exec，除非该仓库专门用来存放二进制大文件。]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitHub API]]></title>
    <url>%2Fgit%2Fgithub%2Fapi.html</url>
    <content type="text"><![CDATA[本文简要介绍了 GitHub 的 API。 官方网站：https://api.github.com 官方文档：https://developer.github.com/v3/ 验证方式https://developer.github.com/v3/#authentication curl -u &quot;username&quot; https://api.github.com URL 参数 url?access_token=OAUTH-TOKEN Header 方式 Authorization: token OAUTH-TOKEN URL?client_id=xxxx&amp;client_secret=yyyy (S2S only) 举例 获取项目最新版本 https://api.github.com/repos/docker/compose/releases/latest 获取组织的项目列表 https://api.github.com/orgs/khs1994-docker/repos]]></content>
      <categories>
        <category>GitHub</category>
      </categories>
      <tags>
        <tag>GitHub</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 常见问题解决方法]]></title>
    <url>%2Flinux%2FREADME.html</url>
    <content type="text"><![CDATA[本文列举了 Linux 常见问题及其解决方法。 U 盘制作工具 https://github.com/pbatard/rufus 网页搜索软件包 查看包有哪些文件 查看文件属于哪个包 1234567$ sudo apt install apt-file$ sudo apt-file update$ apt-file search file_name$ apt-file list package_name 1$ yum whatprovides 或者在以下网站中输入 文件 或 包名 查找。 https://pkgs.org/ 包含各种系统的软件包 Alpine https://pkgs.alpinelinux.org/packages Debian https://packages.debian.org/zh-cn/ Ubuntu https://packages.ubuntu.com/zh-cn/ 软件源 https://pkgs.org/ 包含各种系统的软件包 RHEL 第三方源 REMI http://rpms.remirepo.net/ http://rpms.remirepo.net/enterprise/remi-release-7.rpm EPEL https://fedoraproject.org/wiki/EPEL/zh-cn http://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm RPM Fusion https://rpmfusion.org/ http://download1.rpmfusion.org/free/el/updates/7/x86_64/r/rpmfusion-free-release-7-1.noarch.rpm IUS https://ius.io/ https://centos7.iuscommunity.org/ius-release.rpm 设置环境变量 export 临时 /etc/profile ~/.bashrc ~/.bash_profile sudo找不到命令编辑 /etc/sudoers 文件。 12Defaults secure_path=...# 在后边加上PATH 脚本输入密码1echo "password" | sudo -S cmd sudo 重定向到文件1$ echo 1 | sudo tee 1.txt 脚本中切换用户123su - user -c "command"su - user -s /bin/bash shell.sh 相关链接 http://blog.csdn.net/wangbole/article/details/17579463]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fish Shell 安装配置]]></title>
    <url>%2Flinux%2Ffish-shell%2FREADME.html</url>
    <content type="text"><![CDATA[fish-shell GitHub：https://github.com/fish-shell/fish-shell oh-my-fish GitHub：https://github.com/oh-my-fish/oh-my-fish 两个都安装，具体编译安装查看项目 README.md 文件 配置所有配置建议在 ~/.config/fish/config.fish 中进行。以下命令中，前边加 $ 的在终端中输入命令，不加的写入配置文件中 环境变量env通过 set -x 命令设置环境变量 只对当前 shell 设定环境变量: 1$ set -x VISUAL vim 全局生效: 1$ set -Ux VISUAL vim PATH我习惯于将PATH写入配置文件中 1set -gx fish_user_paths $fish_user_paths /usr/local/sbin /usr/local/bin 别名兼容其他 Shell alias 设置方法，例如 1alias nginx="sudo nginx ; php-fpm" 使用 abbr，执行 abbr -h 查看帮助信息。 1$ abbr -a l ls -lhS 即可添加 l 为 ls -lhS 的缩写。 变量赋值 set-l -g -U -x -u 12345678910$ set -xg# Prints all global, exported variables.$ set foo hi# Sets the value of the variable $foo to be 'hi'.# 将 hi 赋值给变量 $foo$ set -e smurf# Removes the variable $smurf# 删除变量 相关链接 官方文档：http://www.fishshell.com/docs/current/index.html https://zhuanlan.zhihu.com/p/26157081]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>fish shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派 Debian 9 MySQL 实践]]></title>
    <url>%2Fraspberry-pi3%2Fmysql.html</url>
    <content type="text"><![CDATA[Debian9 使用 apt 安装 MySQL 会安装 MariaDB，下面介绍一下常用的配置方法。 密码做一次安全检查，设置 root 密码等操作。 1$ sudo /usr/bin/mysql_secure_installation 刚装好的服务端时只能用 sudo 命令登录，然后进行后续设置 1$ sudo mysql -u root -p 设置密码之后，根据测试，使用 sudo 登录 MySQL 在输密码处直接回车也能登录。 这是由于 plugin=unix_socket 造成的，使用如下命令解决该问题。 1234567891011121314$ sudo mysql -u rootUSE mysql;select plugin from user;+-------------+| plugin |+-------------+| unix_socket |+-------------+UPDATE user SET plugin='' WHERE User='root';flush privileges; 执行之后必须使用密码才能登录。 远程登录/etc/mysql/mariadb.conf.d/50-server.cnf 123[mysqld]# 将 `bind-address = 127.0.0.1` 注释 查看权限1234567SELECT host,user,password,Grant_priv,Super_priv FROM mysql.user;+-----------+------+-------------------------------------------+------------+------------+| host | user | password | Grant_priv | Super_priv |+-----------+------+-------------------------------------------+------------+------------+| localhost | root | *06EE5A234B2A56A0FD89545356F30594E36CC7EF | Y | Y |+-----------+------+-------------------------------------------+------------+------------+1 row in set (0.00 sec) 赋予完整权限123CREATE USER 'username'@'%' IDENTIFIED [ WITH mysql_native_password ] BY 'password';GRANT ALL ON *.* TO 'root'@'192.168.199.%' WITH GRANT OPTION; 我们已经创建 root 用户，并且让这个用户在 192.168.199.0/24 地址内能连接到服务器。 重启 mysql.service 服务，进行测试。 1$ sudo systemctl restart mysql mysql.service 和 mysqld.service 位于 /etc/systemd/system，均软链接到了 /lib/systemd/system/mariadb.service 相关链接 https://mariadb.com/kb/zh-cn/configuring-mariadb-for-remote-client-access/]]></content>
      <categories>
        <category>Raspberry Pi3</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Raspberry Pi3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dockerfile 最佳实践 （转载）]]></title>
    <url>%2Fdocker%2Fdockerfile.html</url>
    <content type="text"><![CDATA[本文是 Docker 官方文档中 Best practices for writing Dockerfiles 的理解和翻译。 官方修订历史 翻译：http://blog.csdn.net/candcplusplus/article/details/53366024 khs1994.com 对翻译内容进行了修改及更新。 本文包含了 Docker 官方对编写 Dockerfile 的最佳实践和建议。这些建议是为了让你写出高效易用的 Dockerfile。Docker 官方强烈建议你遵从这些建议（实际上，如果你是在创建官方镜像，你必须得遵从这些建议）。 阅读该文档需要你已经会通过 Dockerfile 构建镜像，并了解 Dockerfile 中各条指令的用途。 一般性的指南和建议容器应该是短暂的通过 Dockerfile 构建的镜像所启动的容器应该尽可能短暂（生命周期短）。「短暂」意味着可以停止和销毁容器，并且创建一个新容器并部署好所需的设置和配置工作量应该是极小的。 使用 .dockerignore 文件使用 Dockerfile 构建镜像时最好是将 Dockerfile 放置在一个新建的空目录下。然后将构建镜像所需要的文件添加到该目录中。为了提高构建镜像的效率，你可以在目录下新建一个 .dockerignore 文件来指定要忽略的文件和目录。.dockerignore 文件的排除模式语法和 Git 的 .gitignore 文件相似。 使用多阶段构建在 Docker 17.05 以上版本中，你可以使用 多阶段构建 来减少所构建镜像的大小。 避免安装不必要的包为了降低复杂性、减少依赖、减小文件大小、节约构建时间，你应该避免安装任何不必要的包。例如，不要在数据库镜像中包含一个文本编辑器。 一个容器只运行一个进程应该保证在一个容器中只运行一个进程。将多个应用解耦到不同容器中，保证了容器的横向扩展和复用。例如 web 应用应该包含三个容器：web应用、数据库、缓存。 如果容器互相依赖，你可以使用 Docker 自定义网络 来把这些容器连接起来。 镜像层数尽可能少你需要在 Dockerfile 可读性（也包括长期的可维护性）和减少层数之间做一个平衡。 将多行参数排序将多行参数按字母顺序排序（比如要安装多个包时）。这可以帮助你避免重复包含同一个包，更新包列表时也更容易。也便于 PRs 阅读和审查。建议在反斜杠符号 \ 之前添加一个空格，以增加可读性。 下面是来自 buildpack-deps 镜像的例子： 123456RUN apt-get update &amp;&amp; apt-get install -y \ bzr \ cvs \ git \ mercurial \ subversion 构建缓存在镜像的构建过程中，Docker 会遍历 Dockerfile 文件中的指令，然后按顺序执行。在执行每条指令之前，Docker 都会在缓存中查找是否已经存在可重用的镜像，如果有就使用现存的镜像，不再重复创建。如果你不想在构建过程中使用缓存，你可以在 docker build 命令中使用 --no-cache=true 选项。 但是，如果你想在构建的过程中使用缓存，你得明白什么时候会，什么时候不会找到匹配的镜像，遵循的基本规则如下： 从一个基础镜像开始（FROM 指令指定），下一条指令将和该基础镜像的所有子镜像进行匹配，检查这些子镜像被创建时使用的指令是否和被检查的指令完全一样。如果不是，则缓存失效。 在大多数情况下，只需要简单地对比 Dockerfile 中的指令和子镜像。然而，有些指令需要更多的检查和解释。 对于 ADD 和 COPY 指令，镜像中对应文件的内容也会被检查，每个文件都会计算出一个校验和。文件的最后修改时间和最后访问时间不会纳入校验。在缓存的查找过程中，会将这些校验和和已存在镜像中的文件校验和进行对比。如果文件有任何改变，比如内容和元数据，则缓存失效。 除了 ADD 和 COPY 指令，缓存匹配过程不会查看临时容器中的文件来决定缓存是否匹配。例如，当执行完 RUN apt-get -y update 指令后，容器中一些文件被更新，但 Docker 不会检查这些文件。这种情况下，只有指令字符串本身被用来匹配缓存。 一旦缓存失效，所有后续的 Dockerfile 指令都将产生新的镜像，缓存不会被使用。 Dockerfile 指令下面针对 Dockerfile 中各种指令的最佳编写方式给出建议。 FROM尽可能使用当前官方仓库作为你构建镜像的基础。推荐使用 Alpine 镜像，因为它被严格控制并保持最小尺寸（目前小于 5 mb），但它仍然是一个完整的发行版。 LABEL你可以给镜像添加标签来帮助组织镜像、记录许可信息、辅助自动化构建等。每个标签一行，由 LABEL 开头加上一个或多个标签对。下面的示例展示了各种不同的可能格式。# 开头的行是注释内容。 注意：如果你的字符串中包含空格，必须将字符串放入引号中或者对空格使用转义。如果字符串内容本身就包含引号，必须对引号使用转义。 12345678# Set one or more individual labelsLABEL com.example.version="0.0.1-beta"LABEL vendor="ACME Incorporated"LABEL com.example.release-date="2015-02-12"LABEL com.example.version.is-production="" 一个镜像可以包含多个标签，但建议将多个标签放入到一个 LABEL 指令中。 123456# Set multiple labels at once, using line-continuation characters to break long linesLABEL vendor=ACME\ Incorporated \ com.example.is-beta= \ com.example.is-production="" \ com.example.version="0.0.1-beta" \ com.example.release-date="2015-02-12" 关于标签可以接受的键值对，参考 Understanding object labels。关于查询标签信息，参考 Managing labels on objects。 RUN为了保持 Dockerfile 文件的可读性，可理解性，以及可维护性，建议将长的或复杂的 RUN 指令用反斜杠 \ 分割成多行。 apt-getRUN 指令最常见的用法是安装包用的 apt-get。因为 RUN apt-get 指令会安装包，所以有几个问题需要注意。 不要使用 RUN apt-get upgrade 或 dist-upgrade，因为许多基础镜像中的「必须」包不会在一个非特权容器中升级。如果基础镜像中的某个包过时了，你应该联系它的维护者。如果你确定某个特定的包，比如 foo，需要升级，使用 apt-get install -y foo 就行，该指令会自动升级 foo 包。 永远将 RUN apt-get update 和 apt-get install 组合成一条 RUN 声明，例如： 1234RUN apt-get update &amp;&amp; apt-get install -y \ package-bar \ package-baz \ package-foo 将 apt-get update 放在一条单独的 RUN 声明中会导致缓存问题以及后续的 apt-get install 失败。比如，假设你有一个 Dockerfile 文件： 12345FROM ubuntu:14.04RUN apt-get updateRUN apt-get install -y curl 构建镜像后，所有的层都在 Docker 的缓存中。假设你后来又修改了其中的 apt-get install 添加了一个包： 12345FROM ubuntu:14.04RUN apt-get updateRUN apt-get install -y curl nginx Docker 发现修改后的 RUN apt-get update 指令和之前的完全一样。所以，apt-get update 不会执行，而是使用之前的缓存镜像。因为 apt-get update 没有运行，后面的 apt-get install 可能安装的是过时的 curl 和 nginx 版本。 使用 RUN apt-get update &amp;&amp; apt-get install -y 可以确保你的 Dockerfiles 每次安装的都是包的最新的版本，而且这个过程不需要进一步的编码或额外干预。这项技术叫作 cache busting。你也可以显示指定一个包的版本号来达到 cache-busting，这就是所谓的固定版本，例如： 1234RUN apt-get update &amp;&amp; apt-get install -y \ package-bar \ package-baz \ package-foo=1.3.* 固定版本会迫使构建过程检索特定的版本，而不管缓存中有什么。这项技术也可以减少因所需包中未预料到的变化而导致的失败。 下面是一个 RUN 指令的示例模板，展示了所有关于 apt-get 的建议。 1234567891011121314RUN apt-get update &amp;&amp; apt-get install -y \ aufs-tools \ automake \ build-essential \ curl \ dpkg-sig \ libcap-dev \ libsqlite3-dev \ mercurial \ reprepro \ ruby1.9.1 \ ruby1.9.1-dev \ s3cmd=1.1.* \ &amp;&amp; rm -rf /var/lib/apt/lists/* 其中 s3cmd 指令指定了一个版本号 1.1.*。如果之前的镜像使用的是更旧的版本，指定新的版本会导致 apt-get udpate 缓存失效并确保安装的是新版本。 另外，清理掉 apt 缓存 var/lib/apt/lists 可以减小镜像大小。因为 RUN 指令的开头为 apt-get udpate，包缓存总是会在 apt-get install 之前刷新。 注意：官方的 Debian 和 Ubuntu 镜像会自动运行 apt-get clean，所以不需要显式的调用 apt-get clean。 CMDCMD 指令用于执行目标镜像中包含的软件，可以包含参数。CMD 大多数情况下都应该以 CMD [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;...] 的形式使用。因此，如果创建镜像的目的是为了部署某个服务(比如 Apache)，你可能会执行类似于 CMD [&quot;apache2&quot;, &quot;-DFOREGROUND&quot;] 形式的命令。我们建议任何服务镜像都使用这种形式的命令。 多数情况下，CMD 都需要一个交互式的 shell (bash, Python, perl 等)，例如 CMD [&quot;perl&quot;, &quot;-de0&quot;]，或者 CMD [&quot;PHP&quot;, &quot;-a&quot;]。使用这种形式意味着，当你执行类似 docker run -it python 时，你会进入一个准备好的 shell 中。CMD 应该在极少的情况下才能以 CMD [&quot;param&quot;, &quot;param&quot;] 的形式与 ENTRYPOINT 协同使用，除非你和你的镜像使用者都对 ENTRYPOINT 的工作方式十分熟悉。 EXPOSEEXPOSE 指令用于指定容器将要监听的端口。因此，你应该为你的应用程序使用常见的端口。例如，提供 Apache web 服务的镜像应该使用 EXPOSE 80，而提供 MongoDB 服务的镜像使用 EXPOSE 27017。 对于外部访问，用户可以在执行 docker run 时使用一个标志来指示如何将指定的端口映射到所选择的端口。 ENV为了方便新程序运行，你可以使用 ENV 来为容器中安装的程序更新 PATH 环境变量。例如使用 ENV PATH /usr/local/nginx/bin:$PATH 来确保 CMD [&quot;nginx&quot;] 能正确运行。 ENV 指令也可用于为你想要容器化的服务提供必要的环境变量，比如 Postgres 需要的 PGDATA。 最后，ENV 也能用于设置常见的版本号，比如下面的示例： 1234567ENV PG_MAJOR 9.3ENV PG_VERSION 9.3.4RUN curl -SL http://example.com/postgres-$PG_VERSION.tar.xz | tar -xJC /usr/src/postgress &amp;&amp; …ENV PATH /usr/local/postgres-$PG_MAJOR/bin:$PATH 类似于程序中的常量，这种方法可以让你只需改变 ENV 指令来自动的改变容器中的软件版本。 ADD 和 COPY虽然 ADD 和 COPY 功能类似，但一般优先使用 COPY。因为它比 ADD 更透明。COPY 只支持简单将本地文件拷贝到容器中，而 ADD 有一些并不明显的功能（比如本地 tar 提取和远程 URL 支持）。因此，ADD 的最佳用例是将本地 tar 文件自动提取到镜像中，例如 ADD rootfs.tar.xz。 如果你的 Dockerfile 有多个步骤需要使用上下文中不同的文件。单独 COPY 每个文件，而不是一次性的 COPY 所有文件，这将保证每个步骤的构建缓存只在特定的文件变化时失效。例如： 12345COPY requirements.txt /tmp/RUN pip install --requirement /tmp/requirements.txtCOPY . /tmp/ 如果将 COPY . /tmp/ 放置在 RUN 指令之前，只要 . 目录中任何一个文件变化，都会导致后续指令的缓存失效。 为了让镜像尽量小，最好不要使用 ADD 指令从远程 URL 获取包，而是使用 curl 和 wget。这样你可以在文件提取完之后删掉不再需要的文件来避免在镜像中额外添加一层。比如尽量避免下面的用法： 12345ADD http://example.com/big.tar.xz /usr/src/things/RUN tar -xJf /usr/src/things/big.tar.xz -C /usr/src/thingsRUN make -C /usr/src/things all 而是应该使用下面这种方法： 1234RUN mkdir -p /usr/src/things \ &amp;&amp; curl -SL http://example.com/big.tar.xz \ | tar -xJC /usr/src/things \ &amp;&amp; make -C /usr/src/things all 上面使用的管道操作，所以没有中间文件需要删除。 对于其他不需要 ADD 的自动提取功能的文件或目录，你应该使用 COPY。 ENTRYPOINTENTRYPOINT 的最佳用处是设置镜像的主命令，允许将镜像当成命令本身来运行（用 CMD 提供默认选项）。 例如，下面的示例镜像提供了命令行工具 s3cmd: 123ENTRYPOINT ["s3cmd"]CMD ["--help"] 现在直接运行该镜像创建的容器会显示命令帮助： 1$ docker run s3cmd 或者提供正确的参数来执行某个命令： 1$ docker run s3cmd ls s3://mybucket 这样镜像名可以当成命令行的参考。 ENTRYPOINT 指令也可以结合一个辅助脚本使用，和前面命令行风格类似，即使启动工具需要不止一个步骤。 例如，Postgres 官方镜像使用下面的脚本作为 ENTRYPOINT： 1234567891011121314#!/bin/bashset -eif [ "$1" = 'postgres' ]; then chown -R postgres "$PGDATA" if [ -z "$(ls -A "$PGDATA")" ]; then gosu postgres initdb fi exec gosu postgres "$@"fiexec "$@" 注意：该脚本使用了 Bash 的内置命令 exec，所以最后运行的进程就是容器的 PID 为 1 的进程。这样，进程就可以接收到任何发送给容器的 Unix 信号了。 该辅助脚本被拷贝到容器，并在容器启动时通过 ENTRYPOINT 执行： 123COPY ./docker-entrypoint.sh /ENTRYPOINT ["/docker-entrypoint.sh"] 该脚本可以让用户用几种不同的方式和 Postgres 交互。 你可以很简单地启动 Postgres： 1$ docker run postgres 也可以执行 Postgres 并传递参数： 1$ docker run postgres postgres --help 最后，你还可以启动另外一个完全不同的工具，比如 Bash： 1$ docker run --rm -it postgres bash VOLUMEVOLUME 指令用于暴露任何数据库存储文件，配置文件，或容器创建的文件和目录。强烈建议使用 VOLUME 来管理镜像中的可变部分和用户可以改变的部分。 USER如果某个服务不需要特权执行，建议使用 USER 指令切换到非 root 用户。先在 Dockerfile 中使用类似 RUN groupadd -r postgres &amp;&amp; useradd -r -g postgres postgres 的指令创建用户和用户组。 注意：在镜像中，用户和用户组每次被分配的 UID/GID 都是不确定的，下次重新构建镜像时被分配到的 UID/GID 可能会不一样。如果要依赖确定的 UID/GID，你应该显示的指定一个 UID/GID。 你应该避免使用 sudo，因为它不可预期的 TTY 和信号转发行为可能造成的问题比它能解决的问题还多。如果你真的需要和 sudo 类似的功能（例如，以 root 权限初始化某个守护进程，以非 root 权限执行它），你可以使用 gosu。 最后，为了减少层数和复杂度，避免频繁地使用 USER 来回切换用户。 WORKDIR为了清晰性和可靠性，你应该总是在 WORKDIR 中使用绝对路径。另外，你应该使用 WORKDIR 来替代类似于 RUN cd ... &amp;&amp; do-something 的指令，后者难以阅读、排错和维护。 官方仓库示例这些官方仓库的 Dockerfile 都是参考典范：https://github.com/docker-library/docs]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker Machine 使用详解]]></title>
    <url>%2Fdocker%2Fmachine.html</url>
    <content type="text"><![CDATA[Automate container provisioning on your network or in the cloud. Available for Windows, macOS, or Linux. GitHub: https://github.com/docker/machine 命名为 default 创建使用官方支持的 virtualbox 驱动。 1234567$ docker-machine create \ --driver virtualbox \ --engine-opt dns=114.114.114.114 \ --engine-registry-mirror https://registry.docker-cn.com \ --virtualbox-memory 2048 \ --virtualbox-cpu-count 2 \ default Windows Hyperv1234567$ docker-machine create ` -d hyperv ` --engine-registry-mirror https://registry.docker-cn.com ` --hyperv-memory &quot;2048&quot; ` --hyperv-cpu-count &quot;2&quot; ` --hyperv-virtual-switch zy ` default --hyperv-virtual-switch macOS xhyve使用第三方驱动 xhyve GitHub: https://github.com/zchee/docker-machine-driver-xhyve 123456789101112$ brew install docker-machine-driver-xhyve$ docker-machine create \ -d xhyve \ # 不指定这一项的话，每次启动都会从 github 下载 iso --xhyve-boot2docker-url ~/.docker/machine/cache/boot2docker.iso \ --engine-opt dns=114.114.114.114 \ --engine-registry-mirror https://registry.docker-cn.com \ --xhyve-memory-size 2048 \ --xhyve-rawdisk \ --xhyve-cpu-count 2 \ xhyve 列出12345$ docker-machine lsNAME ACTIVE DRIVER STATE URL SWARM DOCKER ERRORSdefault - virtualbox Running tcp://192.168.99.100:2376 v17.10.0-cexhyve - xhyve Running tcp://192.168.64.2:2376 v17.10.0-ce 进入123456$ docker-machine env default$ eval "$(docker-machine env default)"$ docker run -d -p 8000:80 nginx$ curl $(docker-machine ip default):8000# 如果此时想操作本地的 Docker ,先退出终端重新打开一个新的终端。 通过 SSH 进入123$ docker-machine ssh default$ docker@default:~$ docker info]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 正则表达式]]></title>
    <url>%2Fphp%2Fbasic%2Fpreg%2FREADME.html</url>
    <content type="text"><![CDATA[本文主要介绍了 PHP 正则表达式相关的函数。 官方文档：http://php.net/manual/zh/ref.pcre.php 表单验证123int preg_match($pattern, $subject, [ array &amp;$matches ])int preg_match_all($pattern, $subject, array &amp;$matches) 返回匹配到结果的次数，结果放到第三个参数的数组中。 搜索替换 词语过滤123preg_replace($pattern, $replacement, $subject)preg_filter($pattern, $replacement, $subject) // 只保留发生替换的字符串 1preg_grep($pattern, array $input) // 阉割版 preg_filter，只返回匹配到的值 1preg_split($pattern, $subject) // 升级版的 explode 1preg_quote($str) // 转义 基本概念 界定符 /正则表达式/ 原子 量词 边界控制 模式单元]]></content>
      <categories>
        <category>PHP</category>
        <category>Preg</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Preg</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP PDO MySQL]]></title>
    <url>%2Fphp%2Fbasic%2Fpdo%2Fmysql%2FREADME.html</url>
    <content type="text"><![CDATA[连接 1234567891011// 数据源$dsn='mysql:host=localhost;dbname=imooc;port=3306';// uri 形式$dsn='uri:file://G:\path'$pdo=new PDO($dsn,$username,$password);var_dump($pdo); exec() 对于 select 没有作用。 执行一条 SQL 语句，并返回其受影响的行数。 可用于 创建表 数据库 插入记录 更新 删除 123456789101112131415161718192021$query=&lt;&lt;&lt;EOF CREATE TABLE IF NOT EXISTS tablename(...)EOF;$res=$pdo-&gt;exec($query);// 最后插入记录的 ID 号$id=$pdo-&gt;lastInsertId();var_dump($res);var_dump($id);// 获取错误信息$pdo-&gt;errorCode(); // string$pdo-&gt;errorInfo(); // array// 使用 try-catch 捕获 PDOException query() 查询，执行一条 SQL 语句，返回一个 PDOStatement 对象 查询 插入 12345$sql='select * from tablename';$stmt=$pdo-&gt;query($sql);// 之后通过遍历数组，获取结果 prepare() PDOStatement::execute() prepare() 准备要执行的 SQL 语句，返回 PDOStatement 对象 PDOStatement::execute() 通过调用该方法处理预处理过的语句 123456789101112131415$stmt=$pdo-&gt;prepare($sql);$stmt-&gt;execute(); // 返回布尔类型$stmt-&gt;fetch(); // 默认返回关联 + 索引数组，得到结果集中一条记录// 可以在 fetch 时设置返回形式，只返回关联数组，失败返回 false$stmt-&gt;fetchAll(PDO::FETCH_ASSOC); // PDO::FETCH_NUM PDO::FETCH_BOTH// 也可以先设置返回形式，再 fetch。和上一种方法二选一$stmt-&gt;setFetchMode(PDO::FETCH_ASSOC);$stmt-&gt;fetchAll(); // 二维数组，返回所有数据，失败返回 false setAttribute() getAttribute() 设置，得到数据库连接属性 12345$pdo-&gt;getAttribute($attribute);$pdo-&gt;setAttribute($attribute, $value);// PDO::ATTR_ERRMODE PDO::ERRMODE_EXCEPTION | ERRMODE_SILENT(default) | ERRMODE_WARNING quote() 返回带引号的字符串，防止 SQL 注入 1$pdo-&gt;quote($usernmae); rowCount() select 操作，返回结果集中记录的条数 insert update delete 操作，返回受影响的记录的条数 1$stmt-&gt;rowCount(); 预处理语句中的占位符 也可以防止 SQL 注入 12345678910111213$sql='select * from tablename where username=:username';// 通过 ? 占位$sql='select * from tablename where username=?';$stmt=$pdo-&gt;prepare($sql); // 返回 PDOStatement 对象$stmt-&gt;execute([':username'=&gt;$usernmae]); // 调用的是 PDOStatement 对象的 execute 方法// ? 占位$stmt=execute([$username]); 绑定参数到指定的变量bindParam() 1234567891011121314// :var 占位$username='usernmae';$stmt-&gt;bindParam(':username',$username); // 第二个参数不能是具体的值，第二个参数是引用类型$username='usernmae2'; // 实际值为 username2$stmt-&gt;execute();// ? 占位，索引从 1 开始$stmt-&gt;bindParam(1,$username);$stmt-&gt;execute(); 把一个值绑定到参数bindValue() 1234567891011$username='username';// :var 占位$stmt-&gt;bindValue(':var',$username); // 第二个参数可以是具体的值$username='username2'; // 实际值为 username// ? 占位$stmt-&gt;bindValue(1,$username); 注意以上两者的区别 第二个参数是否为引用变量 绑定结果中的一列到一个 PHP 变量bindColumn() 1234567$stmt-&gt;execute();$stmt-&gt;bindColumn(1,$username);while ($stmt-&gt;fetch(PDO::FETCH_BOUND)) &#123; echo 'username:'.$username;&#125; 其他 columnCount() 返回结果集的列数 getColumnMeta() 返回结果集中一列的元数据，索引从 0 开始 fetchColumn() 从结果集中返回一列，索引从 0 开始 debugDumpParams() 打印预处理语句 nextRowset() 将结果集中的指针下移]]></content>
      <categories>
        <category>PHP</category>
        <category>PDO</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
        <tag>PDO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 数据库抽象层 PDO]]></title>
    <url>%2Fphp%2Fbasic%2Fpdo%2FREADME.html</url>
    <content type="text"><![CDATA[统一各种数据库的访问。 支持的数据库，只列出常用的 PDO_MYSQL PDO_PGSQL PDO_SQLITE 其他请查看这里 http://php.net/manual/en/pdo.drivers.php https://pecl.php.net/package-search.php?pkg_name=pdo&amp;bool=AND&amp;submit=Search]]></content>
      <categories>
        <category>PHP</category>
        <category>PDO</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PDO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RESTful API 设计详解]]></title>
    <url>%2Fphp%2Frestful%2FREADME.html</url>
    <content type="text"><![CDATA[RESTful 是一种软件架构风格，其面向资源。基于 HTTP 协议实现。 慕课网：http://www.imooc.com/learn/811 设计概念和准则 所有事物都可以被抽象为资源。 每一个资源都有唯一的资源标识，对资源的操作不会改变这些标识。 所有操作都是无状态的。 请求方法 get 获取 =》查(SELECT) post 附加新的资源 (新建) =》增 (CREATE) put 请求服务器存储一个资源，并用 REQUEST-URI 作为其标识 更新 =》改 (UPDATE) 改全部信息 patch 在服务器更新资源（客户端提供改变的属性）更新 =&gt; 改 (UPDATE) 改部分信息 delete 请求服务器删除 REQUEST-URI 所标识的资源 =》删 (DELETE) head 请求获取由 REQUEST-URI 所标识的资源的响应信息报头 options 请求查询服务器的性能，或者查询与资源相关的选项与需求 常用状态码 200 OK 400 Bad Request 客户端请求有语法错误，不能被服务器理解 401 Unauthorized 服务器受到请求，但拒绝提供服务 404 Not Found 500 Internal Server Error 服务器不可预期的错误 503 Server Unavailable 服务器当前不能处理客户端的请求 设计要素资源路径 URI每个网址代表一种资源，网址中不能有动词（待商榷），只能是名词，名词应该是复数 HTTP 动词get、post, etc 过滤信息url?offset=10 指定返回记录的开始位置 url?limit=10 指定返回记录的数量 url?page=2&amp;per_page=100 指定第几页，以及每页的记录数。 url?sortby=name&amp;order=asc 指定返回结果按照哪个属性排序，以及排序顺序。 url?animal_type_id=1 指定筛选条件 状态码错误处理123&#123; "error": "错误信息"&#125; 123&#123; "message": "message"&#125; 返回结果More Information http://www.ruanyifeng.com/blog/2011/09/restful.html http://www.ruanyifeng.com/blog/2014/05/restful_api.html https://www.zhihu.com/question/28557115]]></content>
      <categories>
        <category>PHP</category>
        <category>RESTful</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 数据库操作]]></title>
    <url>%2Fphp%2Fframework%2Flaravel%2Fdatabase%2FREADME.html</url>
    <content type="text"><![CDATA[可以使用 原生 SQL 查询构造器 Eloquent ORM。 原生 SQL同原始 PDO 一样支持两种绑定参数的方式。 插入 insert使用 ? 绑定参数 1DB::insert('insert tb1 values(?,?,?)',[null,'tom',10]); 返回布尔值 使用 :var 绑定参数 12345DB::insert('insert tb1 values(:id,:username,:age)',[ 'id'=&gt;null, 'username'=&gt;'tom', 'age'=&gt;10]); 查询 select123DB::select('select * from tb1 where id = :id',[ 'id'=&gt;1]); 返回一个数组结果集，数组中的每个结果将是一个 PHP stdClass 对象。 更新 update1DB::update('update tb1 set name=? where id = ?',['khs1994',1]); 返回所影响的行数 删除 delete1DB::delete('delete from tb1'); 返回所影响的行数 statement 适用于没有返回值的 SQL 语句。 1DB::statement('drop table tb1'); 数据库请求构造器获取所有数据列 get1DB::table('tb1')-&gt;get(); 返回一个 Illuminate\Support\Collection 结果，其中每个结果都是一个 PHP StdClass 对象的实例 获取单列或单行获取一行数据，使用 first 方法。 123DB::table('tb1') -&gt;where('name','John') -&gt;first(); 取出一行中的单个值。 12345DB::table('tb1') -&gt;where('name','John') -&gt;where('name','like','J%') -&gt;where('age','=',10) -&gt;value('age') 获取一列值。 12DB::table('tb1') -&gt;pluck('title') 结果分块 chunk12345DB::table('tb1')-&gt;orderBy('id')-&gt;chunk(100,function($users)&#123; foreach ($users as $k)&#123; &#125;&#125;) 聚合函数123456DB::table('tb1') -&gt;count() -&gt;min('price') -&gt;max('price') -&gt;avg('price') -&gt;sum('price') select1234DB::table('tb1') -&gt;select('name','user_email as email') -&gt;distinct() // 去掉重复结果 -&gt;get(); 也可以在已有的查询构造器实例上调用 addselect(&#39;age&#39;)。]]></content>
      <categories>
        <category>PHP</category>
        <category>Framework</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 创建数据库]]></title>
    <url>%2Fphp%2Fframework%2Flaravel%2Fdatabase%2Fcreate.html</url>
    <content type="text"><![CDATA[使用数据库迁移创建数据库。 1$ php artisan make:migration create_name_table 新的迁移文件会被放置在 database/migrations 目录中。 在 up 方法中修改表结构。 迁移命令 1$ php artisan migrate 回滚迁移 1$ php artisan migrate:rollback]]></content>
      <categories>
        <category>PHP</category>
        <category>Framework</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhpStorm Xdebug 使用详解]]></title>
    <url>%2Fphp%2Fdevelopment%2Fxdebug.html</url>
    <content type="text"><![CDATA[场景 LNMP 位于 本机 LNMP 位于 Docker 或 WSL LNMP 位于虚拟机（远程） LNMP 位于虚拟机中的 Docker php xdebug 扩展安装1234567# php 也是通过 brew 安装的，已安装的请跳过$ brew install php$ pecl install xdebug# 可能需要修改配置文件来增加扩展，这里不再赘述 配置/usr/local/etc/php/7.2/conf.d/ext-xdebug.ini 注意请替换为实际的路径 123456789101112[xdebug]# 或者填绝对路径zend_extension="xdebug.so"xdebug.remote_enable=1#xdebug.remote_host=local004.khs1994.comxdebug.remote_connect_back=1xdebug.remote_port=9010xdebug.remote_log=/tmp/xdebug-remote.logxdebug.remote_handler=dbgp 浏览器插件Chrome 插件https://github.com/mac-cain13/xdebug-helper-for-chrome 在选项中选择 PhpStrom FireFox 插件https://github.com/BrianGilbert/xdebug-helper-for-firefox 在选项中选择 PhpStrom PhpStrom 配置 File -&gt; Settings -&gt; Languages&amp;Frameworks -&gt; PHP -&gt; Debug -&gt;Xdebug Debug port: 9010 三个选项全部勾选（必须与扩展中配置的端口一致）。 使用 设置断点 点击 电话 图标(run -&gt; Start listening for PHP…) 浏览器打开网址，点击 xdebug helper -》debug ,自动跳转到 IDE 相关链接 http://blog.csdn.net/willcold/article/details/68068090 https://segmentfault.com/a/1190000005878593 http://blog.csdn.net/u012914309/article/details/65440609]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS PhpStorm Docker 使用详解]]></title>
    <url>%2Fphp%2Fdevelopment%2Fphpstorm-docker.html</url>
    <content type="text"><![CDATA[在 PhpStorm | Preferences | Build, Execution, Deployment | Docker 设置 Docker。 项目根目录编写 Dockerfile 或 docker-compose.yml 点击 Run | Edit configurations 中添加 Docker Deployment 在 Deployment 选择 image 或者 Dockerfile 或者 docker-compose.yml 在 Container 设置运行命令、挂载数据、端口号等。 相关链接 https://www.jetbrains.com/help/phpstorm/docker-2.html?search=docker https://confluence.jetbrains.com/display/PhpStorm/Docker+Support+in+PhpStorm]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 环境变量]]></title>
    <url>%2Fphp%2Fframework%2Flaravel%2Fenv.html</url>
    <content type="text"><![CDATA[不同环境加载不同的 .env 文件。 开发: development 测试: testing （运行 PHPUnit 使用 .env.testing 文件） 预上线: staging 正式环境: production 生产环境加载 .env.production 以此类推 设置系统环境变量/etc/profile 文件末尾写入以下内容 123export APP_ENV=development# export APP_ENV=production Windows 不再赘述。 验证123$ php artisan envCurrent application environment: development 与上一步系统变量一致说明设置成功，Windows 设置系统变量之后记得注销再登陆。 More Information https://laravel-china.org/articles/5638/laravel-env-the-loading-of-environment-variables-and-source-code-analysis https://segmentfault.com/a/1190000009682704]]></content>
      <categories>
        <category>PHP</category>
        <category>Framework</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PhpStorm 配置 Laravel 智能提示]]></title>
    <url>%2Fphp%2Fframework%2Flaravel%2Fide.html</url>
    <content type="text"><![CDATA[本文介绍了 PhpStorm 下的 Laravel 智能提示。 配置 composer设置中搜索 composer 进行设置 安装 laravel-ide-helperGitHub：https://github.com/barryvdh/laravel-ide-helper 仅在开发环境中使用 1$ composer require --dev barryvdh/laravel-ide-helper 在 app/Providers/AppServiceProvider.php 中添加如下内容 1234567public function register()&#123; if ($this-&gt;app-&gt;environment() !== 'production') &#123; $this-&gt;app-&gt;register(\Barryvdh\LaravelIdeHelper\IdeHelperServiceProvider::class); &#125; // ...&#125; 通过命令行生成 _ide_helper.php 文件 123$ php artisan ide-helper:generate$ php artisan ide-helper:meta$ php artisan optimize 在 .gitignore 中添加如下内容 12.phpstorm.meta.php_ide_helper.php 插件Laravel Plugin IDE 中搜索 Laravel，在插件配置中手动勾选两个配置]]></content>
      <categories>
        <category>PHP</category>
        <category>Framework</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel 5 框架基础配置]]></title>
    <url>%2Fphp%2Fframework%2Flaravel%2FREADME.html</url>
    <content type="text"><![CDATA[本文介绍了 Laravle 5 的安装及简要的使用方法。 服务容器 服务提供者自定义的类，不是基于接口而且构造函数没有带参数的情况下可以不用绑定到容器，在解析的时候会自动反射出来的 生产环境优化123$ php artisan config:cache # 配置缓存$ php artisan route:cache # 路由缓存$ php artisan down | up # 启用或关闭维护模式 安装123$ composer global require "laravel/installer"$ laravel new blog // laravel 命令只能安装主线版本 安装特定版本1$ composer create-project --prefer-dist laravel/laravel=5.5.* blog 密钥一般情况下安装程序会自动设置好，如果提示错误，请执行以下命令： 1$ php artisan key:generate phpredis (pecl)config/database.php 1234567'redis' =&gt; [ //'client' =&gt; 'predis', 'client' =&gt; 'phpredis', ...] 禁用 CSRF 保护app\Http\Kernel.php 注释掉以下几行。 1App\Http\Middleware\VerifyCsrfToken 其他在 ./config/app.php 中 aliases 过的类，直接 use 类名，不要 use 完整路径。 123use App; // 推荐use Illuminate\Support\Facades\App; // 不推荐 辅助函数通过使用函数实现功能 1234567cache(['key'=&gt;1], 5); // 在数组中设置值cache('ket'); // 获取值session(['key'=&gt;1]); // 设置值session('key'); Facades通过调用类的静态方法实现功能。 12345Cache::set('key', 'value', 5);Cache::get('key');Session::all(); Contracts 契约路由123456789101112131415161718192021222324252627282930313233Route::get();Route::match(['get'],)Route::redirect(); // 重定向Route::view(); // 返回视图Route::get('/user/&#123;name&#125;/id/&#123;id&#125;',) // url 参数Route::get('/id/&#123;id?&#125;',function($id)&#123; return $id;&#125;); // url 参数的Route::get()-&gt;name('name'); // 路由命名Route::get()-&gt;where(); // 正则表达式约束路由参数Route::domain('sub.domain.com')-&gt;group(function()&#123;&#125;); // 子域名Route::prefix('sub')-&gt;group(function()&#123;&#125;); // 路由前缀Route::namespace('Admin')-&gt;group(function()&#123; // 在 "App\Http\Controllers\Admin" 命名空间下的控制器&#125;);Route::middleware()-&gt;group(function()&#123; // 中间件&#125;); 中间件app\Http\Middleware 123456789101112131415161718// 新建中间件类public function handle($request, Closure $next)&#123; // 前置中间件 // 执行动作 return $next($request); // 后置中间件 $response = next($request); // 执行动作 return $response;&#125; 注册中间件app\Http\Kernel 123protected $middleware =[ // 在这里增加一个条目]; 控制器__invoke 魔术方法来定义单个控制器。 123456789101112public function __construct()&#123; $this-&gt;middleware('auth') -&gt;only('method') -&gt;except('method'); $this-&gt;middleware(function($request, Closure $next)&#123; // code return $next($request); &#125;);&#125; 响应123456789101112131415161718192021222324252627$response($content) -&gt;header('Content-Type',$type) -&gt;withHeaders([ // 数组形式 'Content-Type'=&gt;$type ]); -&gt;cookie('key','value','过期时间'); // 参数与原生参数相同 -&gt;view(); // 响应视图 -&gt;json([ // 响应 json,直接 return [] 默认返回 json ]); -&gt;download($filePath); // 强制用户下载指定路径的文件 -&gt;file($filePath); // 浏览器显示文件（不下载），例如图片、PDF// 重定向redirect('routeName') -&gt;with() // 数据闪存到 session 中 -&gt;action('name',[ // 参数 ]); // 重定向到 控制器 -&gt;route('routeName'); // 重定向到路由 日志12345678Log::emergency($message);Log::alert($message);Log::critical($message);Log::error($message);Log::warning($message);Log::notice($message);Log::info($message);Log::debug($message); 文件1234567$request-&gt;file('photo'); // -&gt;photo; 也可以直接通过文件名调用 -&gt;hasFile('photo'); // 请求是否包含某文件 -&gt;isValid(); // 验证文件是否有效 -&gt;path(); // 文件路径 -&gt;extension(); // 文件扩展名 -&gt;store('images'); // 目录名，文件名会自动生成 -&gt;storeAs('images', 'filename.jpg'); // 指定目录及文件名 Session123456789101112131415161718192021Illuminate\Http\Request 实例-&gt;session()-&gt;get(); // 获取 -&gt;put(); // 新增 -&gt;forget(); // 删除 -&gt;flush(); // 清空 -&gt;pull(); // 取值之后删除 -&gt;flash(); // 闪存// 辅助函数session();// 辅助函数新增值session(['key'=&gt;1]) Cookie123456789101112131415Illuminate\Http\Request 实例-&gt;cookie('key'); // 获取 cookie// 辅助函数设置 cookie，生成的是 cookie 实例，之后附加到响应。$a=cookie(); // 与 PHP 原生 setcookie() 参数一致return response()-&gt;cookie($a);// 响应时设置 cookiereturn response()-&gt;cookie( 'name', 1 , 100); 文件系统建立链接 storage/app/public -&gt; public/storage 1$ php artisan storage:link 123456789101112131415Storage::disk('local')-&gt;// 默认路径为 storage/app ::put('public/1.txt', 1); // 写入文件 ::get('public/1.txt'); ::exists('public/1.txt'); ::url('public/1.txt');// 生成文件访问链接asset('storage/1.txt'); 邮件1$ php artisan make:mail MailClass 在 build 方法中完成邮件的配置 123Mail::to()-&gt;send(new MailClass); -&gt;queue(new QueueClass()) 消息通知1$ php artisan make:notification NotificationClass 12345678class DemoClass&#123; use Notifiable;&#125;$demoClass-&gt;notify(new NotificationClass());Notification::send($users, new InvoicePaid($invoice)); 事件事件（Events） 监听器（Listeners） 例如一个 用户注册事件 可以对应 邮件 短信 等监听器 控制器中调用一个事件 event(new MyEvents()); 将 事件 与 监听器 注册 EventServiceProvider $listeners=[‘事件’=&gt;[‘监听器’，’监听器2’]] 监听器接收 事件 示例 进行逻辑处理 监听器可以放入队列中]]></content>
      <categories>
        <category>PHP</category>
        <category>Framework</category>
        <category>Laravel</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ThinkPHP 5]]></title>
    <url>%2Fphp%2Fframework%2Fthinkphp%2FREADME.html</url>
    <content type="text"></content>
      <categories>
        <category>PHP</category>
        <category>Framework</category>
        <category>ThinkPHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>ThinkPHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派 3 常用设置]]></title>
    <url>%2Fraspberry-pi3%2FREADME.html</url>
    <content type="text"><![CDATA[本文简要介绍了 树莓派 3 的常用设置。 SSH 登录TF 卡 boot 新建一个名为 ssh 的空白文件。 官方的 Raspbian 系统默认的登录帐号：pi 密码：raspberry 常用配置换源编辑 /etc/apt/source.list 文件 用 # 注释存在的内容 Debian 912deb http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpideb-src http://mirrors.aliyun.com/raspbian/raspbian/ stretch main contrib non-free rpi Debian 812deb http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free rpideb-src http://mirrors.aliyun.com/raspbian/raspbian/ jessie main contrib non-free rpi 改时区1$ dpkg-reconfigure tzdata 网络配置DNS编辑 /etc/resolvconf.conf 文件 12# configure your subscribers configuration files below.name_servers=127.0.0.1 静态 IP 注意：修改 /etc/network/interfaces 的方法已经过时 编辑 /etc/dhcpcd.conf 文件 1234567891011interface eth0static ip_address=192.168.0.10/24static routers=192.168.0.1static domain_name_servers=192.168.0.1interface wlan0static ip_address=192.168.0.200/24static routers=192.168.0.1static domain_name_servers=192.168.0.1 ShellFish ShellGitHub：https://github.com/fish-shell/fish-shell 1234$ autoreconf --no-recursive$ ./configure$ make$ sudo make install 软件Sambahttp://shumeipai.nxez.com/2013/08/24/install-nas-on-raspberrypi.html LNMPPython、pipNode.js、npm硬件SPI使用以下命令开启 SPI 1$ sudo raspi-config WiFi编辑 /etc/wpa_supplicant/wpa_supplicant.conf 文件 12345678910111213country=GBctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdevupdate_config=1#network=&#123;# ssid="WIFINAME"# psk="password"#&#125;network=&#123; ssid="CMCC.." psk="000000000"&#125; 相关链接 http://www.cnblogs.com/taojintianxia/p/6026225.html http://www.landzo.cn/thread-12826-1-1.html]]></content>
      <categories>
        <category>Raspberry Pi3</category>
      </categories>
      <tags>
        <tag>Raspberry Pi3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树莓派 3 内核交叉编译详解]]></title>
    <url>%2Fraspberry-pi3%2Fbuild-kernel.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/khs1994/kernel 编译环境 Ubuntu 18.04 server 64 位(使用 VirtuaiBox 虚拟机)，本次编译专门针对 树莓派 3，可能不适用于前代产品！ 目录说明：本次编译目录位于 ~/pi，请提前创建好该文件夹。 arm64 来源：https://github.com/bamarni/pi64 准备安装包arm32v7 （官方系统）1234567891011$ sudo apt install \ make \ libncurses5-dev \ gcc-arm-linux-gnueabihf \ g++-arm-linux-gnueabihf# 32 位库，不安装会提示 gcc 编译器提示 找不到文件$ sudo apt install \ lib32ncurses5 \ lib32z1 arm64v812345678910111213141516$ sudo apt-get update \ &amp;&amp; sudo apt-get -y install \ bc \ build-essential \ cmake \ device-tree-compiler \ gcc-aarch64-linux-gnu \ g++-aarch64-linux-gnu \ git \ unzip \ qemu-user-static \ multistrap \ zip \ wget \ dosfstools \ kpartx 克隆资源https://github.com/raspberrypi 在 ~/pi 目录执行以下命令 firmware 树莓派的交叉编译好的二进制内核、模块、库、bootloader 1$ git clone --depth=1 git@github.com:raspberrypi/firmware.git linux 内核源码 1$ git clone -b rpi-4.13.y --depth=1 git@github.com:raspberrypi/linux.git linux-src 编译准备 .config在 linux-src 目录执行以下命令。 arm32v7使用以下两种方法之一，在 linux-src 文件夹下生成 .config。 使用命令生成1$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- bcm2709_defconfig 使用图形化界面进行配置有特殊需求再自行配置，一般使用第一种方法即可。 1$ make ARCH=arm CROSS_COMPILE=arm-linux-gnueabihf- menuconfig arm64v812345$ wget https://raw.githubusercontent.com/bamarni/pi64/master/make/kernel-config.txt$ mv kernel-config.txt .config$ make ARCH=arm64 CROSS_COMPILE=aarch64-linux-gnu- olddefconfig 编译arm32v71$ make ARCH=arm -j $(nproc) CROSS_COMPILE=arm-linux-gnueabihf- arm64v81$ make ARCH=arm64 -j $(nproc) CROSS_COMPILE=aarch64-linux-gnu- 复制 kernel在 linux-src 目录执行以下命令。 arm32v7123$ mkdir -p ../linux/boot$ cp arch/arm/boot/Image ../linux/boot/kernel7.img 注意: kernel.img 是树莓派 1 用的，二代以后 cpu 是 arm v7 架构，内核名字被配置成了 kernel7.img ！ arm64v8123$ mkdir -p ../linux/boot$ cp arch/arm64/boot/Image ../linux/boot/kernel8.img 提取 modules上一步不但编译出来了内核的源码，一些模块文件也编译出来了，这里我们提取一下（新的 Kernel 要正确运行，还需要编译所需的 modules，主要对应 /lib 目录下的内容）。 编译时，使用 INSTALL_MOD_PATH 参数指定目标路径。 在 linux-src 目录执行以下命令。 arm32v7123$ make ARCH=arm \ CROSS_COMPILE=arm-linux-gnueabihf- \ INSTALL_MOD_PATH=../linux modules_install arm64v8123$ make ARCH=arm64 \ CROSS_COMPILE=aarch64-linux-gnu- \ INSTALL_MOD_PATH=../linux modules_install 提取 firmware在 ~/pi 目录执行以下命令。 12345$ cd firmware/boot$ rm -rf *.dtb *.img$ cp -a * ../../linux/boot 打包由于编译环境位于虚拟机，把文件压缩之后，本机使用 scp 将压缩包拿回来。 1$ tar -zcvf linux.tar.gz linux 将文件移动到 TF 卡在本机将 linux.tar.gz 解压缩。 将 linux/boot 目录文件复制到 TF 卡 boot 目录，树莓派开机。 启动之后将 linux.tar.gz 通过 scp 上传到树莓派中。 1234567$ tar -zxvf linux.tar.gz$ cd linux$ sudo rm -rf /lib/firmware$ sudo cp -a lib/modules/* /lib/modules/ 注意: 这一步不可以省略，如果不复制 modules 一些软件比如 Docker 会出错。 相关链接 官方文档 https://github.com/bamarni/pi64 http://www.aptno1.com/YC/255.html]]></content>
      <categories>
        <category>Raspberry Pi3</category>
      </categories>
      <tags>
        <tag>Raspberry Pi3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[curl wget 参数详解]]></title>
    <url>%2Flinux%2Fdownload.html</url>
    <content type="text"><![CDATA[curl wget 使用方法 12345$ curl url -o outfile$ curl -O url # Write output to a file named as the remote file$ curl -fsSL url 1$ wget url -O outfile]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Fedora 常用软件]]></title>
    <url>%2Flinux%2Ffedora.html</url>
    <content type="text"><![CDATA[本文列举了 Fedora 常用软件。 右键菜单在终端中打开1$ yum -y install nautilus-open-terminal Tilix https://github.com/gnunn1/tilix 1$ dnf install tilix 字体123$ cp /usr/share/doc/freetype-infinality/infinality-settings-generic /etc/profile.d/infinality-settings-generic.sh ; \$ cp /usr/share/doc/freetype-infinality/infinality-settings.sh /etc/X11/xinit/xinitrc.d/ ; \$ chmod a+x /etc/X11/xinit/xinitrc.d/infinality-settings.sh]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Fedora</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 容器编排之路：从 Fleet 到 Kubernetes 的转变（转载）]]></title>
    <url>%2Fdocker%2Fcoreos%2Fmigrating-from-fleet-to-kubernetes.html</url>
    <content type="text"><![CDATA[CoreOS 计划于 2018 年 2 月 1 日从 Linux 的容器平台上替换 fleet 技术，对 fleet 的支持也即将截止。 CoreOS博客：https://coreos.com/blog/migrating-from-fleet-to-kubernetes.html 翻译：http://dockone.io/article/2277 近两年分布式应用的组织和管理水平大幅提升。CoreOS集群管理始于fleet，fleet是2014年发布的一个简易的分布式服务管理框架。而社区上Kubernetes被广泛应用，并逐渐成为了开源容器框架的事实标准。基于技术应用和市场占有等原因，Kubernetes成为大规模容器架构集群最优秀的自动化编排工具，CoreOS也因此而改变技术选型。本文讲述了CoreOS公司集群编排框架的前世今生，描述了从fleet到Kubernetes的转变。 目前，CoreOS计划于2018年2月1日从Linux的容器平台上替换fleet技术，对fleet的支持也即将截止。fleet进入了维护期，仅负责安全及补丁修复的升级。此项变动代表着集群编排和管理技术将转移到Kubernetes技术上。此转变也简化了用户自动更新容器Linux最小集操作系统的发布和部署操作。 新集群部署将提供以下支持： CoreOS Tectonic 为生产环境部署 Kubernete 提供专家支持和交钥匙部署和升级服务 Linux的容器上使用的开源 Kubernetes 软件 用于 Kubernetes 先导帮助的开源 minikube 工具 2018年2月1日以后，fleet 的容器镜像在 CoreOS 的软件注册仓库中仍存在，但不作为 Linux 的容器操作系统集装打包。 若已购买 Linux 容器服务的 fleet 的用户，可在服务终止前从原有渠道获得迁移服务。并获取相关文档。 在此期间，可继续通过 CoreOS 的邮件列表服务解答 fleet 用户的问题。 fleet：集群化之路的第一步公司创始之初，CoreOS就致力于研究操作系统的集群编排技术，目前以 CoreOS Linux 容器操作系统最为流行，也是首家提供云环境自动部署和调度集群资源的容器软件。最初该软件是通过fleet实现开源集群调度框架，实现集群设备的系统初始化。 采用 fleet 不到一年，Google 公布了开源 Kubernetes 项目。令人振奋是他推动了 CoreOS Linux 容器操作系统 fleet 的 etcd 分布式键值后台存储技术的发展，更重要的是Kubernetes提供了fleet未提供的今后发展方向和解决方案。 Kubernetes 设计了一套稳定可扩展的API接口、预置服务发现、容器网络、及扩展的关键特性。此外，该技术还在 Google Borg，Omega，and SRE 团队有多年的运营经验。 Kubernetes and Tectonic：如何编排容器基于以上原因，在Kubernetes 1.0之前，CoreOS转而将Kubernetes作为容器编排设计的主要特性，将开发资源投入到Kubernetes的相关基础功能和社区支持中去。CoreOS是Cloud Native Computing Foundation（CNCF）的主要成员之一，谷歌将Kubernetes版权捐赠给CNCF产业联盟，这也促使Kubernetes真正成为全行业努力发展的软件成果。 CoreOS的开发团队主导了 Kubernetes 版本周期管理，Special Interest Groups（SIGs）曾用了2年时间简化 Kubernetes 部署、管理和升级，便于生产环境可用。 CoreOS flannel SDN 成为热门的 Kubernetes 网络管理机制。因为 CoreOS 开发的 Kubernetes 网络接口模型作为容器网络接口（CNI）已被大量容器化系统应用。团队致力于设计和应用 Kubernetes 基于角色的访问控制（RBAC）的技术，使得开源身份认证解决方案dex的团队补充了认证提供商和类似LDAP的企业级解决方案。当然，etcd 原本作为fleet的后台数据存储，代表了早期的努力，也将继续沿用到 Kubernetes 的时代中。 fleet 探索了集群自动化管理的愿景，CEO Alex Polvi 认为 Kubernetes 帮助 CoreOS 达到最终目标。感谢过去社区对 fleet 的反馈和支持，公司已将多年积累的经验和思路应用到 Kubernetes和 Tectonic 的集群容器编排上。 在 CoreOS Tectonic 上开始使用 KubernetesTectonic提供一种最简易的构建新集群方式。在应用开源 Kubernetes 的基础上，它提供了集群编排软件的简单安装和自动升级服务。对于10个节点以内规模的集群的设备提供免费测试应用 lisence，并支持AWS和裸机部署两种环境。 minikube 是 Kubernetes 的简易先导若是个使用容器编排的新手，minikube工具可帮助用户在本地快捷的运行 Kubernetes ，也是一个可安装在笔记本或本地电脑上的 Kubernetes 先导帮助工具。 让 Kubernetes 开启 CoreOS Container Linux 之旅为了深入研究 Kubernetes 的技术细节，可参考部署帮助手册。帮助文档提供了 Kubernetes 相关概念的解释说明，以及一些超出Tectonic两类初始环境外的平台部署技术。 为 fleet 容器提供集群继续提供维护支持在2018年2月 fleet 将从容器的 Alpha 版本上删除，随后将从 Beta 和稳定版本上删除，而此后版本可通过运行容器环境继续使用 fleet。有一个简单封装的脚本可帮助客户获取 fleet 应用容器软件及安装说明。 管理员们可通过调试” fleet 迁移配置示例”实现容器化 fleet 应用部署的迁移。设备提供商可在 fleet 节点上部署封装配置以激活服务。 下一步：从 fleet 迁移到 Kubernetes可加入 CoreOS 的 Container Linux 邮件列表或 IRC 以获得反馈或技术支持。也可在2月14日的现场技术研讨会获得更多信息。最终，建议参加 Coreos 的 Kubernetes 的专家面授培训，帮助开始 Kubernetes 的正式使用。]]></content>
      <categories>
        <category>CoreOS</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 虚拟化软件 Xhyve]]></title>
    <url>%2Fvm%2Fxhyve.html</url>
    <content type="text"><![CDATA[GitHub: https://github.com/mist64/xhyve]]></content>
      <categories>
        <category>VM</category>
      </categories>
      <tags>
        <tag>VM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox Ubuntu EFI 模式配置]]></title>
    <url>%2Fvm%2Fubuntu-efi.html</url>
    <content type="text"><![CDATA[以 UEFI 模式启动虚拟机，首次启动会出现错误。 1234Shell&gt; FS0:FS0:\&gt; cd EFIFS0:\EFI&gt; mkdir bootFS0:\EFI&gt; cp ubuntu\grubx64.efi boot\bootx64.efi]]></content>
      <categories>
        <category>VM</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
        <tag>EFI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VirtualBox 常用配置]]></title>
    <url>%2Fvm%2FREADME.html</url>
    <content type="text"><![CDATA[本文列举了 VirtualBox 常用配置。 压缩虚拟磁盘体积碎片整理12$ sudo dd if=/dev/zero of=/EMPTY bs=1M$ sudo rm -f /EMPTY 压缩磁盘关闭虚拟机，现在可以开始压缩虚拟硬盘了 1$ VBoxManage modifyhd ****.vdi --compact 改UUID1$ VBoxManage internalcommands sethduuid ****.vid #虚拟磁盘文件]]></content>
      <categories>
        <category>VM</category>
      </categories>
      <tags>
        <tag>VirtualBox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[火狐常用设置]]></title>
    <url>%2Ftools%2Ffirefox.html</url>
    <content type="text"><![CDATA[所有页面统一缩放比例打开 about:config 搜索 zoom 找到 zoom.maxPercent 和 zoom.minPercent 都修改为统一的你想绽放的比例，打开任何网页都是你设定的比例。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Firefox</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[终端录屏工具 asciinema]]></title>
    <url>%2Ftools%2Fterminal-rec.html</url>
    <content type="text"><![CDATA[asciinema 是一个用 ClojureScript 编写的开源命令行录屏工具。 安装macOS1$ brew update &amp;&amp; brew install asciinema pip31$ sudo pip3 install asciinema 录制1$ asciinema rec 使用 exit 或者 Ctrl+D 快捷键结束录制。结束录制的时候提示，如果要上传的话，敲回车，这样就不至于把废品也上传了。 上传之后，asciinema 会给出一个网址，如：https://asciinema.org/a/44nu2i2ieywlmqq9wx5sk5k1e 。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Tools</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[brew 安装配置]]></title>
    <url>%2Fmacos%2Fbrew.html</url>
    <content type="text"><![CDATA[访问官网复制脚本安装 https://brew.sh/index_zh-cn.html 常用命令诊断1$ brew doctor 清理删除旧包、不再需要的包、安装包 1$ brew cleanup 切换版本12345# 没有执行过 cleanup ,可以切换到以前安装的版本$ brew info node$ brew switch node 8.2.1]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
        <tag>brew</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 背后的故事（上）]]></title>
    <url>%2Fmacos%2Fstory.html</url>
    <content type="text"><![CDATA[作者:王越 来源:《程序员》 作者王越，美国宾夕法尼亚大学计算机系研究生，中国著名 TeX 开发者，非著名 OpenFOAM 开发者。 Mac OS X 背后的故事（一）力挽狂澜的Ellen Hancock Mac OS X 背后的故事（二）Linus Torvalds的短视 Mac OS X 背后的故事（三）Mach之父Avie Tevanian Mac OS X 背后的故事（四）政客的跨界 Mac OS X 背后的故事（五）Jean-Marie Hullot的Interface Builder神话 Mac OS X 背后的故事（六）上善若水 Mac OS X 背后的故事（七）上善若水下——Cordell Ratzlaff 引发的 Aqua 革命 Mac OS X 背后的故事（八）三好学生Chris Lattner的LLVM编译工具链 Mac OS X 背后的故事（九）半导体的丰收 Mac OS X背后的故事（十）Mac OS X文件系统的来龙去脉 Mac OS X 背后的故事（一）力挽狂澜的 Ellen HancockEllen Hancock曾任苹果公司技术总监 故事还得从 20 世纪 90 年代说起。Ellen Hancock 是本文的主人公，也是一位女英雄。她因在 IBM 的经历而被人们所熟悉。1966-1995 年间，Ellen Hancock 在 IBM 共工作了 29 年。1985 年，她成为 IBM 的副主席。在 1986-1988 年间，Ellen Hancock 担任过 IBM 通信产品的主席，并在 1992 年被选为资深副总裁。1995 年 9 月，她被时任美国国家半导体（National Semiconductor）CEO的 Gil Amelio 忽悠，跳槽来到这个企业，做执行副总裁。她在这里带领团队完成了 CompactRISC 架构，这个架构事后成为 ARM7 系列的前身。很多人早已经把她忘了，也很少有人能够在回忆时将她和 Mac OS X 联系起来。但事实上，她是让苹果放弃 Copland 转而购买 NeXT 的关键人物。 早在 1994 年，Gil Amelio 就找好了下家 Apple，成为 Apple 董事会的成员。1997 年 2 月，Gil Amelio 从 National Semiconductor 辞职，并成为 Apple 的 CEO。为了紧跟老板的召唤，Ellen Hancock 再次被忽悠，来到了当时危机四伏的 Apple。这时是 1996 年 5 月，为什么是危机四伏呢？还得从早先的事情说起。 20 世纪 80 年代，卖可乐的 John Sculley 成为 Apple 的 CEO，随之 Steve Jobs 被轰出Apple。毕竟可乐和计算机不是一回事，因此不管是硬件还是 Mac OS，整个公司的开发项目越来越受阻。而且由于先天的不足，Mac OS 从诞生之初就不具有一个现代操作系统所应有的特性。所以，在 1987 年，开发下一代操作系统的计划呼之欲出。具体的规划是，把新的系统所需要的功能，写在一堆卡片上。短期可实现的目标，比如增加颜色支持（当时计算机仍是黑白的），写在蓝色的卡片上；长期的目标，比如多任务功能，写在粉色的卡片上；而在可预见的未来都无法实现的长期的目标，比如加一个纯物件导向的文件系统，就写在红色的卡片上。在这样的思路下，Mac OS 的开发团队马上就被分成两个组，一个叫蓝组，目标是在 1991 年，发布一个关于 Mac OS 的更新版本；另一个叫粉组，和蓝组同时工作，计划在 1993 年，发布一个全新的操作系统。 1991 年 5 月 13 日，蓝组顺利按时完成开发任务，发布了 Mac OS 7（一般被称为 System 7），而粉组却没做出什么有实际用途的东西来，因此接连跳票。而且，由于 Mac OS 7 的发布缺乏人手，为了保持正常发布，常常需要从粉组抽调人员参加蓝组的开发，再加上 Apple 当时把重心放在了和 IBM 等公司的合作上（Taligent 项目）而不是在粉组上，最终导致了粉组项目夭折。而本来 Apple 指望和 IBM 合作的Taligent 项目能开发出一个可用的新系统，但后来 IBM 不跟 Apple 继续玩了，因而 Taligent 的果子又吃不到，Apple 相当郁闷。这时由于 Mac OS 有先天不足（单任务，没有内存保护），再加上 Apple 以及第三方软件的无限量增加（在这段时期，单 Apple 自己就已经加入了 QuickDraw、PowerTalk、QuickTime 等软件和技术，每一个都比 Mac OS 本身来得大），Mac OS 的问题终于大爆发。上个世纪 90 年代，Mac OS 给人的印象就是很不稳定、经常崩溃，同 Windows 95 留给 PC 用户的印象差不多，甚至更甚。 Taligent 项目挂掉后，Apple 自己尝试过十多个不同的内部项目，但大多没做多久就夭折了。而这时正是 Windows NT 走向成熟的关键时期。眼看着日子逐渐变得不好过了，Apple 开始重新开始考虑建立下一代操作系统的事情。1994年，Mac OS 7.5（Mozart）发布后，Apple 推出新规划，建立一个全新的操作系统，以 Copland 命名（纪念 Aaron Copland，Mac OS 的发布以音乐家名字命名，和 Mac OS X 后使用猫科动物名字很不一样），这个项目将有一个全新的内核，具有类似 Windows NT 内核的所有高级特性，而老的软件都当作独立的进程模拟运行。这个项目时间紧、任务重，1995 年 3 月公布计划，预期 1996 年发布。而 Copland 后的版本 Gershwin（纪念 George Gershwin），预计 1997 年发布，将重写 Mac 的所有系统主要部件，以适合新内核的各种特性。 Copland 将使用微内核技术，只做任务和内存分配。除此之外的所有功能，比如文件系统、硬件驱动等作为微内核上的服务运行。而 Mac OS 的所有用户界面功能将成为一个独立的框架，称为蓝盒（Blue Box，今后介绍 Mac OS X 时，我们还会遇到这个词）。所有的任务相互独立，占用独立内存，也可以用 IPC 相互交流。学过操作系统的人都知道，微内核是当时的一个热词，一个系统只有被称为微内核才可被看作是先进的，当时还有针对 Linux 系统的著名的 Tanenbaum-Torvalds 笔战。但事实证明，所有本来想做成微内核系统的成功项目都放弃了原先的设计（包括 NeXTSTEP、Windows NT），因为这种类似 Mach 微内核的系统往往难产，GNU/Mach + Hurd 之类的项目做到现在经过了20年，仍未成事，一年内搞一个微内核系统谈何容易。 微内核还没搞成，Apple 几乎所有开发组的成员都来添乱。大家都说自己做的东西很重要，一定要加入 Copland 开发组，所以 QuickDraw GX、OpenDoc 之类的开发组产品成为新系统的核心组件，甚至类似用户界面皮肤之类的开发组都来凑热闹，马上就使 Copland 成为一个无法维护的项目。开出的计划越来越长，项目越来越多，但相关进展越来越少，完成速度越来越慢。即便做出了产品，连测试人手都不够。1995 年就有工程师指出，在 1996 年发布 Copland 纯粹是幻想，能 1997 年发布就不错了。 1996年，Gil Amelio 已经掌权。在苹果电脑全球研发者大会上他开心地宣布，传说中的 Copland，也就是 System 8 的开发版会在当年夏天发布，而正式版在秋天就可以送到每位用户手上。时任 TidBITs 编辑的 Matt Neuburg 有幸见到了这个传说中的系统。令他大吃一惊的是，这个系统在当时只能打开或关闭文件，而无法对文本文件进行编辑，甚至所有用户界面的文本框都不能输字。哪怕什么都没做，整个系统也会随机崩溃，而崩溃甚至会造成文件系统损坏。参加演示的苹果员工，则需要不断守在旁边，他们的工作是不断地格式化已崩溃的计算机磁盘，然后重装系统。那年夏天，第零个测试版送到一小簇不明真相的开发者手中，把那些脆弱的没见过世面的人吓得半死。就连 Apple 内部都开玩笑说 Copland 的正式发布日期可能得推迟到 2030 年。 Gil Amelio 心急如焚，希望 Copland 快点走到正道上来。作为 Gil Amelio 永远的好朋友，Ellen Hancock 就在这个乱糟糟的时候来到了 Apple。她的职务，正是担任这个乱糟糟项目的负责人。她亲自下访各小组体察民情，了解情况。毕竟在 IBM 干了近三十年，她依靠自己过人的判断力在 2~3 个月内便得出结论，Copland 这个项目是没有指望的，就按目前 Apple 这样的状态，Copland 永远都不可能发布，还不如早点取消了好。在短期内，先把 Copland 中的一些有用的成果一点点合并到老的 Mac OS 中，并且抓紧从外部购买一个全新系统来满足 Apple 的需要。正是她的这个结论，结束了 Apple 长达五年的纠结，使公司重新走向正轨。整个 PC 的黄金时代已经过去，Apple 想要翻身，还有很长一段路要走。Gil Amelio 支持了 Ellen Hancock 的计划。1996 年 8 月，Apple 取消 Copland 项目。开发预览版的 CD 封套都已制完，每个邮包上的地址都已打印就续，而 CD 却从未曾制出。 1996-1998 年是 Apple 最混乱的几年。在商业上，有一阵曾传出 Apple 要被 Sun 收购的消息。更有意思的是，《连线》杂志在 1997 年的六月还发表了一篇文章，名为《101 种拯救 Apple 的方法》，其中一条说最好的方式是 Apple 让自己被 Motorola 买下，成为 Motorola 的一个部门，做 PowerPC 系列产品。以当时的眼光来看这些建议非常讽刺好笑，以今天的眼光看更为好笑。而 Ellen Hancock 在这段时间内的出色工作，成功地挽救了 Apple。 首先，Ellen Hancock 的对内政策是继续 Mac OS 7.5 的开发工作，一步步把 Copland 中的技术并到 7.5 中。同时，也大量购买第三方的系统增强包，包括插件管理工具、层次化菜单等技术。Apple 把它们买过来，整合到现有的系统中。整个老系统在新系统尚未完成的时候不断更新，至 2000 年已出到 9.0 版，尽可能地留住了老用户。并且，前面提到的蓝盒（Blue Box）也作为后来新 Mac OS X 系统的一部分，支持用户运行经典 Mac OS 的程序。 而对外政策更是一个大手笔。Ellen Hancock 协助 Gil Amelio 在 Apple 之外找寻操作系统技术。在 IBM 和 Microsoft 合作 Big Blue 的经验告诉她，购买一个操作系统的使用权问题多多，最好的计划是整个一并买下来。因此，Gil Amelio 开始和当时看好的 Be 谈，却因价格问题没有成功，最终转而收购了 NeXT。而 Apple 合并 NeXT 后，NeXTSTEP 就演化为 Rhapsody，并最终成为 Mac OS X。这些事情我们今后会详细再谈。 买完 NeXT 后，Steve Jobs 执政，Gil Amelio 因任 CEO 期间 Apple 亏损严重而被炒。Steve Jobs 把信得过的人（很多是前 NeXT 员工）拉拢到周围，开始新政，而同 Gil Amelio 有关的 Ellen Hancock 则在人事变动中被疏远。Steve Jobs 甚至在很多场合称她为“笨蛋”。Ellen Hancock 最终于 1998 年主动辞职。事后同 Gil Amelio 以及 Apple 的创始人之一 Steve Wozniak 一同创业，但始终不景气，她的辉煌时代已经过去。 Gil Amelio 总结他在 Apple 时期的工作时说：“Apple 是一艘底部有洞漏水的船，而我的工作是把这船引向正道。”（Apple is like a ship with a hole in a bottom, leaking water, and my job is to get this ship pointed in the right direction. ）Ellen Hancock 虽然同 Gil Amelio 一样，不知如何去堵这个漏水的洞，但正是由于她在 Apple 的出色表现，不但把船引到了正道上，还找来了有能力堵这个洞的人。 Mac OS X 背后的故事（二）——Linus Torvalds的短视 本文主要的故事来源是 Linus Torvalds 的自传《Just for Fun: The Story of an Accidental Revolutionary》。 Steve Jobs 于 1997 年回归 Apple Steve Jobs对Mac OS X的考虑 1997 年，Steve Jobs 回归，开发下一代操作系统的工作被提上日程。此刻的时代背景是像 Linux 这样的开源软件大行其道。随着网络的发展，使得像 Red Hat、VA Linux 之类的企业成为爆发户，把泡沫越吹越大。Steve Jobs 承认 Linux 的好处，甚至在若干年后介绍 Mac OS X 底层的 Darwin 时还不忘在幻灯片上写道：Darwin 是类似 Linux 的系统。而当时精明的 Steve Jobs 在考虑下面几个问题。 第一，NeXTSTEP 的内核和外围工具中，BSD 代码维护起来需要大量人力，而且各分支的 BSD 发展显然不如 Linux 快。很多功能都没有，需要 Apple 自己做。 第二，像 Apple 这样的小公司，需要借力打力。Apple 的主要竞争对手是 Microsoft，而开源软件的矛头也是 Microsoft，如果联合起来干革命，不但能让自己得到一个好名声（Apple 事后一直自称是最大的开源软件公司），也可以获得可观利益，从而对 Microsoft 造成压力。 第三，也是最重要的，联合各开源组织能够推动 Mac OS 的发展。毕竟开源软件中像 GCC 之类都是很成熟的项目，Apple 用起来省时省力，投点钱就有大效益，多好。 所以，把 Linux 内核作为 Mac OS X 的重要组成部分的想法被这位伟大的智者想了出来。Apple 之前也有开发 Linux 的经验，比如在 Steve Jobs 回归之前，Apple 就和 OSF 合作开始把 Mach 内核移植到 PowerPC 上（Apple 是最大的 PowerPC 玩家，而 OSF 是最大的 Mach 玩家），并把 Linux 作为服务跑在 Mach 上。这个系统就是 MkLinux，我们在后续的连载中还会提到这个系统，因为它不但对 Linux 的移植性作出了重要的贡献，也对后来的 Mac OS X 的 XNU 内核技术起到了相当重要的作用。 如果可以采用 Linux 作为系统重要组成部分，并且这个构想能够取得在开源软件界呼风唤雨的 Linus Torvalds 的认同，就能靠他在社区鼓动一大群开发者皈依 Apple 麾下，这是 Apple 很想看到的给力结局。有了这个指导思想，他便让秘书给 Linux 的开发者 Linus Torvalds 发了一个邮件，问他是不是有一到两小时的时间和 Steve Jobs 会面。不明真相的 Linus Torvalds 收到邮件后相当高兴，因为这是他第一次有机会去硅谷观摩。 无果而终的会面 Apple 总部 Infinity Loop 终于迎来了这位稀客，Steve Jobs 亲自接见，而先前任 NeXT 技术总监的 Avie Tevanian（这人的故事我们今后会提到）也参加了这次会谈。不用多说，这次讨论的内容自然是还处于未知状态的 Mac OS X。讨论算不上正式，但 Linus Torvalds 的愤青个性，却让谈判陷入僵局。 Steve Jobs 自然搬出他 1997 年回归之际在 MacWorld 讲话时的那套理论，Apple 虽然很颓，但骨子里是个牛逼的公司。全世界桌面领域的真正玩家就两个，一个是 Apple，另一个是 Microsoft，两者加起来，构成百分之百的桌面用户群。所以，Linus 同学，你就从了我们吧，如果你从了我们，让我们把 Mac 架在 Linux 上，一大批桌面用户就是 Linux 用户啦，前景可是一片大好！ 而 Linus Torvalds 那时候牛啊，诸多大公司如 IBM、Red Hat 都围着他转。他可是企业家中的大红人，像 Apple 这样的企业根本就不在他眼里。作为一个开源软件的革命家，在他的想象中 Linux 的潜在用户应该比 Apple 还多。他始终相信，按照目前开源软件的发展态势，自己很快就能在桌面领域分到一杯羹。而且这个命题在他这种古怪性格下的直接推论是，即使我能占领桌面领域，我也要摆出一副不在乎这个领域的态度来。所以实际上 Steve Jobs 的开场白一开始就失败了。 接着，Avie Tevanian 向 Linus Torvalds 介绍了整个计划。他们想把 Mach 和 Linux 内核合并起来作为 Mac OS X 的基础，我估计 Linus Torvalds 是听错了（因为 Avie Tevanian 很早就意识到相比于微内核，混合内核有明显优势），他以为 Apple 想把 Linux 作为 Mach 的一个服务来跑（当然我个人认为，即使是合并 Mach 和 Linux 成为混合内核，依 Linus Torvalds 的愤青性格，依然是不可能接受的），这正让他回想到先前和 Tanenbaum 教授的笔战。并且，他也知道 Apple 和 IBM 合搞的失败项目 Taligent 正是用 Mach 的。 Linus Torvalds 对于微内核有他自己的看法，之前也曾在不同的地方表述过。若把关于微内核的笔战去掉限制级敏感词的话可概括成两方面。一方面，设计一个微内核和相关的服务，可能造成各种设计上的灾难。GNU/Hurd 早在八十年代末就考虑尝试在 Mach 上写一系列 Unix 的服务层，结果他们始终无法搞明白到底是让这些服务先发消息到另几个服务呢，还是考虑其他方案。所以直到 2011 年我写这篇文章时，Hurd 项目依然处于半死不活的状态。而另一方面，微内核的效率无法和传统内核相比，最简单的系统调用会涉及一系列底层服务的互相通信。所以很多研究者着手研究如何把微内核的效率提上去，结果就导致微内核变得更加复杂。能提高微内核效率的很多研究成果都已在 Mach 项目中实现了。而在 Linus Torvalds 看来这恰使 Mach 成为了一个非常复杂的项目，并且效率也不怎么高。 会谈时坐一旁的 Avie Tevanian 事实上是 Mach 最早的开发者之一，他热情地给 Linus 讲述 Mac OS X 系统蓝图。而 Linus 实际上早就不耐烦了。比如，Mac OS X 中，有一个模拟层，可让用户使用经典的 Mac OS 程序。这个技术极类似于现在跑在 Unix 系统上执行 Windows 程序的 Wine 。Apple 当时的考虑是这样，因为老的 Mac OS 在设计 API 时，就没有考虑到类似内存保护之类的问题，所以这层 API 必须废掉，Mac OS X 中所有的新程序必须采用 NeXT 的那套更先进的 API（根据我的考证，当时还没有 Carbon 这样的想法，而且事实上 Carbon 不管在 API 还是 ABI 上都和经典 Mac OS 不兼容）。而短期内已有的软件又不可能快速重写迁移至 Mac OS X。所以，如果用户需要使用老版 Mac OS 的第三方应用程序，就可以使用 Apple 提供的这个兼容层。但是由于刚才提到的原因，老版程序并不享受新版程序的待遇，因为模拟器本身运行多个老 Mac OS 任务时，和原先老版 Mac OS 一样，实际上只有一个进程，没有内存保护。这样做的好处是明显的，因为一方面老的程序在 Mac OS X 发布之初还能用，另一方面 Apple 又和老技术划清了界限，逼着开发者使用新技术，技术方面的原因是最重要的。但这个看似很正确的技术在 Linus Torvalds 看来是古怪的，他想当然地认为，完全可以运行多个不同的模拟器进程，来执行不同的任务，使得每个任务都可以享受内存保护。这种浪漫主义情调让他无比鄙视 Apple 员工的智商。而事后当笔者使用早期版本的 Mac OS X 时，发现 Linus Torvalds 的想法完全是不切实际的。因为这个模拟层本来就要占用不少的内存和 CPU，在处理器速度不及今日手机、内存无比精贵的 90 年代末，跑一堆模拟器进程无异于是和自己过不去。 Steve Jobs 考虑到 Linus Torvalds 是开源软件的领军人物，便继续以开源为话题，动之以情，晓之以理。他告诉 Linus Torvalds，我们这个系统做出来后呢，所有的 Unix 层（非图形界面层），都会开源，所以事实上你加入我们，也是在给开源做贡献啊！而由于在开源圈子混久了，Linus Torvalds 对此丝亳不领情，他认为，有谁会想用一个底层是开源而图形界面是不开源的系统呢？所以，像笔者这样的用户被“代表”了。 Mac OS X 与 Linux 分道扬镳 总之，这次会面完全谈崩，两人站在不同的角度去看问题，加上 Steve Jobs 和 Linus Torvalds 都是个性鲜明、唯我独尊的人，技术和商业上的考虑都不同，所以会谈中双方简直就是鸡同鸭讲。这次讨论也使得 Apple 放弃 Linux，转而采用 FreeBSD 技术，并在 2001 年任命 FreeBSD 的发起者、领军人物 Jordan Hubbard 为 BSD 技术小组的经理，并在后来升为 Unix 技术总监。至于 Apple 的内核技术后来走向何方，我们下期再讲。 笔者认为，Apple 和 Linus Torvarlds 的商谈破裂，以今天的眼光来看，是因 Linus Torvarlds 的自命清高和短视造成的。他不懂得尊重其他开发者的意见，并且不断抬扛。包括后来关于 C++ 的论战。Mac OS X 发布后，Linus Torvalds 又数次嘲笑 Mac 的技术落后，并说这些他在当年和 Steve Jobs 开会时就预料到了。直到最近，他终于有些成熟，对 Mac OS X 的观点开始缓合，但还是不忘批评 Mac 的文件系统就是垃圾（事实上，Linux 的也没好到哪去，至少 Apple 还搞过一阵 ZFS）。这种性格最终导致在 Mac OS X 和 iOS 大行其道的时候，Linus Torvalds 连兔子汤都不曾分到。而事实上这对 Apple 也是件好事。Apple 重要的是利益而不是折腾，即使是开源也是利益驱动。像类似 Linux 开发组那样自以为是但代码又写得差的开源项目，Apple 事后也遇到不少，比如 GCC 编译器项目组。虽然大把钞票扔进去，在先期能够解决一些问题，但时间长了这群人总和 Apple 过不去，并以自己在开源世界的地位恫吓之，最终 Apple 由于受不了这些项目组人员的态度、协议、代码质量，觉得还不如自己造轮子来得方便，因此 Apple 推动了类似 LLVM 这样宏伟的项目，并且在短短几年内，使其成为最领先的开源软件技术。这无异于扇了 Linux 小组、GCC 小组一记响亮的耳光。 Mac OS X 背后的故事（三）Mach 之父 Avie Tevanian 1975 年，美国罗彻斯特大学纽约分校，一组研究员正在做一个名为 RIG（Rochester’s Intelligent Gateway）的项目，它由 Jerry Feldman 主持设计。RIG 的目标是给所有本地以及远端的计算设备（比如磁盘、列印机、磁带、绘图机等）提供一组统一的访问方式，其作业系统称为 Aleph。为了实现所需要的功能，Aleph 的内核主要构建了一个进程交互（Interprocess Communication，IPC）的机制。RIG 的各进程，只要设置了目标端口，就可以彼此间发送信息。RIG 项目没过几年就被判了死刑，主要是缺少很多有用的功能，比如端口没有保护机制，一次最多只能发送 2KB 大小的信息（受硬件限制），也没有很好的网络支持等。不过在 20 世纪 70 年代，这个系统依然代表着当时作业系统设计的先进水平，比如除了进程交互外，每个进程还有内存保护的功能，这足以让 20 世纪 90 年代末都没有做出内存保护技术的 Apple 公司汗颜。 该项目后来失败了，随后在 1979 年，RIG 的 Richard Rashid 博士毕业到卡内基-梅隆大学当教授，开始做 Accent 项目。它是一个网络作业系统，于 1981 年 4 月开始活跃开发。受 RIG 的影响，Accent 系统的亮点也在于可以使用 IPC，而且解决了很多 RIG 的不足。比如每个进程有 4GB 的虚拟内存空间，而且甚至连内核自已都可以被存入缓存页面，内存有先进的更新前拷贝（Copy-on-Write）功能，可以实现进程间大信息的传送等。读者可以把 Accent 理解为支持虚拟内存技术，并且具有网络透明 IPC 功能的 RIG 内核。 但过了几年，开发者们越来越对 Accent 失去兴趣。在 1980 年初，很多人觉得多核计算是计算机未来发展的潮流，但 Accent 内核在设计时并没有考虑到这些问题。而且，随着许多实验室纷纷购置性能更强劲的计算机，这就意味着 Accent 需要移植到新的目标架构上。此外，Unix 正大行其道，不管是在作业系统理论上还是在用户程序上，都成为最为流行的作业系统模式，而 Accent 并不是一个 Unix 系统，所以无法享受 Unix 世界的诸多美好。为了解决这个问题，研究人员决定把所有设计推翻重来，于是就有了一个全新的系统。 在匹兹堡的一个雨天，卡内基-梅隆大学的 Avie Tevanian，此系统的最主要开发者，正打着伞和同学们在去吃午饭的路上。他们一边绕着无数的泥塘，一边构思给这个新系统取什么名字好。灵感突来， Avadis Tevanian 建议把这个系统叫作 Muck，引得同学们哈哈大笑。后来，Richard Rashid 和一位意大利同事 Dario Giuse 说起这玩笑，结果这位同事不经意地把 Muck 发为 Mach，遂把 Richard Rashid 笑翻，伟大的 Mach 系统因此得名。 Mach 是一个受 Accent 启发而搞出的Unix兼容系统。那年，Unix 已经十六岁，而且依然是作业系统理论与实践开发的主要阵地。Unix 内核由于新加入的功能越来越多，变得越来越复杂。而 Mach 的一个主要目标就是尽量缩减 Unix 的各项服务，以使内核变得简单可维护。此项目从 1984 年开始，目标主要是包含完整的多任务支援、良好的硬件移植性，并要把大量服务移出内核作为跑在内核上的服务，以及提供与 Unix 的兼容性。 Mach 使用纯 C 编写，所以在一定程度上保证了可移植性，这事实上为后面的 NeXT 向 PowerPC 移植以及 2005 年的向 Intel 移植提供了很重要的前提。而为了缩减内核该管的任务，Mach 做得很绝，只提供内存和处理器管理。类似于档案系统、网络、输入输出等功能都作为单个的系统进程，独立执行于内核之上。Mach 的开发过程以 4.3 BSD 作为起点，以 RIG 的 Accent 作为参考，采纳 DEC 的虚拟内存设计思路，逐步开发，以新写的代码代替 BSD 的代码。两年后的 1986 年，虽然没能把系统服务完全分离于内核之外，但已颇见成效。Mach 第一版大功告成，组员发表会议论文，成为操作系统史上里程碑式的经典，引发操作系统业界的“微内核”学潮，如今学习作业系统设计的皆需学习此文，二十五年来被引用一千二百余次。 这篇文章主要讲了两方面内容：IPC 和虚拟内存。在 IPC 方面，Mach 把复杂的消息传送机制分为四个独立的清晰概念—任务、线程、端口、信息。任务是拥有一组系统资源的对象，允许线程在其中执行；线程是执行的基本单位，拥有一个任务的上下文，并且共享任务中的资源。 由于该论文的影响力，所以项目得到了 OSF（Open Software Foundation）在内的很多投资。当然了，学术和工程永远存在差距，所以即使是最受欢迎的 Mach 2.5 其实仍然是一个包括大多数 BSD 服务层的单内核。但包括 NeXTSTEP、OSF/1 在内的很多操作系统都采用 Mach 作为其内核技术，原因是广大研究人员依然相信微内核代表着未来。虽然 Mach 2.5 的效率比传统的 Unix 系统稍低一些，但研究者们表示情绪淡定，因为 Mach 支持多处理器系统，可以利用多线程把任务处理得飞快，相比之下其他 Unix 内核并没有多处理器的完善支援，因此 Mach 效率稍低完全可以接受。但随着真正把 Mach 和 BSD 服务完全脱离的 Mach 3 微内核面世，研究人员们的情绪就再也淡定不起来了。因为服务和内核分离后，任务间的 IPC 数量暴涨，一个简单的 Unix 系统调用要涉及到十多个开端口、设权限、发送、收取消息的操作，哪怕是使用数年后的 1997 年的硬件，跑一个系统调用密集的程序，Mach 的效率要比一般的 Unix 系统慢 50%，而且根本没有什么好方法来解决这个问题。 所以 Mach 3 出来后，虽有少数微内核信徒继续执著地改进 Mach，或者开始其他微内核比如 L4 的研究。但学术界对 Mach 的兴趣大减，因而 Mach 3 也成为最后一版。项目解散后，Richard Rashid 去了微软研究院。 再说我们的主角 Avie Tevanian，他 1987 年博士毕业去了 NeXT。这家公司刚刚由 Steve Jobs 成立两年，这两年 Steve Jobs 啥正经事都没干，只是花了十万美元雇 Paul Rand 设计了一个公司商标。直到 Avie Tevanian 加入后，这个公司才开始干实事。1987 年公司确认要开发一个面向研究人员使用的计算机工作站，于是软硬件的开发工作紧锣密鼓地展开。硬件组由领导过 Apple Lisa 的 Rich Page 原班人马负责，而软件则由 Avie Tevanian 负责，计划开发一个有图形界面的操作系统 NeXTSTEP。由于 Avie Tevanian 是 Mach 主要的开发者，自然 NeXTSTEP 就基于 Mach 了。1988 年 10 月 12 日，NeXT 发布预览版（0.8版），并于 1989 年 9 月 18 日发布 1.0 版（注：http://en.wikipedia.org/wiki/NeXTSTEP ）。 作为 NeXTSTEP 系统的内核，NeXT 分支的 Mach 经历了不少变化。NeXTSTEP 0.8 主要使用 Mach 2.0 版，而稍后的 NeXTSTEP 1.0 版主要基于 Mach 2.5 版，包含一个自己定制的当时最新的 4.3 BSD 服务层。从 3.1 版开始，NeXT 分支的 Mach 还包括一个全新的设备驱动框架， 名为 Driver Kit，仅供 x86 系列的硬件使用。和 Mach 以及 BSD 代码不同，Driver Kit 是使用 Objective-C 写的。为什么是一个面向对象的语言呢？看 NeXTSTEP 3.3 的 DriverKit 文档。读者大概就会发现，NeXTSTEP 把所有硬件设备理解为对象，而我们知道，对象之间有继承关系，比如，磁盘（IODisk物件）属于输入输出设备（IODevice物件）的子物件，而磁盘（IODisk）本身又是逻辑磁盘（IOLogicalDisk）的父物件。硬件的初始化对应于每个物件的初始化（init方法），硬件又有读、写，所以可以用 getter/setter 的方法。因此，DriverKit 是一个非常有特色的实现。而且由于 Objective-C 的效率很高，依赖很少（Objective-C 程序可以直接被编译器翻译成等价的C语言程序并编译，而 Objective-C 的运行库 libobjc 也以高效著称），所以也是编写驱动的良好选择。几年后的 IOKit 其实就是个 DriverKit 的翻版。 这时，NeXTSTEP 操作系统大获成功，风险投资商们纷纷购买，但硬件却始终卖不出去（注：Aaron Hillegass《Cocoa Programming for Mac OS X》前言），所以 NeXT 砍掉了硬件部门专做软件，更是使 NeXTSTEP 发展到了巅峰时期，同时支持 68K、x86、PA-RISC 和 SPARC 等硬件，但颇有意味的是它就是不支持 PowerPC 架构。它可以同时产生一个包含所有架构可执行码的二进制文件，来使开发的程序在所有平台上执行。这个功能也影响了后来 Mac OS X 的技术。Mac OS X 10.4 时代有两件跨时代意义的事情，一件是 Apple 搞出了 64 位的 Power Mac，开发者可以发布一个包含64位和32位程序的单一可执行文件，而无需让用户去区分；另一件是和 Intel 合作。Apple 正式发表了 Universal Binary 技术，可以一个 Mach-O 文件同时包含 Intel 和 PowerPC 的指令。这非常贴心的设计（要知道，大多数电脑用户根本不知道 Intel、PowerPC、64位、32位等技术）就是来自于 Mach 的技术。 NeXTSTEP 3.3 后，NeXTSTEP 因为 NeXT 和 Sun 的合作改名为 OPENSTEP，1996 年发布 4.0 版，到 1997 年 2 月 4 日，NeXT 被 Apple 收购之前，期间内核改进除源码同步到 Mach 3.0 版外不明，而且出于不知道的原因，我手头的 OPENSTEP 正式版光盘中，居然找不到 DriverKit 的发布说明和编程文档，故不作详述。不过这段时间，Apple 的活动值得好好一说。之前在《Linus Torvalds的短视》中，我们曾提到，1996 年，Apple 和 OSF 曾经合作，把 Mach 移到 PowerPC Mac 上，再把 Linux 作为单一的服务跑在 Mach 上，这个项目叫做 MkLinux。在 1996 年发布基于 Mach 3.0 和 Linux 1.3 的预览版，并更新到 2002 年结束其历史使命，对 Mach 在 PowerPC 的移植性上做出了重要贡献。这个 PowerPC 版的 Mach 被叫作 osfmk 分支，也正是现在 Mac OS X 中用的分支。当然了，NeXT 被合并后做了大量修改。 Apple 收购 NeXT 后，Mach 被确定作为未来的操作系统核心。Avie Tevanian 被选为软件开发部的总裁。合并所有项目的号角吹响后，上层的 OpenStep API 和老版 Mac OS 的部件开始合并，而 Mach 也经历重大变化。主要是一方面，Mach 使用了 osfmk 分支，但依然包含 4.3 BSD 服务；另一方面，DriverKit 被 IOKit 取代。这是 Apple 走得很被动的一步。因为当时外界普遍对 Objective-C 不看好，逼着 Apple 走老版 Mac OS API 的老路。而 Apple 自己对 Objective-C 也很不自信，甚至想索性换用 Java 了事（我们以后会谈及这段不自信的历史）。所以 IOKit 是一个 C++ 的驱动架构，来符合大众口味。这些改变最早在 Rhapsody 中出现（我们以后也会有一期 Rhapsody 的专题）。但由于 C++ 是门很恐怖的语言，所以 Apple 又把 C++ 给阉割了，去掉了多重继承、模板、运行时动态以及异常，让开发者使用这种对于 Objective-C 来说换汤不换药的 Clean C++ 来做驱动。但公正地说，IOKit 对于 Driver Kit 是有不少改进的，比如 IOKit 可以写在用户空间跑的驱动（虽然大多仍是跑在内核空间上的），因而驱动挂了而系统不会挂。另外 IOKit 考虑到了计算机发展的趋势，所以在电源管理、即插即用、动态加载上做得更好。 但各位也知道，C++ 程序得用专门的运行库才能跑，所以 Mach 中又加入了一个叫作 libkern 的库负责 C++ 相关的功能，同时，还有一个 libsa 的库提供一些类似二分查找、排序等基本算法之类的功能。最后和硬件相关的还有一个叫作 pexpert（Platform Expert）的库，负责收集硬件设备列表、检测机器种类（比如处理器速度等）、解析启动参数等杂活。 至此，Mac OS X 的内核完全形成，形成 BSD、IOKit、Mach osfmk 三足鼎立的态势，并有 pexpert、libkern、libsa 作为基础。Apple 称它的内核杰作为 XNU。其代码开源，请读者移步http://www.opensource.apple.com/source/xnu/xnu-123.5/ ，每个部分的代码都独立存放在一个文件夹中，条理清晰，不妨一读。 由于 4.3 BSD 已是过眼烟云，Apple 后来投入大量资源扶持 FreeBSD 开发。2001 年，Apple 将 FreeBSD 的发起者、领军人物 Jordan Hubbard 收入麾下，并在 Mac OS X 10.3 时基本同步到 FreeBSD 5 的代码（注：http://osxbook.com/book/bonus/ancient/whatismacosx/arch_xnu.html ）。 另外，Apple 的开发也同时反馈到 FreeBSD 小组，包括 FreeBSD 6.2 内核引入的 AUDIT (man audit 或参见http://manpages.unixforum.co.uk/man-pages/unix/freebsd-6.2/4/audit-man-page.html )，后来 FreeBSD 8引入的 libdispatch （http://wiki.freebsd.org/GCD , 在 Apple 这项技术叫 Grand Central Dispatch，是 Mac OS X 10.6 主推的新功能，FreeBSD 基本在 Mac OS X 10.6 上市的同时就拥有这项最新技术），以及 FreeBSD-CURRENT 中的 LLVM-Clang，全是 Apple 的手笔。从 1999 年开始，FreeBSD 源码仓库可以搜索到 Apple 提供的大量的补丁以及新功能。 Mac OS X 早期版本不太稳定，所以会内核崩溃。10.0 版本会直接像 Linux 或者 BSD 那样打出回溯信息，很不美观，所以 Apple 在 10.2 版本开始设计了一个多国语言的图片告诉用户你的内核崩溃了，以让内核崩得看起来更优雅一点。由于包含四国语言，被国内用户戏称为“四国”（注：优雅的图片见下图，详见 （http://support.apple.com/kb/ht1392 ），这是 XNU 的 Mach osfmk 部分的功能。但从 10.3~10.4 版本开始，系统越发稳定，正常使用已很少见到内核崩溃。而且，内核提供的服务也越来越多，使得 Mac OS X 成为一个完善的系统。 21 世纪 XNU 架构方面的最重大改动是支持了 PPC64（10.4 版本时代）、x86 架构（其实本来也一直支持的，以后讲 Apple 的 Intel 迁移时详谈）、x86_64（64位支持是苹果长年努力逐步展开的。10.4 时代 32 位内核支持载入 64 位的用户程序，10.5 系统提供 64 位的Cocoa框架，但系统大部分程序都是 32 位的，10.6 时代内核支持以 64 位模式启动，但在不少硬件上这是非默认的方式，但系统大量程序已被改写并编译为 64 位的二进制程序，10.7 时代内核默认以 64 位模式启动。）和 ARM 架构（iPhone 和 iPad 使用 XNU 内核）等多个新架构。 而其中 ARM 架构的支持别具意义。但 2006 年 5 月 31 日，功成名就的 Avie Tevanian 离开 Apple 另谋发展，此时，离 Apple 的 iPhone 奇迹发生，只有不到一年时间。 Mac OS X 背后的故事（四）—— 政客的跨界 2000 年，美国总统大选，由于选票设计问题，时任美国副总统的 Al Gore 败北。2000 年 12 月 13 日，在一番重新计票的大折腾不起作用后，曾经意气风发的 Al Gore 拖着疲惫的身子，走上讲台，发表了认输讲话（参见 Al Gore《2000 Presidential Concession Speech》），从此退出政坛。一般国家领导人的退政生活其往往松愉快，出出日记，学用哲学，或者像多才多艺的李岚清不但去各地推广古典音乐，更是玩起了篆刻（参见《南方周末》2006 年 5 月 11 日《老常委的卸任生活》），克林顿先生都成立个基金会来帮助社会预防和治疗爱滋。 Al Gore 也没闲着，他找到了让他感兴趣的去处——Apple 总部，并成为董事之一。 Mac OS X 和 Al Gore 的双赢 2003 年 5 月 19 日，Apple 的启示中罕见性地登出了《前总统 Al Gore 加入 Apple 董事会》的快讯。文中提到，Al Gore 总统是一个正宗果粉，他一直用 Mac 计算机，而且还会用 Final Cut Pro 来编辑他的视频。Al Gore 也不掩饰他对 Apple 技术的热爱，他表示对 Mac OS X 的开发极感兴趣，并且也对 Apple 在开放源代码运动中的贡献喜闻乐见。他虚心地说，想在这个让 Apple 起死回生的董事会好好观摩并学习。 Al Gore 的加盟让 Apple 一跃成为电子产品的代言人 苹果公司的 CEO Steve Jobs 表示 Al Gore 曾经管理过世界最大的组织——美国政府，期间显示出的经验和智慧对苹果公司是笔巨大的财富。Al Gore 将成为出色的董事会主席，苹果将以他把苹果公司作为职业生涯的开始为荣。 这之后，Al Gore 在 Apple 内部的决策究竟起了什么作用，和 Mac OS X 的开发有何关联，在正式的渠道很少有史料，但是他后来的各种公开活动，却给 Mac OS X 的技术做足了广告，而且很多证据表明，他正是使 Apple 从被绿色人士攻击的众矢之的的状态，成为业界注重电子产品环保领头羊的主要推手。 Al Gore 重新进入普通人的视野是在 2006 年，他推出了自己参与制作和演出的纪录片《An Inconvenient Truth》（《难以忽视的真相》）和同名书籍。这部长达 94 分钟的影片，在西方国家引起了广大的回响，以 Al Gore 的一场演讲和人生的回忆作为两条主线，详细、科普地向民众介绍了全球变暖问题的科学证据及美国政府掩盖问题的真相。该片以发人深省的立意、详尽的科学数据、平实的讲演风格，加上苹果高超的技术，而获得了广泛的好评并一举获得年度奥斯卡最佳纪录片奖，使得这位美国前副总统摇身一变，成为好莱坞明星。 为什么单单一场简单的讲话，就能做出一部电影，还能得到奥斯卡这样学院艺术奖的亲睐？是因为讲话内容无懈可击么？事后有很多科学家站出来表示，虽然影片内容有积极的意义，但其实也有很多被夸大的科学数据、假设和结论。试思索，该片之所以成功，甚至成为诸多演讲培训机构的重要分析案例，除了数据、观点、论述外，还有以下几个原因。 首先，这场演讲由苹果主导的技术和艺术的设计。Al Gore 向来以说不清想表达的内容而著称。他经常因为讲得过于专业或者缺乏好的表述方法以致于民众完全不懂他在讲些什么。他的早期讲话用现在的眼光看就是个少将体，比如“互联网…网…我…这个…那个…那个…怎么说呢…我想这个…这…这…这…我啊…我啊…就是说…互联网是我发明的！”因此作为苹果展现公司软实力的重要机会，苹果非常重视这场讲话，请公司的图形设计小组带领完成各种所需设计，苹果甚至特地请来了专业的设计公司 Duarte 来进行讲稿和讲话内容的安排。因此，不管是内容安排、图形设计还是技术支持，Al Gore 都有强有力的后盾，他们能够帮助Al Gore 完成任何想达到的目标。不论是 FinalCut 还是 Keynote，一旦缺少任何 Al Gore 想要的功能，Apple 都可以给他开小灶实现。在片末的走马灯字幕中，有大量 Apple 的 Keynote 组、Final Cut 组和图形设计组的员工名字，以示鸣谢。 其次，上面这些资源的相互合作，也使得 Al Gore 的这场讲话的讲稿被精心制作，体现了精心设计的电子稿演讲所能达到的最高成就。苹果公司向来重视演讲，也是各大企业中最会通过演讲来营销产品的公司。每年的 MacWorld 和 WWDC 的 Steve Jobs 讲话都会吸引百万人在计算机前观看。每场讲话都好戏连连，台下的观众的欢呼和掌声不亚于著名歌星的演唱会。这种风格显然给 Al Gore 的讲话风格带来很大的影响。在影片中，观众看不到一个传统的 bulletpoint（PowerPoint 用户常爱使用的表示讲话结构的方法），取而代之的是高清的照片、视频，来展现环境的严峻性。观众不再会为枯燥无味的技术词语而搞得昏昏欲睡，因为屏幕上的一切都是如此真实，各种科学现象由动画效果配合，使其浅显易懂。另外，所有的数据、图表都精心使用软件制作，使其一目了然，表现准确而美观大方，而且 Al Gore 时而还会玩些小噱头，比如讲到现在的温室气体浓度是多么高时，他甚至爬上工作人员为他准备的升降机，升到舞台顶端，来告诉观众，数据已经突破图表的顶端了。现在距笔者观赏完这部影片，已经五年过去了，但影片中的灾难场景、冰川融化的影片段落、海平面上升的计算机模拟、二氧化碳浓度的数据图表，至今都记得一清二楚，足以见得其表现力是何等深入人心。甚至有人在调侃他在 2000 年的竞选演说是怎么回事？难道就是缺少了这些科技元素？ 最后，Mac OS X 的各项技术也是这部片子的重要保证。Duarte 公司的 Ted Boda 表示（该幻灯片的设计师之一），Mac OS X 系统本身的反锯齿功能把文字、图片、矢量图标表现得栩栩如生，使得幻灯片充满美感。QuickTime 技术作为 Mac OS X 的一块重要基石，又使得 Keynote 不需任何插件就能引入任何图片和影像，所以类似使用 Illustrator、Photoshop、AfterEffects 等软件做出的图片、影像或动昼，不需要任何转换过程就能直接拖到 Keynote 中。哪怕 1920×1080 的高清视频，都可以轻松插入，流畅播放。他们组根本想象不出在 Windows上 使用 PowerPoint 会成什么样子。 可以说，没有 Mac OS X，就没有这部电影。而实际上这部电影的作用远胜过任何一部 Apple 公司的广告。片中 Al Gore 时时拿着 PowerBook 的笔记本，在办公室用 Safari 查网页，字体渲染真实而美观，甚至在车上都不忘打开笔记本用 Keynote 做几张幻灯片，就更不用说电影中 Keynote 幻灯片曾经迷倒多少 Windows 用户了。向笔者推荐这部电影的好朋友了解到这些全是 Apple 技术的功劳时，拥有一台 Mac 就成为其人生梦想。 环保卫士的 Apple 之路 作为环保人士，Al Gore 对 Apple 的策略的影响也不容忽视。Apple 向来被各环保组织长期批评，即使 Apple 长年不断地改进这方面问题，但绿色人士依然不买帐。哪怕在稍后的 2007 年，也仍有包括 GreenPeace 在内的七十多个组织联名写信给 Al Gore，敦促 Apple 更重视环境问题，信中指责 Apple 仍在大量使用 PVC 和 BFRs 等对环境有害的材料，也不注重对自家产品的回收。由于 Al Gore 是 Apple 董事会成员，使得这个问题受到了 Apple 的广泛关注。Apple 在 2007 年后史无前例地迈开大步，大力推广环保计划（要求全世界的 IT 制造商们逐步弃用 PVC 等有毒的化学用品进行生产），让 Apple 一跃成为注重电子产品环境保护问题的领头羊。 从制造材料上，2007 年 8 月发布的 iMac 成为分水岭。这款产品的设计主要使用可完全被回收的玻璃屏和铝外框，减小了塑料等不环保物质的使用，此后苹果一发不可收拾，把这项革命进行到底，从手机到笔记本，都全番设计。2008 年的 MacBook Air 引出的 Unibody 技术是这场革命的代表产品，不但在外观上还是工程上做到极致，在环保上更是让各绿色组织无可挑剔。 在造势上，Apple 现在每项主要产品的都有“环境”的标签页，从制造、运输、耗电、回收等性能情况分产品详细列出。Apple 甚至在包装上都动足脑筋，尽量减少每个产品的包装，使得同一架飞机可以运输更多的产品，从而在运输相同数量产品的情况下减少飞机温室气体的总排放量。 Mac OS X 的各项节电功能的开发更是不用说了。休眠、调整空闲时的屏幕亮度、硬盘转速等常规功能自然越做越好。而系统的多项技术能使程序更优地分配使用中央处理器和显示卡。甚至系统还能在用户打字时，每两键之间的空隙减少处理器的占用从而节省击键之间的功耗，这使得 Mac OS X 不但更节约能源，笔记本的电池使用时间也不断提高。而这一切的变化，和 Al Gore 似乎都有着千丝万缕的联系。 由于《An Inconvenient Truth》中的讲话让 Al Gore 的观点深入人心，同时也对美国政府在京都议定的决策产生重大的压力，挪威诺贝尔委员会决定把 2007 年的诺贝尔和平奖颁给了 Al Gore，以表彰其在全球环境问题方面的努力，同时苹果的主页上全版刊发新闻，以示祝贺。贺词如下： Al has put his heart and soul, and much of his life during the past several years, into alerting and educating us all on the climate crisis. We are bursting with pride for Al and this historic recognition of his global contributions. (Al Gore 在过去几年殚心积虑，全身心地投入对公众关于气候危机的警示和教育中。我们为他这次所得的荣誉和他全球性贡献的历史性承认感到无比自豪。） 或许，由于 Al Gore 在计算机领域的一贯低调（他也是 Google 的高级顾问），他在这些企业的工作很少被报道出来，但是他在政界的跨界身份是显而易见的。Al Gore 在他的人生道路将何去何从，我们不得而知，但是从各种媒体信息的披露可以看出，Al Gore 对计算机事业的热衷，对环保问题的投入，可能是美国历任领导人中最突出的。 Mac OS X 背后的故事（五）Jean - Marie Hullot 的 Interface Builder 神话 Interface Builder，是用于苹果公司 Mac OS X 操作系统的软件开发程序，Xcode 套件的一部分，于 1988 年创立。它的创造者 Jean-Marie Hullot 自称是“一个热爱旅行、充满激情的摄影师”，本篇分享 Hullot 热爱技术的那一面——创造 Interface Builder 的过程。因势而动 1981年， Jean-Marie Hullot 拿到巴黎第十一大学的计算机科学博士资格后，开始了法国国家信息与自动化研究所（INRIA）的研究生活。 Jean-Marie Hullot 的名字似乎不为大众所熟知，但他设计的 Interface Builder 却深入人心，创造了一个个软件神话。 20 世纪 70 年代初，正是面向对象程序设计开始走上历史舞台的时期。许多现代计算机技术的诞生地 Xerox PARC（施乐帕洛阿尔托研究中心）的 Alan Kay、Dan Ingalls、Ted Kaehler 、Adele Goldberg 等人，从 1969 年开始研发一款面向对象的程序语言 Smalltalk，并于 1980 年正式公布。这是一个完整地实现面向对象范型的编程套件，包含了一种面向对象的程序设计语言、一种程序设计库和一个应用开发环境（ADE）。 虽然当时的机器跑得巨慢无比，但 Smalltalk 先进的思想对其他众多的程序设计语言（Objective-C、Actor、Java 和 Ruby）的产生起到了极大的推动作用，对计算机工业界的发展产生了非常深远的影响。我们将会在今后介绍 Objective-C 时，详细介绍 Smalltalk 及其对 Objective-C 的影响，这里先一笔带过。 Smalltalk 的发布在业界一石激起千层浪，也给 Jean-Marie Hullot 幼小的心灵带来了巨大的震撼。他立即明白了面向对象思想所代表的先进生产力，一定会改变今后数十年的程序设计流程，他毫不犹豫地成为面向对象编程模式的早期粉丝。 SOS 的助力 那时，Jean-Marie Hullot 使用早期的 Macintosh 计算机进行开发。不过他很快就和其他开发者一样，发现虽然 Mac 的用户界面做得不错，但开发程序实在是太糟糕了。他说：“当 Macintosh 被发明出来时，计算机和先前就大不一样了，你至少需要花 60%~70% 的时间在用户界面部分的代码上。”在 Macintosh 被发明之前，用户界面是相当简单的，只需要在命令行下面打一串字符，计算机就会回应出一行行的信息。所以在那个时代，开发者完全不需要专注于用户界面。而 Mac 一经发布，随之而来的众多的窗口和菜单，让整个世界都不一样了。虽然对于使用最终产品的用户而言是简单方便的，但对于码工来说简直是个噩梦。每次他们需要一个窗口或者菜单，都要从零开始构建。 聪明的 Hullot 开始动脑筋改进 Mac 编写用户程序难的现状。他开发了一个程序，有点像现在 Windows 系统中的“画板”。一侧的工具条，是类似菜单这样的大量可重用的对象；而另一侧，则是程序员想构建的用户程序界面。只要把工具条上的工具拖放到程序界面中，那么类似“打开”、“打印”等相关的功能，就可以被添加到用户界面中。事实上，这个程序，是最早的一批能通过鼠标把控件拖入界面设计窗口实现相应功能的商业程序，是用户界面设计软件的先驱。 这个跨时代的发明被称作 SOS，用 Lisp 语言编写【注：What are we going to called this thing 中认为此时就是 Interface Builder，但据 The NeXTonian 等多处资料表明，在 Steve Jobs 见到以前，该程序名为 SOS】。当时，ExperTelligence 开发了一种叫做 ExperLisp 的方言，SOS 即用此语言写成【注：http://en.wikipedia.org/wiki/Interface_Builder 】。 此时 Hullot 忽然意识到，他设计的东西事实上很强大，其重要性简直可以和 Smalltalk 这样的发明相比——Smalltalk 让开发者尝到了面向对象语言的甜头，而 SOS 则是直接把对象放到了开发者手边。有了这么拽的东西，Hullot 意识到如果他只在研究所窝着，那只能让十几个人享受这一成果，而如果他跳槽，把这个工具公开，那对天下的码工来说可是大福音。 诞生之源 经过不断努力，Hullot 找到了一个值得推销自己发明的好地方——剑桥的苹果大学联盟（Apple University Consortium）。这个苹果和大学合作的组织看到 Hullot 的创作后反响很好，就推荐他去见 Jean-Louis Gassee。 Jean-Louis Gassee 是个法国人，时任苹果开发研究院主任，见到 SOS 后也认为这是个好东西，便说服他去美国闯一闯。经过几次的鼓励和推荐，加上美国对 Hullot 来说又不陌生，于是他就买了机票跳上飞机就奔赴美国。 不过当 Jean-Marie Hullot 来到美国加州苹果总部时，他却认为这不是一个工作的好地方——苹果已经是一个很庞大的企业，很难再有所创新发展。他最终决定不留在那儿，转而在美国寻找一个能把这个产品卖出去的人。四处推销之后，找到他用来写 SOS 的 Lisp 解释器的生产商，就是刚才提到的位于 Santa Barbara 的软件公司 ExperTelligence。 事实上，当时的 ExperTelligence 正在寻找合作商卖自已的 Lisp，而 Hullot 也在找合作商卖自已的 SOS，两者一拍即合，随即打电话给 NeXT，共同推销自家的产品。 NeXT 在 Palo Alto 总部的产品市场部人员接待了 Jean-Marie Hullot 和两位来自 ExperTelligence 的员工，被 SOS 的理念镇住，遂打电话请 Steve Jobs 下来看。Jean-Marie Hullot 像复读机一样又把自己的大作秀了一遍。老谋深算的 Steve Jobs 事实上早就看中了 SOS，但他对 ExperTelligence 的 Lisp 一点兴趣都没有。所以他装作对这场演示毫无兴致【注：这有很多引用该文的翻译译错，原文说 nonplussed，字面意思为惊异，但在美国非正式表述中，此字表毫无兴致】，挥挥手就把这三个人打发走了。 但当他们一行人走到停车场时，Steve Jobs 让他手下把 Hullot 追了回来，当他只身回到 NeXT 总部时，发现 Steve Jobs 正恭敬地等着他。 “我想要你计算机上那个程序”【注：http://rixstep.com/2/0/people/ 】，Steve Jobs 说道：“你大概什么时候能开始给我们工作？” Hullot 回答说自己翌日就要离开去度假。 “好吧，我两周后给你打电话，”Steve Jobs 说。 “不行，老乔”，Hullot 表示：“我不游美国，我可要环游欧洲，你七个礼拜后再打给我吧。” Steve Jobs 虽然一骨子傲气，但他明白一个简单的道理：21世纪最缺的是什么——是人才！即使 Jean-Marie Hullot 玩起了大牌，这电话自然还是要打的。Hullot 刚一度完假回来，Steve Jobs 的电话就如期而至。 如此三顾茅庐般的热情，把 Jean-Marie Hullot 感动得第二天就登上了去美国的飞机。合约签了半年，但实际上他最终在 NeXT 整整待了十年。在 NeXT 工作期间，他使用 Objective-C 和 NeXTSTEP 框架重写了 SOS，命名为 Interface Builder。由此，Interface Builder 成为 NeXT 集成开发环境 Project Builder 标准套件之一。 进阶与探索 Interface Builder 和 SOS 一样，提供了一个工具箱，包含一系列用户控件对象。工具箱并不是官方定死的，而是可以任意扩展的，比如如果用户想使用类似 Safari 中的 toolbar，而这不是官方提供的，则下载第三方的 PSMTabBar 即可实现，甚至连 Cappuccino 这样的网页框架也可以用 Interface Builder 来完成设计。开发者只要把控件比如菜单和文本框拖入项目文件就能完成用户界面设计，节省了几乎所有和控件放置有关的代码。 开发者拖拽鼠标，将控件可提供的动作（IBAction）和另一个对象的接口（IBOutlet）连在一起， 则建立了一个绑定。这样，一旦动作被激发（比如用户点了按钮），那接口中相应的方法则会被执行。所以，大量对象关联的代码也能被省去。 有了这样的模式后，Interface Builder 和 Cocoa 可以比后来出现的 Microsoft Visual Studio 或 Qt Designer 等软件走得更远——只要是对象，Interface Builder 就能够操控它们，不需要一定是一个界面的控件。比如，数据库的数据源、队列等，都可以在 Interface Builder 中连接起来，于是很多原本需要上千行的复杂应用（比如用来显示、修改企业中职工姓名、部门、电话、地址、头像等信息 SQL 数据库的用户界面程序），数分钟内就可以写完，不用一行代码。不信？让 1992 年的 Steve Jobs 亲自做给你看【注：http://www.youtube.com/watch?v=j02b8Fuz73A ， 第 23 分钟～第 29 分钟】。 NeXT 被 Apple 收购后，苹果把下一代操作系统建立在 NeXTSTEP 的基础上。Objective-C 和 Cocoa 被作为主要框架，而 Interface Builder 和 Project Builder 也因此受到重用。就官方的工具箱而言，支持 Objective-C/Cocoa、Carbon 的 HIToolbox 和 WebObject。 2008 年 3 月 27 日，苹果发布首个 iPhone SDK，设计 Cocoa Touch 界面的，也正是 Interface Builder。可以说，Interface Builder 一直随着公司产品的发展而不断拓新。 Jean-Marie Hullot 是在 NeXT 被收购时进入苹果的。Steve Jobs 令他率领在法国的一个小团队，秘密为 Mac OS X 10.2 开发一个办公软件。以往这样量级的程序，都是由苹果加州总部的大班人马完成。而这次，为了向世人表明他的 Interface Builder 有多强大，iCal 横空出世，展示复杂的界面元素（日历、可拖拽的任务、五花八门的分类）和诸多功能（网络同步、Apple Script 脚本控制）可以用相当快速的时间内开发出来【注：http://www.appleinsider.com/articles/07/10/17/road_to_mac_os_x_leopard_ical_3_0.html&amp;page=2 】。 最后，在 iCal 小组打完酱油的 Jean-Marie Hullot 荣升苹果软件开发部首席技术官。 Project Builder 在 Mac OS X 10.3 时被重命名为现在大家所熟知的 Xcode。Xcode 3 以前，Interface Builder 使用一种名为 nib 格式的二进制文件格式。不过由于 nib 不能用肉眼读，也不方便使用版本管理工具来管理，所以 Xcode 3 开始新加入一种名为 xib 的文本文件格式，最后再在项目编译阶段输出为 nib 格式。和产生静态界面布局代码的工具（如 MSVC、QtDesigner、 Delphi 等类似的软件）很不同，nib 是不被转译成相应 Objective-C 代码的。用户程序执行时，nib 文件被读入，解包，并且唤醒【注：awake，即载入 nib 会自动调用程序中 awakeFromNib 方法】，所以 nib 文件是在运行时动态加载的。 长期以来，Xcode 环境和 Interface Builder 是两个独立但相互工作的程序。而 2010 年释出的 Xcode 4 预览版中，Xcode 和 Interface Builder 合二为一，成为一个一体化的编程环境。所以现在，开发者甚至可以只用鼠标在用户界面和代码间来回拖拽就能完成，这样一来 Interface Builder 对用户代码的解释也比先前更正确。比早期分离的程序使用起来确实方便很多。 当然，一个负面的影响是，这样用一体化集成开发环境写程序，往往会发现屏幕空间是不够的，所以像我这样用 11 寸 Air 或者 13 寸 Macbook Pro 的人，出去打招呼都不好意思说自己是做 Mac 开发的。下一个海阔天空 在而后的岁月里，Interface Builder 创造了一个又一个应用软件神话，小到官方教程中的汇率计算器，大到苹果所有的家用、专业软件，都由 Interface Builder 完成。 在风起云涌的 1989 年，欧洲核子研究组织（CERN）工作的科学家 Emilio Pagiola 忽悠经费，买来研究所的第一台 NeXT 计算机——当时 NeXT 计算机在 CERN 可是个新鲜事物——那里的科学家们纷纷前来把玩，普通青年发现里面有全本的韦氏词典，并可自动检查用户输入的拼写错误，技术青年发现它跑的是 Unix 系统，还有一个可读写的光驱，文艺青年更是发现里面居然预装了莎翁全集。不过毕竟像 Emilio Pagiola 这样忽悠巨款买 NeXT 机器的青年不多，所以大家围观完了，也就回去该干嘛干嘛了。 但 Tim Berners-Lee 和别人不一样，他不仅围观了那台计算机，还看到了 Jean-Marie Hullot 设计的 Interface Builder，研究了 Objective-C，发现了面向对象编程范式开发环境的最高成就。这情景让他心中漾起了巨大的波澜，最终化为激情澎湃的投入，汇成了一行行面向对象的代码，一泻千里，奔向未来。 一年后，世界首个 HTTP 服务在 CERN 的 NeXT 计算机运行起来，而使用 Objective-C 和 Interface Builder 所编写的超文本语言编辑器兼浏览器同步发行。他给这个主从式架构起了个好听的名字——World Wide Web（万维网）。 Mac OS X 背后的故事（六）上善若水 Aqua 是 Mac OS X Public Beta 全新用户界面的名字，英文中为水的词根，寓意以水为灵感，精心设计。Steve Jobs 曾介绍说，Aqua 的设计是如此之美好，初次见它甚至有想亲吻的冲动。本篇 Cordell Ratzlaff 引发的 Aqua 革命（上）介绍的是 Aqua 的起源和来历，在下篇中，我们将展示 Aqua 的具体设计过程。 “Mac OS 的图形界面就是你们那么业余的人设计的吗？” Steve Jobs 开门见山地问。 包括 Cordell Ratzlaff 在内的设计师们怯怯地点头称是。“你们就是一群白痴！” Steve Jobs 骂道。 这个场景发生在 Steve Jobs 回归不久的图形界面组组会上，前文提到的骂人的话，是他送给图形界面设计组的见面礼。【注：参见 http://www.cultofmac.com/how-mac-os-x-came-to-be-exclusive-10th-anniversary-story/87889 ，How Mac OS X Came To Be，Leander Kahney】 不进则退的局面 Mac OS 曾是图形界面设计的先驱。 从 System 1 开始，Mac 就打破了字符终端的模式，使用图形界面和用户交互设计。但自 System 1 到 System 7，10年过去了，界面却始终没有显著的变化。设计组一直认为，为尊重用户的习惯，定下的规矩不要轻易改动。但同时，Microsoft 的变化可以说是天翻地覆，从黑屏的 DOS，到全屏幕的 Windows 1，再到成熟的 Windows 3，最后演变到奠定当今 Windows 界面基础的炫丽多彩的 Windows 95。用当时的眼光来看，这个变化是相当惊人的。由于因循守旧，Mac OS 在界面设计上从领先掉到了最后。旧的界面原语，一成不变的界面风格，让 Mac OS 的图形界面在 Windows 前显得黯然无光。【注：参见 http://vimeo.com/21742166 】 于是，在图形界面组的组会上，Steve Jobs 抨击了老 Mac OS 界面的各种不是——几乎所有的地方都被骂了一遍。众矢之的是各种打开窗口和文件夹的方式。在 Mac OS 中有至少 8 种打开窗口和访问文件夹的方式，如弹出菜单、下拉菜单、DragStrip、Launcher、Finder 等不同的程序。 Cordell Ratzlaff 作为主管，他一开始担心是不是会被 Steve Jobs 炒掉（传闻说 Steve Jobs 刚进入苹果时最爱炒人，经常会发生一些“神奇”的情况，比如有员工和他一同进了电梯，等一同出电梯时，该员工已被炒掉）。不过批评大会进行到第 20 分钟时，Cordell Ratzlaff 转为淡定，因为他意识到如果 Steve Jobs 要炒他，不用废那么多话，早就可以动手了。 其实 Cardell Ratzlaff 是 Apple 内部较早意识到小组设计不思进取的人之一。他意识到苹果有三个重要的设计问题【注：参见 Designing Interactions 第二章 My PC 附录访谈】。第一、Apple 的很多界面语言不明确。例如，在老 Mac OS 中，删除文件的动作是把文件图标拖到废纸篓里，但当磁盘和光盘弹出时，居然也是把图标拖到废纸篓里。第二、老 Mac OS 不会对问题进行变通，如果有几个图标同时显示，窗口还容易操作，但如果有几十个图标或窗口，以相同的方式显示出来，那么在繁杂的页面中找寻所需内容，对使用者则是巨大的挑战。第三、Mac OS 的界面过于古板，看上去还是停留在 Windows 3.0 阶段。总之，当时的 Mac OS 已经不能代表先进的生产力，也不能代表科技的前进方向，更不能让广大用户得到更多的利益。在 Cardell Ratzlaff 看来， Mac OS 的界面面临不进则退的重大困局，非改不可。 Cordell Ratzlaff 的试水 收购 NeXT 以后，Apple 开始考虑如何把 NeXTSTEP 作业系统变为下一代的 Apple 操作系统，但界面设计组的倦怠又浮出水面。设计组认为，这是一个浩大的工程，所以他们决定照着 Mac OS 8 的样子改 NeXTSTEP 的代码，把 NeXTSTEP 改成 System 8 的样子。这并不困难，组里只需一个人就能完成这项任务，这人的工作极其无聊——像小孩子描红模，把新界面的样子临摹得和老界面一模一样。事实上，当 Apple 释出 Rhapsody 和 Mac OS X Server 初版时，经典 Mac OS 的界面已经被学得惟妙惟肖了。 Cordell Ratzlaff 认为这种混搭，是一个极其让苹果丢颜面的事情。所以，除了那个搞山寨的人以外，他召集其他人做新界面设计的图样。而由于 NeXTSTEP 具有强大的图形处理和动画能力，因此很多新的图样是在新系统上完成的。 Apple 将“What’s not a computer!”（看起来不是电脑的电脑）的概念应用在硬件外观上，设计出具有浪漫主义气质，半透明“果冻” 式且具有艺术美感的 iMac，这成了 Aqua 设计灵感的来源。 20世纪 90 年代初，Apple 和 Microsoft 的操作系统都素面朝天，色调简单，统一的矩形窗口。到 1997~1998 年，Apple 的硬件外观设计取得重大进展：由后来成为金牌设计师的 Jonathan Ive 领衔，设计出具有浪漫主义气质、五彩斑澜的、半透明外壳、具有曲线美感的 iMac，这个设计成为 Cordell Ratzlaff 和他的同事们设计的灵感，他们马上就作出了一个全新的界面图样来。【注：参见 http://en.wikipedia.org/wiki/IMac_G3 】 与此同时，Cordell Ratzlaff 着手解决前文提到的三个设计问题。第一、他提出了一个叫“实时状态”的概念。当用户拖动文件时，废纸保持原样，而如果拖动的是磁盘，那废纸篓的图标变成“弹出”的图标。第二、窗口的问题统一采用动画加以解决。比如窗口的最小化和还原都配有动画，告诉用户窗口的来去方向。当 Dock 项目有所增减时，项目长度和元素也会随之改变。第三、Mac OS 一改死板面孔，呈现多彩的、小清新的图形界面，所有尖锐的直角都被打磨成圆弧，并且有像 iMac 外壳一样半透明的菜单。当时有评论指责 Apple 的设计太卡通缺乏权威感，其变化之大可见一斑。【注：参见 http://www.aresluna.org/attached/files/usability/papers/onethousandsquarepixelsofcanvas.pdf ，One thousand square pixels of canvas On evolution of icons in graphical interfaces by Marcin Wichary 第五页】 Cocoa 之父 Bertrand Serlet，作为 Cordell Ratzlaff 的上司，对新界面很满意。但当时，他们认为这个新界面实现起来难度很大，既没有时间也没有资源把这个想法在 Mac OS X 中付诸实现。于是先前那位孤独的照葫芦画瓢的设计者只好继续工作。 Aqua 只是个设想（PS 出来的图样＋模拟出来的视频），还不是能用的代码。 Steve Jobs 的怒火和 Aqua 的源头 几个月以后，Apple 举办了一个所有开发小组参加的长达两天的汇报大会。Cordell Ratzlaff 汇报的时间被排在两天的最后压轴出场。大多数工程师对这长达两天的大会报告早已疲倦，感叹 Mac OS X 剩下的的工作很艰巨，认为发布遥遥无期。于是，Cordell Ratzlaff 报告成了整个报告会的最大笑场，所有工程师使出咆哮体来评价这个工作——“啊！！！你看这新界面多出位啊！！！有没有有没有！！！居然用的透明通道！！！还搞个实时的动画！！！你难道不知道你这些永远是天方夜谭不可能完成吗？？？我们工程师伤不起啊伤不起！！！”这个新设计就这样在所有 Apple 顶级工程师的鄙视下被废了。 无奈于此，只好无聊地让那位开发者继续复制全套经典 Mac OS 界面，而当 Steve Jobs 召集所有设计组负责人时，这个山寨版 Mac OS 的展示把 Steve Jobs 看得情绪激动，就发生了文章开头的那一幕。 Cordell Ratzlaff 前来解释压轴报告的尴尬局面，暗示千里马常有而伯乐不常有的处境，还让 Steve Jobs 观摩了他的杰作。果然 Steve Jobs 看了这几张图例后大为惊异，拍着 Cordell Ratzlaff 的肩说：“很好！很强大！”然后让设计组不惜一切代价做成试验品。 在加班奋战的三周后，设计组用 Macromedia Director 完成了一个试验品。Steve Jobs 亲自来 Cordell Ratzlaff 办公室视察了一下午。结果是他激动地握着 Cordell Ratzlaff 的手，吐露心声：“你是苹果里我见到的第一个智商是三位数字的人。”得到了 Steve Jobs 的支持，Apple 的 Mac OS X 开发团队，更加紧密地围绕在以 Cordell Ratzlaff 为核心的界面设计概念周围，开发操作系统。 有缘千里来相会，无缘对面不相识。Steve Jobs 和 Cordell Ratzlaff 算是相见恨晚。这样由 Cordell Ratzlaff 主导的新界面，在 Steve Jobs 的支持下，横扫一切困难，成为新版操作系统界面的最大亮点。 从这时到 Steve Jobs 正式在舞台上秀他的 Mac OS X Public Beta，还有 18 个月。此时，系统界面革命的旅程已经开始，一道神秘的天光射向 Infinity Loop，千古杰作 Aqua 就要在这里诞生，其光辉历程，我们下篇再谈。 Mac OS X 背后的故事（七）上善若水下——Cordell Ratzlaff 引发的 Aqua 革命 在前一节中讲到，Cordell Ratzlaff 新界面方案得到 Steve Jobs 的高度肯定，Steve Jobs 让各开发组紧紧围绕在界面设计组周围，共同建造 Mac OS X。此时，离 Mac OS X 第一个公共测试版的发布，仅有一年半时间。这时苹果的设计构想，还仅仅是个概念，在本篇中我们将展示 Aqua 的具体设计过程。 设计与软件的融合 开发分设计和软件两条路并行走，“两手抓，两手都要硬”。 设计是个有趣的领域。有些人认为，设计就是产品的外观看上去什么样。但其实，如果细想一下，你会发现设计其实是有关产品如何工作的学问。 ——Steve Jobs 首先，苹果定下计划，并规划整个界面设计元素的方案，把设想通过可操作性强的材料让工程师来实现。 Cordell Ratzlaff 每周都要和 Steve Jobs 开会，向他展示界面设计小组最新成果。任何大家现在见到的各界面控件，如菜单、按钮、进度条、Steve Jobs 都一一过目，毫不马虎。针对每一个控件，Cordell Ratzlaff 会要求拿出多套方案来，让 Steve Jobs 选出他中意的。Steve Jobs 也会提出各种他自己的见解和改进建议，而 Cordell Ratzlaff 则会根据这些回馈不断修改，直到 Steve Jobs 满意为止。 与此同时，软件工程师也以越来越重的比例加入到这个设计行列中。 图形界面设计小组使用的设计软件是 Macromedia Director。它能做出演示用的动画，可以演示打开、关闭窗口、下拉菜单等模拟效果，但这些并不是可供用户使用的最终软件。软件工程师需要把图形界面设计师的设计，变为一行行代码，运用到 Mac OS X 中。所以每次会议的 Macromedia Director 动画演示机旁，还会有一台计算机，预装了软件工程师转换的代码。当工程师们向 Steve Jobs 展示最新代码如何工作时，Steve Jobs 会身体前倾，鼻子快贴到荧幕上，观察细微到“像素级别”来比较软件的表现和之前的设计是否完全一致。如果他有发现任何细微的差错，一阵类似“你们全是一帮白痴”的腥风血雨就会在办公室中展开。 设计整套方案是一个令人难以置信的漫长过程，尤其是遇到追求完美的 Steve Jobs。Mac OS X 中有一个控件叫滚动条（NSScroller）。当需要显示的内容长于当前控件大小时就会出现滚动条，可上下翻阅内容。这是一个非常不起眼的控件，大多数时间，用户甚至注意不到它的存在，甚至在十年后的今天它都被默认不显示了（关于 Lion 图形界面的改动受 iOS 思潮的影响我们今后会提到）。但哪怕是这种不起眼的细节，Steve Jobs 都偏执地当个大项目来做。Mac OS X 的界面设计是有史以来最复杂的一个，需要考虑诸多因素——比如所在窗口的活动与否，都会影响这个控件的颜色等属性。就滚动条而言，箭头的大小、位置的变化、颜色的启用等全都是活动的属性，牵一发而动全身。一根看似简单得不能再简单的滚动条，设计组花了整整六个月来修改。 当时，Mac OS X 的用户界面有两个重大的设计目标：第一是让老用户没有压力地迁移过来，且倍感新界面的好用；第二是让那些从未摸过 Mac 的人尽快上手，并称赞这界面很好很强大。所以，整个界面设计保留了老 Mac OS 界面元素的设计理念，但同时又对很多有问题的老设计进行了革新。比如，在老版 Mac OS 中，各种系统设置选项是隐藏在不计其数的系统扩展、控制面板，以及很多系统组件中的。用户要想联个网，要去五六个地方设网络、设 IP、设连接设密码，而在 Mac OS X 中，所有这些设置都被分门别类地规类到一个单一的程序——系统首选项（System Preferences），让用户“足不出户”，就能进行一切相关设置。 精简的狂热追求和大胆的设计创新 Apple 偏爱最简化的设计，而往往满屏的窗口让 Steve Jobs 忍无可忍。又酷又炫的 Dock 横空出世，巧妙地解决了这个问题。Dock 的设计源于 Mac OS X 的前身 NeXTSTEP，但在 Mac OS X 中完全被重写，并重定义了它的功能。Dock 提供用户一个放置常用软件图标、闲置窗口、文档的场所，Steve Jobs 说“任何东西都能被拉进 Dock”。但 Dock 真正神奇的，是它犹如多拉A梦的口袋，有无限的承载能力。当放入 Dock 中的东西变多时，它会自动把横向宽度变长、图标变小，可承载几十个窗口。当窗口缩入和还原时，都配有“精灵”一样的动画——在 Dock 的图标多的时候，每个图标很小，用户就很难找到需要的——灵动且放大动画可以让用户能快速地找到所需。 另外，起初版本的 Dock 中每个图标都是正方形的方块，被换成半透明的背景，看得人垂涎欲滴。这些经典的设计，影响了整整一代图形界面设计者，被各山寨界面抄了一遍又一遍，甚至又活在当今的 Ubuntu Linux 的 Unity 和 Windows 7 中。 Apple 追求清爽甚至到了发疯的地步，在最初版的 Mac OS X Public Beta 中，每个窗口有一个按钮，只要按下，除了当前窗口外，其它一切都会飞入 Dock。因此，只要一键，“整个世界都清静了”。而在后来每个版本的 Mac OS X 中，都有大的更新来防止窗口或其他界面元素的堆积。10. 4 时代的 Expose，10. 5 时代的 Stack 和 Spaces，10.6 时代的 Expose 和 Dock 相结合双管齐下，到 10.7 时代的 Mission Control，都是用来解决果面精简这一个问题的。 而很多传统的界面控件也被赋予了新的含义。比如 Steve Jobs 觉得，“最大化”一个窗口没有实际意义，而且把整个窗口最大化，也会挡住后面的窗口（直到 2011 年，Apple 用“全屏”来重新定义传统的“最大化”）。而 Mac OS X 没有所谓的“最大化”，取而代之的是自动计算后调整窗口到所需大小的“最适化按钮”。而关闭一个窗口的含意也不该是关闭一个程序，而只应是结束目前的内容。Apple 的许多设计都格外具有魄力，完全重写了界面设计的教科书。当然，有许多地方 Apple 确实做得矫枉过正，比如 Apple 一直是我见过的只有拖住右下角才能改动窗口大小的唯一系统。这个置用户于不顾的狂妄设计，一直在十年后发布的 Lion 中，才得以改变。 Steve Jobs 一直是界面设计的重要顾问。他有时候会提出一些看似稀奇古怪的意见，但往往最终又被证明是好的。比如，有一次他在会上指出，窗口左上角的“关闭”、“最小化”、“最适化”三个按钮的颜色都是一样的灰色，不容易区分他们。他建议把三个按钮变成交通灯的颜色，并且当鼠标移到附近时，显示出相应的图形指示。当 Cordell Ratzlaff 一群人听到这个主意后面色大变，认为简直是计算机图形设计史上最好笑的段子——谁会把电脑当交通灯使啊。不过改完后，他们对 Steve Jobs 心悦诚服——“红灯给用户一个终止的警示，这个窗口要被关掉；黄灯表示这个窗口要被放入等待队列，以便以后再通行；最适化则是给这个窗口大开绿灯”——这样高明的比喻，使 Cordell Ratzlaff 对 Steve Jobs 崇拜得五体投地。 18个月转瞬即逝，“你们就是一群白痴”的骂声依旧清晰，而此时的 Mac OS X 的图形界面，已今非昔彼。 “语静声息。我走上舞台。依着那打开的门，我试图探测回声中，蕴涵着什么样的未来。”（北岛翻译的帕斯捷尔纳克的《哈姆雷特》）。 18 个月后的 2000 年 1 月，新世纪的钟声刚刚敲响，Steve Jobs 镇定地走上 MacWorld 大会的舞台，独领风骚的新世纪的经典大作 Aqua，此时，就要被他揭开帷幕。 Mac OS X 背后的故事（八）三好学生 Chris Lattner 的 LLVM 编译工具链 2011年 12 月 3 日，LLVM 3.0 正式版发布，完整支持所有 ISO C++ 标准和大部分 C++ 0x 的新特性， 这对于一个短短几年的全新项目来说非常不易。 开发者的惊愕 在 2011 年 WWDC（苹果全球开发者大会）的一场与 Objective-C 相关的讲座上，开发者的人生观被颠覆了。 作为一个开发者，管理好自己程序所使用的内存是天经地义的事，好比人们在溜狗时必须清理狗的排泄物一样（美国随处可见“Clean up after your dogs”的标志）。在本科阶段上 C 语言的课程时，教授们会向学生反复强调：如果使用 malloc 函数申请了一块内存，使用完后必须再使用 free 函数把申请的内存还给系统——如果不还，会造成“内存泄漏”的结果。这对于 Hello World 可能还不算严重，但对于庞大的程序或是长时间运行的服务器程序，泄内存是致命的。如果没记住，自己还清理了两次，造成的结果则严重得多——直接导致程序崩溃。 Objective-C 有类似 malloc/free 的对子，叫 alloc/dealloc，这种原始的方式如同管理C内存一样困难。所以 Objective-C 中的内存管理又增加了“引用计数”的方法，也就是如果一个物件被别的物件引用一次，则引用计数加一；如果不再被该物件引用，则引用计数减一；当引用计数减至零时，则系统自动清掉该物件所占的内存。具体来说，如果我们有一个字符串，当建立时，需要使用 alloc 方法来申请内存，引用计数则变成了一；然后被其他物件引用时，需要用 retain 方法去增加它的引用计数，变成二。当它和刚才引用的物件脱离关联时，需使 release 方法减少引用计数，又变回了一；最后，使用完这个字符串时，再用 release 方法减少其引用计数，这时，运行库发现其引用计数变为零了，则回收走它的内存。这是手动的方式。 这种方式自然很麻烦，所以又设计出一种叫做 autorelease 的机制（不是类似 Java 的自动垃圾回收）。在 Objective-C 中，设计了一个叫做 NSAutoReleasePool 的池，当开发者需要完成一个任务时（比如每开启一个线程，或者开始一个函数），可以手动创立一个这样的池子， 然后通过显式声明把物件扔进自动回收池中。NSAutoReleasePool 内有一个数组来保存声明为 autorelease 的所有对象。如果一个对象声明为 autorelease，则会自动加到池子里。如果完成了一个任务（结束线程了，或者退出那个函数），则开发者需对这个池子发送一个 drain 消息。这时，NSAutoReleasePool 会对池子中所有的物件发送 release 消息，把它们的引用计数都减一 ——这就好比游泳池关门时通知所有客人都“滚蛋”一样。所以开发者无需显式声明 release，所有的物件也会在池子清空时自动呼叫 release 函数，如果引用计数变成零了，系统才回收那块内存。所以这是个半自动、半手动的方式。 Objective-C 的这种方式虽然比起 C 来进了一大步，我刚才花了几分钟就和读者讲明白了。只要遵守上面这两个简单的规则，就可以保证不犯任何错误。但这和后来的 Java 自动垃圾回收相比则是非常繁琐的，哪怕是再熟练的开发者，一不小心就会弄错。而且，哪怕很简单的代码，比如物件的 getter/setter 函数，都需要用户写上一堆的代码来管理接收来的物件的内存。 经典教材《Cocoa Programming for Mac OS X》用了整整一章节的篇幅，来讲解 Objective-C 中内存管理相关的内容，但初学者们看得还是一头雾水。所以，在 2007 年 10.5 发布时，Objective-C 做出了有史以来最大的更新，最大的亮点是它的运行库 libobjc 2.0 正式支持自动垃圾回收，也就是由运行库在运行时随时侦测哪些物件需要被释放。听上去很不错，可惜使用这个技术的项目却少之又少。原因很简单，使用这个特性，会有很大的性能损失，使 Objective-C 的内存管理效率低得和 Java 一样，而且一旦有一个模块启用了这个特性，这个进程中所有的地方都要启用这个特性——因此如果你写了一个使用垃圾回收的库，那所有引用你库的程序就都得被迫使用垃圾回收。所以 Apple 自己也不使用这项技术，大量的第三方库也不使用它。 这个问题随 Apple 在移动市场的一炮走红而变得更加严峻。不过这次，Apple 和与会的开发者讲，他们找到了一个解决问题的终极方法，这个方法把从世界各地专程赶来聆听圣谕的开发者惊得目瞪口呆——你不用写任何内存管理代码，也不需要使用自动垃圾回收。因为我们的编译器已经学会了上面所介绍的内存管理规则，会自动在编译程序时把这些代码插进去。 这个编译器，一直是 Apple 公开的秘密——LLVM。说它公开，是因为它自始至终都是一个开源项目；而秘密，则是因为它从来没公开在 WWDC 的 Keynote 演讲上亮相过 。 一直关注这系列连载的读者一定还记得，在第二篇《Linus Torvalds 的短视》介绍 Apple 和 GPL 社区的不合时，提到过“自以为是但代码又写得差的开源项目，Apple 事后也遇到不少，比如 GCC 编译器项目组。虽然大把钞票扔进去，在先期能够解决一些问题，但时间长了这群人总和 Apple 过不去，并以自己在开源世界的地位恫吓之，最终 Apple 由于受不了这些项目组的态度、协议、代码质量，觉得还不如自己造轮子来得方便。”LLVM 则是 Apple 造的这个轮子，它的目的是完全替代掉 GCC 那条编译链。它的主要作者，则是现在就职于 Apple 的 Chris Lattner。 编译器高材生 Chris Lattner 2000年，本科毕业的 Chris Lattner 像中国多数大学生一样，按部就班地考了 GRE，最终前往 UIUC（伊利诺伊大学厄巴纳香槟分校），开始了艰苦读计算机硕士和博士的生涯。在这阶段，他不仅周游美国各大景点，更是努力学习科学文化知识，翻烂了“龙书”（《Compilers: Principles, Techniques, and Tools》），成了 GPA 牛人【注：最终学分积 4.0 满分】，以及不断地研究探索关于编译器的未知领域，发表了一篇又一篇的论文，是中国传统观念里的“三好学生”。他的硕士毕业论文提出了一套完整的在编译时、链接时、运行时甚至是在闲置时优化程序的编译思想，直接奠定了 LLVM 的基础。 LLVM 在他念博士时更加成熟，使用 GCC 作为前端来对用户程序进行语义分析产生 IF（Intermidiate Format），然后 LLVM 使用分析结果完成代码优化和生成。这项研究让他在 2005 年毕业时，成为小有名气的编译器专家，他也因此早早地被 Apple 相中，成为其编译器项目的骨干。 Apple 相中 Chris Lattner 主要是看中 LLVM 能摆脱 GCC 束缚。Apple（包括中后期的 NeXT） 一直使用 GCC 作为官方的编译器。GCC 作为开源世界的编译器标准一直做得不错，但 Apple 对编译工具会提出更高的要求。 一方面，是 Apple 对 Objective-C 语言（甚至后来对 C 语言）新增很多特性，但 GCC 开发者并不买 Apple 的帐——不给实现，因此索性后来两者分成两条分支分别开发，这也造成 Apple 的编译器版本远落后于 GCC 的官方版本。另一方面，GCC 的代码耦合度太高，不好独立，而且越是后期的版本，代码质量越差，但 Apple 想做的很多功能（比如更好的 IDE 支持）需要模块化的方式来调用 GCC，但 GCC 一直不给做。甚至最近，《GCC 运行环境豁免条款 （英文版）》从根本上限制了 LLVM-GCC 的开发。 所以，这种不和让 Apple 一直在寻找一个高效的、模块化的、协议更放松的开源替代品，Chris Lattner 的 LLVM 显然是一个很棒的选择。 刚进入 Apple，Chris Lattner 就大展身手：首先在 OpenGL 小组做代码优化，把 LLVM 运行时的编译架在 OpenGL 栈上，这样 OpenGL 栈能够产出更高效率的图形代码。如果显卡足够高级，这些代码会直接扔入 GPU 执行。但对于一些不支持全部 OpenGL 特性的显卡（比如当时的 Intel GMA 卡），LLVM 则能够把这些指令优化成高效的 CPU 指令，使程序依然能够正常运行。这个强大的 OpenGL 实现被用在了后来发布的 Mac OS X 10.5 上。同时，LLVM 的链接优化被直接加入到 Apple 的代码链接器上，而 LLVM-GCC 也被同步到使用 GCC 4 代码。 LLVM 真正的发迹，则得等到 Mac OS X 10.6 Snow Leopard 登上舞台。可以说， Snow Leopard 的新功能，完全得益于 LLVM 的技术。而这一个版本，也是将 LLVM 推向真正成熟的重大机遇。 关于 Snow Leopard 的三项主推技术（64位支持、OpenCL，以及 Grand Central Dispatch）的细节，我们会在下一次有整整一期篇幅仔细讨论，这次只是点到为止——我们告诉读者，这些技术，不但需要语言层面的支持（比如 Grand Centrual Dispatch 所用到的“代码块”语法， 这被很多人看作是带 lambda 的 C），也需要底层代码生成和优化（比如 OpenCL 是在运行时编译为 GPU 或 CPU 代码并发执行的）。而这些需求得以实现，归功于 LLVM 自身的新前端——Clang。 优异的答卷——Clang 前文提到，Apple 吸收 Chris Lattner 的目的要比改进 GCC 代码优化宏大得多——GCC 系统庞大而笨重，而 Apple 大量使用的 Objective-C 在 GCC 中优先级很低。此外 GCC 作为一个纯粹的编译系统，与 IDE 配合得很差。加之许可证方面的要求，Apple 无法使用 LLVM 继续改进 GCC 的代码质量。于是，Apple 决定从零开始写 C、C++、Objective-C 语言的前端 Clang，完全替代掉 GCC。 正像名字所写的那样，Clang 只支持 C，C++和 Objective-C 三种C家族语言。2007年开始开发，C 编译器最早完成，而由于 Objective-C 相对简单，只是 C 语言的一个简单扩展，很多情况下甚至可以等价地改写为C语言对 Objective-C 运行库的函数调用，因此在 2009 年时，已经完全可以用于生产环境。C++ 的支持也热火朝天地进行着。 Clang 的加入代表着 LLVM 真正走向成熟和全能，Chris Lattner 以影响他最大的“龙书”封面【注：见 http://en.wikipedia.org/wiki/Dragon_Book_ (computer_science)】为灵感，为项目选定了图标——一条张牙舞爪的飞龙。 Clang 一个重要的特性是编译快速，占内存少，而代码质量还比 GCC 来得高。测试结果表明 Clang 编译 Objective-C 代码时速度为 GCC 的 3 倍【注：http://llvm.org/pubs/2007-07-25-LLVM-2.0-and-Beyond.pdf 】，而语法树（AST）内存占用则为被编译源码的 1.3 倍，而 GCC 则可以轻易地可以超过 10 倍。Clang 不但编译代码快，对于用户犯下的错误，也能够更准确地给出建议。使用过 GCC 的读者应该熟悉，GCC 给出的错误提示基本都不是给人看的。比如最简单的： 12struct foo &#123; int x; &#125;typedef int bar; 如果使用 GCC 编译，它将告诉你： 1t.c:3: error: two or more data types in declaration specifiers 但是 Clang 给出的出错提示则显得人性化得多： 1t.c:1:22: error: expected ‘;’ after struct 甚至，Clang 可以根据语境，像拼写检查程序一样地告诉你可能的替代方案。比如这个程序： 12#include &lt;inttypes.h&gt;int64 x; GCC 一样给出乱码似的出错提示： 1t.c:2: error: expected ‘=’， ‘，’， ‘;’， ‘asm’ or ‘__attribute__’ before ‘x’ 而优雅的 Clang 则用彩色的提示告诉你是不是拼错了，并给出可能的变量名： 12t.c:2:1: error: unknown type name ‘int64′; did you mean ‘int64_t’?int64 x;^~~~~int64_t 更多的例子可以参考http://blog.llvm.org/2010/04/amazing-feats-of-clang-error-recovery.html 。 而同时又因为 Clang 是高度模块化的一个前端，很容易实现代码的高度重用。所以比如 Xcode 4.0 的集成编程环境就使用 Clang 的模块来实现代码的自动加亮、代码出错的提示和自动的代码补全。开发者使用 Xcode 4.0 以后的版本，可以极大地提高编程效率，尽可能地降低编译错误的发生率。 支持 C++ 也是 Clang 的一项重要使命。C++ 是一门非常复杂的语言，大多编译器（如 GCC、MSVC）用了十多年甚至二十多年来完善对 C++ 的支持，但效果依然不很理想。Clang 的 C++ 支持却一直如火如荼地展开着。2010 年 2 月 4 日，Clang 已经成熟到能自举（即使用 Clang 编译 Clang，到我发稿时，LLVM 3.0 发布已完整支持所有 ISO C++ 标准，以及大部分C++ 0x 的新特性。 这对于一个短短几年的全新项目来说是非常不易的。得益于本身健壮的架构和 Apple 的大力支持，Clang 越来越全能，从 FreeBSD 到 Linux Kernel ， 从 Boost 到 Java 虚拟机， Clang 支持的项目越来越多。 Apple 的 Mac OS X 以及 iOS 也成了 Clang 和 LLVM 的主要试验场——10.6 时代，很多需要高效运行的程序比如 OpenSSL 和 Hotspot 就由 LLVM-GCC 编译来加速的。而 10.6 时代的 Xcode 3.2 诸多图形界面开发程序如 Xcode、Interface Builder 等，皆由 Clang 编译。到了 Mac OS X 10.7，整个系统的的代码都由 Clang 或 LLVM-GCC 编译【注：http://llvm.org/Users.html 】。LLVM 周边工具 由于受到 Clang 项目的威胁，GCC 也不得不软下来，让自己变得稍微模块化一些，推出插件的支持，而 LLVM 项目则顺水推舟，索性废掉了出道时就一直作为看家本领的 LLVM-GCC，改为一个 GCC 的插件 DragonEgg。 Apple 也于 Xcode 4.2 彻底抛弃了 GCC 工具链。 而 Clang 的一个重要衍生项目，则是静态分析工具，能够通过自动分折程序的逻辑，在编译时就找出程序可能的 bug。在 Mac OS X 10.6 时，静态分析被集成进 Xcode 3.2，帮助用户查找自己犯下的错误。其中一个功能，就是告诉用户内存管理的 Bug，比如 alloc 了一个物件却忘记使用 release 回收。这已经是一项很可怕的技术，而 Apple 自己一定使用它来发现并改正 Mac OS X 整个系统各层面的问题。但许多开发者还不满足——既然你能发现我漏写了 release，你为什么不能帮我自动加上呢？于是 ARC 被集成进 Clang，发生了文章开头开发者们的惊愕——从来没有人觉得这件事是可以做成的。 除 LLVM 核心和 Clang 以外，LLVM 还包括一些重要的子项目，比如一个原生支持调试多线程程序的调试器 LLDB，和一个 C++ 的标准库 libstdc++，这些项目由于是从零重写的，因此要比先前的很多项目站得更高，比如先前 GNU、Apache、STLport 等 C++ 标准库在设计时，C++0x 标准还未公布，所以大多不支持这些新标准或者需要通过一些肮脏的改动才能支持，而 libstdc++ 则原生支持C++0x。而且在现代架构上，这些项目能动用多核把事情处理得更好。 不单单是 Apple，诸多的项目和编程语言都从 LLVM 里取得了关键性的技术。Haskell 语言编译器 GHC 使用 LLVM 作为后端，实现了高质量的代码编译。很多动态语言实现也使用 LLVM 作为运行时的编译工具，较著名的有 Google 的 Unladen Swallow【注：Python 实现，后夭折】、PyPy【注：Python 实现】，以及 MacRuby【注：Ruby 实现】。例如 MacRuby 后端改为 LLVM 后，速度不但有了显著的提高，更是支持 Grand Central Dispatch 来实现高度的并行运行。由于 LLVM 高度的模块化，很方便重用其中的组件来作为一个实现的重要组成部分，因此类似的项目会越来越多。 LLVM 的成熟也给其他痛恨 GCC 的开发项目出了一口恶气。其中最重要的，恐怕是以 FreeBSD 为代表的 BSD 社区。BSD 社区和 Apple 的联系一向很紧密，而且由于代码相似，很多 Apple 的技术如 Grand Central Dispatch 也是最早移植到 FreeBSD 上。BSD 社区很早就在找 GCC 的替代品，无奈大多都很差（如 Portable C Compiler 产生的代码质量和 GCC 不能同日而语）。 一方面是因为不满意 GCC 的代码品质【注：BSD 代码整体要比 GNU 的高一些，GNU 代码永无休止地出现各种严重的安全问题】，更重要的是协议问题。BSD 开发者有洁癖的居多，大多都不喜欢 GPL 代码，尤其是 GPL 协议第三版发布时，和 FreeBSD 的协议甚至是冲突的。这也正是为什么 FreeBSD 中包含的 GNU 的 C++ 运行库还是 2007 年以 GPLv2 发布的老版本，而不是支持C++0x 的但依 GPLv3 协议发布的新版本。因此历时两年的开发后，2012年初发布的 FreeBSD 9.0 中，Clang 被加入到 FreeBSD 的基础系统。 但这只是第一步，因为 FreeBSD 中依然使用 GNU 的 C++ STL 库、C++ 运行库、GDB 调试器、libgcc/libgcc_s 编译库都是和编译相关的重要底层技术，先前全被 GNU 垄断，而现在 LLVM 子项目 lldb、libstdc++、compiler-rt 等项目的出现，使 BSD 社区有机会向 GNU 说“不”，因此一个把 GNU 组件移出 FreeBSD 的计划被构想出来，并完成了很大一部分。编写过《Cocoa Programming Developer’s Handbook》的著名 Objective-C 牛人 David Chisnall 也被吸收入 FreeBSD 开发组完成这个计划的关键部分。 预计在 FreeBSD 10 发布时，将不再包含 GNU 代码。 LLVM 在短短五年内取得的快速发展充分反映了 Apple 对于产品技术的远见和处理争端的决心和手腕，并一跃成为最领先的开源软件技术。而 Chris Lattner 在 2010 年也赢得了他应有的荣誉——Programming Languages Software Award（程序设计语言软件奖）。]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 背后的故事（下）]]></title>
    <url>%2Fmacos%2Fstory2.html</url>
    <content type="text"><![CDATA[Mac OS X 背后的故事（九）半导体的丰收半导体的丰收（上） 在美国宾夕法尼亚州的东部，有一个风景秀美的城市叫费城。在这个城市诞生了一系列改变世界的奇迹：第一个三权分立的国家——美立坚合众国，就在第五街的路口诞生；举世闻名的费城交响乐团，1900年在市中心的 Academy of Music 奏响了他们的第一个音符。而写这篇文章时，我正坐在三十四街的宾夕法尼亚大学计算机系的一楼实验室，面前摆放着世界上第一台电子计算机——ENIAC。 1946年 2 月 14 日，ENIAC 问世，每秒可运行 5000 次加法运算或 500 次乘法运算，面积达 170 平方米，重约 30 吨，拉开了计算机处理器革命的序幕。这场革命是各处理器厂商长达数十年的竞赛，而摩尔定律从一开始就准确地预测了这场比赛的走势。根据摩尔定律，同样价格的集成电路上可容纳的晶体管数目，每隔约 18 个月便会增加一倍，性能也将提升一倍。但事实上，并无法用老路子来保持这个增长速度，因为会遇到包括能耗、散热等各种技术瓶颈。所以每隔几年就会有用来绕过这些瓶颈的新一代产品推出。如采用超纯量（superscala）、指令管线化、快取等。这些技术通过一定程度的高效并行来挖掘计算机处理器的速度所能达到的高度，以促使用户更新换代。 世界上第一台计算机 ENIAC，1946年 2 月 14 日诞生于宾夕法尼亚大学 和 66 年前的 ENIAC 相比，今天的处理器已有了质的飞越。而 21 世纪的前十年，我们更是见证了个人计算机处理器的三次重大革命——64位处理器、多核心和高效图形处理器在个人电脑出现。在这样的背景下，乔布斯在 2008 年 WWDC（苹果全球开发者大会）上，宣布下一代 Mac 操作系统 Mac OS X 10.6 将被命名为 Snow Leopard（雪豹）来适应硬件架构的革新。就在那天下午，Bertrand Serlet 在一场开发者内部讲座上透露，和先前两个发行版包含大量的新功能（10.4 Tiger 包含 150 个新功能，10.5 Leopard 包含 300 个新功能）不同，Snow Leopard 不含任何新功能，仅是对 Leopard 中诸多技术的重大更新，以使其在现代架构上更稳定、高效。 在这十年的最后一年，2009 年 8 月 28 日，苹果发布了 Mac OS X 10.6 来有效地支持这三项技术，而本文将为读者介绍其对应的三项软件技术——64位架构、Grand Central Dispatch，以及 OpenCL。 其他 Mac OS X 10.6 技术更新，如全新的 QuickTime X 和跳票的 ZFS，有着更复杂的历史背景（以后再为读者介绍）。 64 位架构出现的缘由 前文提到，根据摩尔定律，同样价格的集成电路上可容纳的晶体管数目，约每隔 18 个月便会增加一倍，性能也将提升一倍。事实上，存储器的容量增长可能更快，每过 15 个月就会翻一番。有了更快更强的电脑，可能会让数值计算的科学家们喜出望外，但对普通大众来说，摩尔定律给普通消费者一个假象——如果你觉得 1000 美元的苹果电脑太贵，那等上 18 个月就可以用 500 美元买到同样的电脑。十年前你在用电脑写 Word 文档，十年后你还在用电脑写 Word 文档，反正计算机不是耗材，一台电脑只要不坏，就不用去买新的。计算机产业的巨头们自然知道摩尔定律对他们造成的致命打击，因此，一个阴谋被以 Intel 和 Microsoft 为首的巨头们构想出来——Intel 负责把硬件越做越快，而 Microsoft 则负责把自己的软件越做越臃肿、越做越慢——至于你信不信，反正我是信的。因此，使用软件、服务等，直接促进计算机产业的消费，使得计算机产业走上可持续发展的道路。这在计算机产业被称为 Andy-Bill 定律，分别以 Intel 和 Microsoft 总裁的名字命名。 当然，软件公司未必真心欺骗消费者，故意把软件做大做慢——为了实现一个新功能，软件势必会比原先庞大。但现代软件的速度、大小和其增加的功能并不成比例。比如对最终用户来讲，Windows Vista 到底比 Windows XP 多了多少功能呢？可能只有 20%30%。Word 2007 对比 Word 2003 多了多少功能呢？可能也只有 20%30%。但 Windows Vista、Word 2007 占用的 CPU、内存、磁盘空间，却比 Windows XP 和 Word 2003 翻了几番。究其原因，为了能赶快把新功能带给用户，我们不惜使用更方便但低效的编程语言（.NET、Java 等依赖虚拟机的语言就要比 C 慢许多，Python 等动态语言比 C 慢的不是一星半点）、快速开发（我们原先处理一个大文本，先分块，一点一点读到内存中，然后把处理完的部分写回磁盘，清空内存；而现在直接把它全读进来处理，开发方便，执行也快）。而用户必须为这些新功能买不成比例的单。64 位就是在这个背景下迅速走入寻常百姓家的——程序占用越来越多的内存，而 32 位的寻址空间已不能满足软件运行的需要了。 64位 CPU 是指 CPU 内部的通用寄存器的宽度为 64bit，支持整数的 64bit 宽度的算术与逻辑运算。早在 1960 年代，64位架构便已存在于当时的超级电脑，且早在 1990 年代，就有以 RISC 为基础的工作站和服务器。2003 年才以 x86-64 和 64 位元 PowerPC 处理器架构（在此之前是 32 位元）的形式引入到个人电脑领域。从 32 位元到 64 位元架构的改变是一个根本的改变，因为大多数操作系统必须进行全面性修改以取得新架构的优点。 成功的迁移 苹果向 64 位处理器的迁移花了整整 6 年时间，远长于该公司其他技术的迁移——向 Intel 的迁移仅用了一年时间，从经典 Mac OS 到 Mac OS X 也仅用了三年时间。总而言之，这场迁移是非常成功的：一方面，用户基本无痛苦，老的 32 位程序在目前最新版的 Mac OS X Lion 中依然可以完全兼容地执行；另一方面，对开发者而言，基本只需做微小的调整，重新编译程序，而且若干技术如 Universal Binary，使他们发布程序非常方便。当然，对于某些大量使用过时技术的公司，如 Adobe 和 Microsoft，这场迁移则要折腾得多。 这场迁移整整用了四个发行版的时间（10.3 至 10.6），不同于 Windows 或 Linux，Mac OS X 对 64 位的迁移自下而上，再自上而下。先是内核扩展，逐渐上升至 Unix 空间，然后上升至用户界面，再上升至整个应用程序生态，最后完成内核的迁移。要提醒读者的是，Mac OS X 的 32 位和 64 位内核空间与用户空间的分配和实现，和 Windows 存在本质的区别，但在本期介绍中，我们尽可能少地把 Mac OS X 的 64 位迁移和 Windows 进行比较，不拘泥于技术细节，对此区别有兴趣的读者，请移步 AppleInsider 的系列专题。 2003 年，苹果发布了其第一款 64 位计算机工作站 Power Mac G5。同期发布的 Mac OS X 10.3 也因此增加了非常简单的 64 位支持，于是 XNU 内核开始支持 64 位的寄存器和整数计算。但对于用户空间而言，程序可见的地址依然是 32 位的。程序当然可以使用大于 4GB 的内存（Power Mac G5 最高可达 8GB 寻址空间），但这要求程序手动地在两个 32 位内存空间中来回转换。 两年后，苹果发布了当时最成功的 Mac OS X 发行版 Mac OS X 10.4 Tiger。10. 4 的内核是革命性的，除了增加对内核并行多线程的支持，它把用户空间可见的地址空间扩展到了 64 位，因此理论上用户程序可以以 64 位方式执行。当然，在这个时期，几乎系统内的所有程序，哪怕是内核，依然是 32 位的。系统中唯一带的 64 位二进制文件是名为 libSystem.dylib 的系统库。它是 Mac OS X 上对 C 标准和 POSIX 标准的支持库，由 libc、libinfo、libkvm、libm 和 libpthread 五部分组成。但这仅有的 libSystem.dylib 理论上就能让所有仅使用 C 标准库和 POSIX 标准库的程序以 64 位模式运行。当时，用户对 64 位的需求较少，主要限于科学计算或图形处理等需要大数组的领域。因此，10.4 能较好地满足这部分用户的需求。但如果程序需要调用除 BSD Unix 以外的系统调用，比如想用 Cocoa 来画图形界面，那么该程序仅能以 32 位方式运行了。对于一些需要 64 位寻址空间的科学计算程序，比如 Mathematica，就需要采用一些比较麻烦的做法：用一个进程调用 32 位的 Cocoa 画图形界面，用另一个进程调用 64 位的 libSystem 来进行运算和 Unix 系统调用，并用 Unix 管道或进程间通信的方式管理两个进程间的输入/输出。 苹果在 Mac OS X 10.4 发布同期的另一项重要决策是向 Intel 平台 x86 及 x86_64架构的迁移。为了帮助开发者和用户顺利迁移，苹果正式公布了 Universal Binary。Universal Binary 技术是 Mach-O 二进制文件早就具有的特性，只是在这个场合作为一个商业词汇进行宣传。NeXT 时代 NeXTSTEP 操作系统就支持许多种不同的硬件架构，自然可以要求开发者对每个平台发布一个独立的版本，但这样的分发模式很麻烦，消费者也需要搞清到底购买哪种平台的软件。因此 NeXT 的 Mach 内核所支持的 Mach-O 二进制文件格式引入了一种叫 fat binary 的特性，说白了就是在一个平台架构上分别交叉编译所有平台的二进制格式文件，然后把每个文件都打包成一个文件。Universal Binary 就是指同时打包 Intel 平台和 PowerPC 平台的二进制文件。Mac OS X 10.4 最终支持四个平台的 BSD 系统调用——32 位 Power PC、64 位 PowerPC、32 位 x86 和 64 位 x86_64。作为最终用户，无须搞清这些区别，因为使用 Universal Binary 技术，买回来的软件直接会解出相应平台程序的二进制文件并执行。这是苹果很成功的一步——不像 Windows 系统中要用不同的路径（\Windows\System、\Windows\System32、\Windows\System64）分别存放不同架构的二进制库，并且用户还需在 32 位版和 64 位版之间犹豫不决。 Mac OS X 10.5 Leopard 经过一系列跳票终于在 2007 年末发布，跳票主要原因是当时苹果投入了大量人力和物力去做 iPhone，以至于 10.5 跳票了整整一年。10.5 包含了约 300 项新功能，而最重要的一项是苹果把对 64 位的支持带入了 Cocoa 层面。因此，几乎系统中所有的库都有四个平台的版本。在 WWDC 上乔布斯亲自向与会者介绍迁移到 64 位的好处，而能使用更大的内存自然是一项重要优势，程序可以申请更大的内存，把所有数据一并读入内存中操作，而无须分块后来来回回地在内存和磁盘搬运数据。另外，对 Intel 平台来说，x86 架构只有 8 个寄存器，而 x86_64 平台有 16 个寄存器，这也就意味着，对该平台来说，只要重新编译程序，程序就能自由调度比原先翻倍的寄存器数量而无须快取或在内存中来回查找和读写。根据粗略估算，一般涉及大量数值计算的程序会加快一倍。所以他很开心地劝说所有的开发者都迁移到 64 位架构。 历时整整 6 年时间，苹果完成了向 64 位处理器的迁移，同时这也给苹果提供了良好的清理门户的机会——清理过时的技术和 API。 彻底的清理 同时，苹果做出了一个大胆的举动——Carbon 框架并未出现在这次迁移中。Carbon 是 Mac OS X 诞生之初为了帮助 Mac OS 开发者把老程序迁移到新的 Mac OS X 操作系统上所提出的一个兼容 API，这套 API 长得很像经典 Mac OS 的 API，但能够得到 Mac OS X 平台提供的一切新特性，Adobe、Microsoft 等都是通过 Carbon 把它们经典的 Mac OS 程序移植到 Mac OS X 上的。苹果的本意是希望开发者用 Carbon 迁移老程序，用 Cocoa 开发新程序，但在 Carbon 诞生之初，其受关注度远大于 Cocoa，据 TeXShop 开发者 Dick Koch 回忆，在 Mac OS X 刚诞生的开发者大会上，Carbon 讲座的教室挤满了人，而 Cocoa 相关的讲座上听者无几。维护两套雷同的 API 的代价自然很高，所以砍掉一个是大势所趋。Carbon 和 Java 的热度甚至一度让苹果产生索性把 Cocoa 或 Objective-C 砍掉的想法。大量苹果自家的程序如 Finder、iTunes、Final Cut、QuickTime 等也都是用 Carbon 写成的。不过在此后由于大量涌现在 Mac OS X 平台上的新程序都是 Cocoa 写的，导致 Cocoa 技术不断走高。2007年的 iPhone 也完全依赖于 Objective-C 和 Cocoa 的一个裁剪版 Cocoa Touch。因此在 WWDC 2006 上，苹果在 Mas OS X Leopard 10.5 的开发预览版中包含了测试版本的 64 位 Carbon 库，甚至还有讲座教如何开发 64 位的 Carbon 程序。但苹果却在 2007 年告诉 Carbon 开发者，他们的程序将不可能再被编译成 64 位，要做到这点，必需先把程序用 Cocoa 重写。 这个突然的决定激怒了很多开发者，尤其是以 Microsoft 和 Adobe 这些巨头为代表的公司。Adobe 全套的 Creative Suite 和 Microsoft 全套的 Microsoft Office 是很多苹果用户必备的软件，数百万行代码全是用 Carbon 写的。所以直到今天，除了 Adobe Photoshop 等少数程序终于在 2010 年全面移植到 Cocoa 后做出了 64 位版，其他大部分程序依然停留在 Carbon 的 32 位模式。 苹果也花了很长时间来重写 Finder、FinalCut、iTunes、QuickTime 等程序或技术，耗费了大量精力。当 Adobe 发布 64 位的 Lightroom 2.0 时，苹果还在手忙脚乱地重写 Aperture。不过公正地讲，长痛不如短痛，砍掉对 Carbon 的支持能够使苹果把更多精力放在该做的事上，也使得 Mac OS X 的结构更简洁，并且事实上，64 位的迁移为苹果提供一个砍去老 API 的机遇，哪怕对 Cocoa 也是。一方面，Cocoa 框架中很多类不是使用类似 Carbon 的 API，就是依赖于用 Carbon 实现（注意，和传统观念不同，Carbon 和 Cocoa 在早期 Mac OS X 上是相互依赖的，比如菜单 NSMenu 就使用了 Carbon 的菜单管理器），这些 API 在 64 位得到了彻底清理，QuickTime 相关的 C 接口全被砍去。Cocoa 经过很长时间的发展，自然也保留了很多过时的 API 以保证和原先的产品兼容，而这次机会给苹果足够的理由彻底推翻原先的设计。在 Mac OS X 10.5 中， Objective-C 的运行库 libobjc 更新到 2.0，提供了全新的并发、异常处理、自动内存回收、属性（property）等新机制，其中很多新特性只供64位享用。同时，所有 int 都被改为 NSInteger，Core Graphics 中的 float 都改为 CGFloat，以保持 API 统一，这些都是 64 位架构上的改动。因此 64 位迁移给苹果一个很好的清理门户的机会。 作为相反的例子，这次清理也有不彻底的地方。比如从老版 Mac OS 中混进来的 Keychain 库，甚至具有 Pascal 风格的 API，由于没有替代品，它也得到了 64 位的更新。所以类似 keychain 这样的库成了现在 Mac OS X 程序员的噩梦。我每次用到 Keychain 都有痛不欲生的感觉。 而 2009 年发布的 Mac OS X 10.6 Snow Leopard 则是对 64 位真正完整的支持。Unix 层虽然 10.4 就提供了 64 位的 libSystem，但所有的 Unix 用户空间工具包括 ls、Python 等，以及 Xcode 中的 gcc，也都是以 32 位二进制的模式发布的。图形界面层，在 10.5 Leopard 中，虽然整个系统的库都迁移到 64 位，以 32 位和 64 位的混合模式发布，但用户应用程序依然是 32 位的。只有 Chess、Java、Xcode 套件等少数程序以 64 位编译。但在 10.6 中，基本所有的应用程序都被迁移到 64 位，不管是 Safari、Mail、Dock，还是 TextEdit。当然，各种 Unix 工具包括 LLVM、GCC 等也都以 64 位的模式发布。10.6 只有四个 Carbon 程序（Front Row、iTunes、DVD Player 以及 Grapher）未得到 64 位升级【2009 年查阅，现页面已更新至 10.7】。其中， Front Row 在 Mac OS X 10.7 Lion 中被砍掉， iTunes 在 10.7 发布时依然以 32 位模式发布，在 2011 年末的更新中才迁至 64 位。 为了使应用支持 64 位，苹果不遗余力地改写了大量代码，Snow Leopard 中最重要的重写当属 Finder，这个程序自 Mac OS X 发布以来就一直是一个 Carbon 程序，并且苹果一直不停地改进它以展示 Carbon 无所不能。但自从 10.5 时代苹果下决心砍掉 Carbon 后，该程序被完整地重写。新的 Finder 和 Carbon 版的 Finder 看上去并没有太大差别，但 Finder 使用 Cocoa 重写后，不仅速度更快，而且增加了许多 Cocoa 新特性，比如加入了更多的 Core Animation 特效来平滑过渡动画。总之，虽然苹果在 10.6 期间没有提供太多新功能，但这样大规模的重写，为今后代码的可维护性奠定了良好的基础。 Mac OS X 10.6 发行版也完成了 64 位化的最后一步——内核的 64 位化。 半导体的丰收（中） 经过 6 年时间，4 个发行版，苹果终于完成了向 64 位的迁移，并随着 Snow Leopard 的发布推出了解决并行编程问题的 Grand Central Dispatch（简称 GCD）技术，释放了多核系统的潜力。 和 10.5 一样，在 10.6 Snow Leopard 中，苹果继续利用 64 位的迁移砍掉了诸多老技术，很多新技术仅以 64 位的模式被支持。例如重写的 QuickTime X 框架，虽然 QuickTime X 应用程序以 32 位和 64 位的模式发布，但其 API 仅暴露给 64 位。另一个例子是 Objective-C 2.1 的运行库，快速 Vtable 调度，新的和 C++ 统一的异常处理模型，以及彻底解决对象的 FBI 问题等，都仅限 64 位程序使用。 内核的 64 位化 读者应该发现，经过这 4 个发行版，Mac OS X 自下而上地对整个系统向 64 位迁移。10.3 内核空间提供了 64 位整数运算的支持。10.4 允许程序以 64 位模式运行在用户空间，并且提供了 64 位的 libSystem 使得开发者可以开发 64 位的 Unix 程序，而 10.5 中系统所有未废弃的函数库、框架都提供 64 位版本，到了 10.6，所有用户空间的程序，包括 Unix 层和图型界面层，基本都更新到 64 位。细心的读者不禁会问—那内核是 64 位的吗？是的，自下而上支持 64 位后，10.6 又从上往下，迁移了整个系统中最后一个也是最重要的部分—内核。 内核 64 位化的意义 对于 Windows、Linux，以及 FreeBSD 等操作系统，64位实现的第一步是实现 64 位的内核。然而 Mac OS X 却反其道而行。主要原因是，反正 32 位的内核也能以非模拟、非兼容的方式原生地运行 64 位用户空间程序，而内核和与内核动态链接的驱动，很少需要用到 64 位的寻址空间（你什么时候见过内核本身使用 4GB 内存？），所以该问题可以暂缓。 但要记住，用户空间的内存是由内核管理的，虚拟内存、内存分页等机制，都是由内核一一实现的。一旦在不久的将来，随着用户空间的内存占用越来越多，虚拟内存的分页比也会不断膨胀。比方说，一个用户程序使用 4GB 的空间，每个分页包含 4KB 的页面，那么总共有 1M 个页面。因此，假设一个页面需要 64B 的 PTE 来记录该页的位置，那总共也就需要 64MB 的内核空间来记录这个用户空间程序的虚拟内存，不算太多。而在不久的将来，如果一个 64 位用户程序使用 128GB 的空间，则需要 32M 个页面，每个页面 64B 的 PTE 会导致 2GB 的内核地址空间来寻址（暂不考虑大分页）。32 位的内核就显得非常紧张。 另外，上一期我们也提到 64 位的 Intel 架构提供了比 32 位多一倍的寄存器，因此，用户空间程序对 64 位内核的系统调用也会更快。根据苹果的数据，系统调用的响应速度比原先快了 250%，而用户空间和内核空间的数据交换也快了 70%，因此，64位内核要比 32 位内核更快。 内核完成 64 位迁移 虽然在 Mac OS X 10.6 中，苹果提供了 64 位模式运行的内核，但在大部分苹果计算机上，这个特性并不默认启用。其原因是，虽然 64 位程序和 32 位程序可以在计算机上同时运行，但 64 位的程序只可以加载 64 位的库或插件，32位程序只能加载 32 位的库或插件。因此，如果默认使用 64 位模式启动，则诸多第三方的 32 位驱动或内核模块将无法使用。当然，用户可以通过修改 com.apple.Boot.plist、nvram，或开机按住 6 和 4 强制加载 64 位内核，不过苹果并不推荐这样的方式。直到 Mac OS X 10.7 时，第三方内核扩展已趋完善，大部分的 Mac 才默认使用 64 位内核模式启动。 苹果用了整整 6 年的时间完成 64 位的迁移，在 2009 年 WWDC 的一个讲座上，Bertrand Serlet 告诉开发者，我们这个 64 位技术的讲座，只针对 Mac OS X，而 iPhone、iPad 等 iOS 设备，由于使用 ARM 平台，在可预见的未来可能并不会支持 64 位技术。 不过两年之后的 2011 年 10 月 27 日，ARM v8 发布，ARM 正式宣布支持 64 位。未来会不会出现基于 ARM 的 Mac，或是 64 位的 iPad，除了苹果，谁知道呢？ Bertrand Serlet 在 WWDC 2009 上介绍 Snow Leopard 的 64 位和 Grand CentralDispatch 技术 GCD(Grand Central Dispatch) 来临 很长一段时间以来，处理器靠更快的运行时钟来获得更高的效率。软件开发者无需改动或重新编译他们的代码，就能得到摩尔定律许诺他们的好处，因为处理器顺序地执行计算机指令，新一代的处理器就自动会跑得比原先更快。后来每每达到一个技术极限时，总有一些聪明的方法绕过这些极限，比如超纯量、指令管线化、快取等，不是悄无声息地把多条互相独立的指令同时运行，就是隐藏掉数据读写的延时。GCD 出现的缘由 到了 21 世纪，能想的办法基本都想尽了——现代处理器已经足够并行了，也采取了各项优化来不断提升各种预测器的准确率，而时钟频率却是不能无限提高的——提高时钟频率会极大地增加处理器的产热，使得服务器机房或笔记本的散热成为一个头痛的问题。同时对于便携设备而言，高频也意味着短得多的电池时间，因此摩尔定律正在经受重大的考验。 因此大约在 21 世纪头十年过掉一半时，“多核”处理器，终于开始跃入普通消费者的视线。“多核”顾名思义，就是把原先单核的半导体线路复制多份排于同一裸片上，每个核相互独立，又能彼此通信。多核处理器的出现，有效缓解了计算机处理器生产商的设计和制造压力，从而达到忽悠消费者买更新款产品这一不可告人的目的。 但这一次技术革新，并不如之前那么顺利，因为程序并不会自动在多核系统上跑得更快，甚至有很多程序每一步都有前后依赖，不能高效地并行运行。即使能够高效并行的程序，也需要大规模改写才能充分利用多核所带来的优势。 传统的并发编程模式，就是学习使用线程和锁。这听起来很简单，几句话能说明白：把每个任务独立成一个线程；不允许两个线程同时改动某个变量，因此得把变量“锁”起来；手动管理线程的先后并发顺序和并发数量，让它们均匀地占满系统资源；最好系统中只有这个程序在运行，否则你精心设计好的线程管理算法往往不能达到原来该有的效果；最后祈祷程序在用户那儿不出问题。 但是实际操作起来，多线程程序的编写要比单线程难上不止一个数量级。一方面，调用大量内存和数据反复的加解锁本身效率就非常低下；另一个重要原因在于，由于多线程程序可能以任意的次序交错执行，程序再也无法像顺序执行时那样产生确定的结果。多线程程序看似容易编写，但难分析、难调试，更容易出错。即使是最熟练的开发者，在茫茫线程和锁之间，也会迷失方向。且程序的错误在很多时候甚至是不可重现的。所以，程序员使用线程和锁机制编写并行程序的代价是很高的。 GCD 就是在这种背景下被苹果提出来的。2008年最初提出但未公布细节时，很多人怀疑它是 FreeBSD 的 ULE 调度器在 Mac OS X 上的实现。ULE 是 FreeBSD 当时最新的内核调度器，用来替换掉老一代的 4BSD 调度器，当时使 FreeBSD 上跑多线程程序的效率获得了重大的性能提高，远高于同期 Linux 和 Solaris 的算法效率。但当时我就认为 GCD 依赖 FreeBSD 这项技术的可能性不大，因为 Mac OS X 中管理进程和线程主要用的是 Mach 而不是 BSD。不过后来证实我只猜对了一半，GCD 的实现，实际上是依赖于 FreeBSD 的另一项技术 kqueue。kqueue 是一个由 FreeBSD 4 时代引入的新功能，内核级别地支持消息通信管理。GCD 的队列，其实就是用 kqueue 实现的。GCD 出现的意义 在 GCD 中，开发者不再管理和创建线程，而是将要实现的运算抽象成一个个任务，一起扔给操作系统，转而让操作系统管理，这在计算机科学中，被称为线程池管理模式。 在 GCD 中，开发者使用很简单的方式就能描述清应用程序所需执行的任务，以及任务之间的相互关联。每一个任务在代码中被描述成块（block），然后开发者把一个一个块显式地按顺序扔到队列（queue）中。使用块和队列两个抽象的表述，开发者无须创建线程，也无须管理线程，更无须考虑数据的加解锁。换之而来的，是更简短可读的代码。剩下的事，全都扔给操作系统去完成。 在操作系统那边，GCD 在程序运行时，管理着一定数量的线程，线程的数量是自动分配的，取决于用户计算机的配置和用户程序运行时的负载。多核工作站每个程序配到的线程，自然就会比单核手机或双核笔记本来得多。而且这个线程的数量是会动态变化的。当程序非常忙时，线程数会相应增多，而当程序闲置时，系统会自动减少其线程数量。然后，GCD 会一一从队列中读入需要执行的块，然后扔到线程上并发执行。 相信读者已经看出 GCD 和传统线程-锁机制的区别来了。传统的方式按劳分配，强调程序自由独立地管理，妄想通过“无形的手”把系统资源平均分配，走的是资本主义市场经济的道路。而 GCD 按需分配，真正实现了社会主义计划经济管理模式。因此在政治上 GCD 就是一个代表先进生产力的计算机技术（我被自己雷了，但事实就是这样）。 GCD 是一个自底向上的技术，它实际上由以下 6 个部分组成。 编译器层面，LLVM 为 C、Objective-C 和 C++ 提供了块语法，这个内容等下会介绍。 运行库方面，有一个高效分配管理线程的运行库 libdispatch。 内核方面，主要基于 XNU 内核 Mach 部分提供的 Mach semaphores 和 BSD 部分提供的 kqueue () 机制。 dispatch/dispatch.h 提供了丰富的底层编程接口。 在 Cocoa 层面，NSOperation 被重写，因为使用 libdispatch，所以先前使用 NSOperation 的程序不需改动，就自动享受 Grand Central Dispatch 的最新特性。Instruments 和 GDB 提供了非常完整的分析和调试工具。 GCD 还有一些工程上的优势。首先，程序的响应速度会更快。GCD 让程序员更方便地写多线程程序，因此写一个多线程程序来实现前后台简单多了，极大改善了 Mac OS X 上应用程序的生态环境。而且 GCD 的代码块队列开销很小，比传统线程轻量得多。统计表明，传统的 Mac OS X 上使用的 POSIX 线程需要数百个计算机汇编指令，占用 512KB 的内存，而一个代码块队列才用 256 字节的长度，把块加入队列，只需要 15 个计算机汇编指令，因此开成百上千个也不费什么事。 其次，线程模式是一种静态的模式，一旦程序被执行，其运行模式就被固定下来了。但用户的计算机配置各不相同，运行时别的程序有可能耗用大量的计算资源。这些都会影响该程序的运行效率。而动态分配系统资源则能很好地解决这个问题。苹果自然也是不遗余力地忽悠开发者使用 GCD，因为各个软件共享多核运算的资源，如果 GCD 被更多的开发者采用，整个苹果平台的生态也就更健康。 而最重要的，还是 GCD 采用的线程池模式极大简化了多线程编程，也降低了出错的可能性。著名 FreeBSD 开发者 Robert Watson 还发布了一个他修改过的 Apache，并释出了补丁，声称只需原先 1/3 至 1/2 的代码量，就实现了原先的多线程模块，并比原先的效率更好。 如何应用 GCD 当然，老王卖瓜，自卖自夸，没有实际的例子，是不能让读者信服的。下面我们就来简单讲解 GCD 的技术。 首先是块状语法，是一个对 C、C++ 和 Objective-C 语言的扩展。用来描述一个任务，用^引导的大括号括起来。比如最简单的： 1x = ^&#123; printf (“hello world\n”);&#125; 则 x 就变成了一个块。如果执行： 1x (); 那么程序会打印 hello world 出来。当然，blcok 像函数一样，可以跟参数，比如： 1234567int spec = 4;int (^MyBlock)(int) = ^(int aNum)&#123; return aNum * spec;&#125;;spec = 0;printf (“Block value is%d”,MyBlock (4)); 这里 MyBlock 是一个带参数的代码块。读者看到这里不禁要问，块到底有什么好处？它和 C 的函数指针有什么不同？我们依然用上面的例子来说明问题，虽然后面我们把 spec 变量改为 0，但事实上在 MyBlock 创立时，已经生成了一个闭包，因此它最后输出的结果，仍是 16，不受 spec 值改动的影响。这对于搞函数式编程的人来说再熟悉不过了，因此很多开发者亲切地称呼块语法的 C 扩展为“带 lambda 的C”。 有了闭包功能的 C 顿时牛起来——你可以把函数和数据包装在一起——这就是块的真正功能。因为只要一个闭包包含了代码和数据，它的数据就不会被别的闭包轻易改动，所以在它执行时，你根本不用为数据上锁解锁。 有了一系列的代码块后，接下来的事是把代码块扔到队列里。比如最简单的： 1dispatch_queue_t queue = dispatch_get_global_queue (0,0); 来创建一个轻量级的队列，然后 1dispatch_async (queue,^&#123;printf (“hello world\n”);&#125;); 那这个代码块就被扔进 queue 这个队列中了。你可以手动依次添加任意多个项目，比如“带着老婆”、“出了城”、“吃着火锅”、“唱着歌”、“突然就被麻匪劫了”等。当然在更多的场合，你会更倾向于使用自动事件源，每当一个事件触发时（比如定时器到点、网络传来包裹，或者用户点击了按钮），相应的代码块被自动添加到队列中。 一旦队列不是空的，GCD 就开始分配任务到线程中。拿上面的例子来说，“老婆”、“城”等变量可是封在闭包里的，所以在运行时，不用考虑它们被某个别的闭包改掉（当然也有方法来实现这个功能）。总体而言，这个模式比线程-锁模型简单太多——它的执行是并行的，但思维却是传统的异步思维，对没有学习过系统多线程编程的开发者来说，依然能很容易地掌握。 读者可能要问，如果闭包之间有复杂的依赖关系，需要申明某两个操作必须同步或异步怎么办？比如“出了城”必须在“吃着火锅”之前。在 GCD 中，可以使用 dispatch_async 和 dispatch_sync 来描述这样的依赖关系，而在 Cocoa 层面，NSOperation 中的队列依赖关系甚至可以被描述成有向图。GCD 得到广泛应用 GCD 一经推出就得到了广泛的应用。苹果自家的软件 Final Cut Pro X、Mail 等软件，都采用 GCD 来实现任务并发和调度，因此 Mac OS X 10.6 成为了有史以来最快的发行版。从 iOS 4 开始，iPhone 和 iPad 也加入了 GCD 的支持。更别提原来使用 Cocoa 的 NSOperation 相关接口的程序，无需改动即享受 GCD 的优惠。 GCD 在 Mac OS X 10.6 发布后，又以 libdispatch 为名，作为一个独立的开源项目发布。 所需的外围代码，如编译器的块支持、运行库的块支持、内核的支持，也都能在 LLVM 和 XNU 等开源项目代码中找到，所以很快被别的操作系统采用。作为 Mac OS X 的近亲， FreeBSD 在一个月后即完整移植了整套 GCD 技术，并最终在 FreeBSD 9.0 和 8.1 中出现。诸多 Linux 发行版也提供 libdispatch 的包，使用 Linux 内核的 epoll 来模拟 FreeBSD 的 kqueue。2011年 5 月 5 日， Windows 的移植工作也宣告完成。 另外，GCD 也成为拯救动态语言的重要法宝。由于受 GIL（全局解释锁）的限制，动态语言虽然有操作系统原生线程，但不能在多核处理器上并行执行。而 GCD 成功绕开了这个限制，如加入 GCD 支持的 Ruby 实现 MacRuby 就能在多核处理器上高效执行。 因此，在苹果生态圈以外，GCD 也会得到越来越多的应用。 半导体的丰收（下） 随着 CPU 与 GPU 合并成技术发展的趋势，苹果开发出了 OpenCL 框架，能够进行高速并行处理的能力使 OpenCL 成为了业界标准，被广泛应用。 最近几年，GPU 的发展吸引了很多来自科学计算界人士的目光。GPU 有稳定的市场推动力——公众喜闻乐见的电子游戏产生了源源不断的升级 GPU 的需求——因此比 CPU 的更新步伐更快。从技术上讲，GPU 本身就是多核架构，高端显卡往往有五百多个核心，即使低端的集成 GPU 也有二三十个核心，所以能够通过并行来高效处理成千上万的线程。同时，对于科学技算中的浮点计算，GPU 往往通过硬件加速使其效率比传统 CPU 更高，因为图形渲染等工作基本都是浮点计算。 GPGPU 浮出水面 早期的 GPU 只能执行固定的程序，而不开放给程序员编程。随着时代的发展，图像处理有时需要对着色器进行编程以实现一些特效，因此需要程序员可以使用 GPU 的汇编语言写简单的着色程序。这自然对程序员要求过高，所以一些高阶的着色语言又被 GPU 厂商开发出来。比如微软和 NVIDIA 共同开发的 Cg 语言，就能为顶点和像素编写专门的着色程序。这类技术虽然面向图形渲染工作者，却吸引了一小簇科学计算研究者的兴趣。以计算流体力学为例，它是用纳维斯托克斯方程【注：把牛顿第二定律和质量守恒应用到流体后，所得到的偏微分方程】来求解流体力学问题的一种算法，广泛用于天气预报、F1 方程式赛车设计等工程领域。同时，对于电影制片特效，计算流体力学也是最基本的用来模拟流体流动特放的算法，皮克斯动画工作室的《寻找尼莫》中的海洋流动和水花等，都是使用纳维斯托克斯方程来模拟的。 首先，对于一个几何空间进行网格化，每个网格中的流体，都可以列出纳维斯托克斯方程，把这些方程联立起来进行求解，即可得到各点的温度、压力、湿度、速度等流体信息。整个求解过程可以高度并行，因为每个网格的控制方程是完全一样的；同时也牵涉大量的浮点运算。但 Cg 这类语言并非面向普通的计算，其变量都是颜色、顶点、像素等图形学专用变量。来自北卡罗莱那大学教堂山分校的 Mark Harris 突发奇想：可以把流体力学中每个网格的速度、压力等变量，存成 RGBA 颜色后让 Cg 去处理，所以他在《GPU Gems》中著名的一章，公布了使用 Cg 来高速实现计算流体力学运算的成果，吸引了大量计算界的目光。然而，这种编程模式对科技工作者来说很不友好，因为这要求一个学力学的、学生物的、学化学的学生，先要明白复杂的 GPU 渲染原理，了解图形学中材质、顶点、合成、像素、光栅化、光线跟踪等深奥的理论，才能编写他们专业相关的 GPU 程序。 GPU 生产厂商洞察到了 GPU 高速并行浮点数运算的潜力，所以 GPGPU（General Purposed Graphics Processing Unit）概念终于浮出水面。一方面 GPU 设计一代比一代可编程化，另一方面各公司也在加紧研制新一代 GPU 编程语言。新一代的语言对比 Cg，去掉了对于渲染相关的知识要求，独立于图形学之外，是纯粹的普通语言，比如变量不再是像素、顶点、面等类型，而是 C/C++ 语言开发者喜闻乐见的浮点数组、整形数组等。这一时期为代表的语言，主要是 CUDA（Compute Unified Device Architecture）。CUDA 是 NVIDIA 在 2007 年公布的一项面对科学计算工作者的编程框架。通过该技术，使用者可利用 NVIDIA 的 GeForce 8 以后的 GPU 和较新的 Quadro GPU 进行高性能编程。用户先编写一个特殊的 C++ 代码文件，扩展名为 cu，文件中需要申明创建的变量、GPU 计算核心（kernel）以及使用给定的编程接口来实现变量在 CPU 和 GPU 中的传送。然后通过 NVIDIA 自家的编译器编译这个代码，链接到 NVIDIA 自家的库上，即可把该运算核心编译为 GPU 汇编语句扔到特定型号的 GPU 上高度执行。其他厂家也紧随其后，比如 AMD 为 ATI 生产的 GPU 卡提供了一个类似的框架叫 Stream SDK（先前被命名为 CTM, Close to Metal， ATI Stream Computing – Technical Overview， 03/20/2009 http://en.wikipedia.org/wiki/Close_to_Metal ）。而微软更是趁 Vista 和 Win7 推出了 DirectCompute，作为旗下 DirectX 技术的一部分。 CUDA 并不完美 对科学工作者来说，CUDA 比 Cg 友好太多。使用 CUDA 加速流体力学运算相关的论文更是雨后春笋般涌现。然而不久后，我发现它存在许多问题。 首先，对初学者来说，CUDA 编程模式很容易学混。因为一个 GPU 数组和一个 CPU 数组在 CUDA 中的表述都是同样的C指针，但对于 GPU 数组和 CPU 数组，CUDA 的处理模式完全不同，CPU 数组使用常规的 malloc 来初始化，而 GPU 数组得使用 CUDA 提供的 malloc。所以程序写着写着，就忘了一个变量到底是给 CPU 用的还是给 GPU 用的，这无疑增加了学习难度。同时，CUDA 对 C/C++ 语言进行了一系列扩展，这不但意味着写的程序不再具有 C/C++ 那样良好的可移植性，而且这种计算核心和传统 C 程序混写的编程语言很不美观。 其次，CUDA 这类语言的实现各自为政。如果你写了一个 CUDA 程序，就意味着这个代码只能运行在 NVIDIA 的显卡上。如果想使用 ATI 的显卡呢？没门，请用 ATI Stream SDK 重写。 再次，CUDA 是在编译时就静态产生 GPU 代码的，所以只能产生特定的 GPU 代码。如果你发布了一个 CUDA 程序，它仅对某几种 NVIDIA 显卡进行特定的代码优化。如果 NVIDIA 自家出了一种新显卡，很抱歉，哪怕新显卡可能兼容老显卡的汇编指令而你的程序恰巧可以在新显卡上跑起来，你也无法发挥新显卡的所有特性。必须用针对新显卡的编译器重新编译源代码，才能够保证程序在新显卡上高效执行。 最后，CUDA 这类语言仅能产生高效的 GPU 代码，而无法产生 CPU 代码，即：写完的代码只能跑在 GPU 上，在 CPU 上只能“模拟执行”，仅供调试用。所以在一台不具备给定 GPU 的机器上，无法高效运行 CUDA 程序。同样，如果你有一个性能很强的工作站，那么你的 CPU 亳无用处——CUDA 不可能分配一部分任务给 CPU 完成。 另外还有未来计算机架构的不确定性。当时，GPU 越来越一般化，可以跑多种数值计算程序，而 CPU 随着多核成为主流也越来越像 GPU。所以很多厂家在考虑 CPU 和 GPU 合并的可能性。 当时轰动一时的热门事件，是 CPU 厂商 AMD 买下了 GPU 厂商 ATI，来开发下一代处理器 AMD Fusion，把 GPU 和 CPU 合并到一起。Intel 自然不甘示弱，做出了 Nehalem 平台，在该平台上，CPU 和集成 GPU 处于同一个包装中，外界一度猜测这样可使合并后的 CPU 具有图形处理工能，从而用户购置计算机就不用再考虑配一块 GPU 了。 更强大的是，当时 Intel 还公布了 Larrabee 计划，让 GPU 支援 x86 指令，使得一个常规的 x86 平台的程序不需要修改和重新编译便可在 GPU 上运行。 虽然事实和这些预期有稍许出入，但当时的技术趋势是：在将来可能出现一种新的合并 GPU/CPU 的技术，能够并行高速地运行一般的计算机程序，而面对这样新的可能的平台，我们如何准备？ OpenCL 诞生 OpenCL 则是苹果为这个新局面画下的蓝图。这项技术初期全称为 Open Computing Library（如果留意苹果早期宣传广告的话），后改名为 Open Computing Language。这项技术从本质上来说，和 CUDA 并没有太多的两样，但由于苹果在借鉴他人技术并把他人技术改得更棒这一点上是出了名的，所以 OpenCL 很好地解决了以上所有问题。 下面简单介绍一下这个框架。OpenCL 技术的结构十分清晰，对程序员来说，它是一个 Mac OS X 的 Framework，定义了两套标准，一套是一个 C 语言的编程界面（API），使得开发者创建、拷贝、回收 GPU 使用的对象，同时也包含检测处理器、为该处理器编译并调用核心程序（kernel）相关的接口；另一套是 OpenCL 核心程序语言的定义，是一套基于 C99 发展而来的语言。 例如我们有两个大数组，1024 维的 a 和 1024 维的 b（当然，1024不算大，OpenCL 往往用来处理十万、百万数量级的任务），我们把两个数组对应的元素加和，结果是一个 1024 维的数组c。C 程序员很容易能写出下面的程序： 12for (int i = 0; i &lt; 1024; i++) c[i]=a[i]+b[i]; OpenCL 的核心程序，则是取每个独立的可并行的循环分支，即上面程序中的 c[i]=a[i]+b[i]。所以核心程序大概是下面这样： 12345__kernel add (float *a, float *b, float *c)&#123;int i = get_global_id (0);c[i]=a[i]+b[i];&#125; 其中，get_global_id () 函数可以返回当前函数是全局中的第几个元素。把该程序保存为 add.cl，就是一个 OpenCL 的核心程序，为 C99 语言的一个子集。 使用 OpenCL 的 API 就能调用这个核心程序。每个 OpenCL 程序基本上是模式化地照搬下面流程： 1. 探测硬件（用 clGetDeviceIDs 函数护取计算设备（可以指定使用 GPU 或是 CPU），用 clCreateContext 函数来新建一个上下文（context），用 clCreateCommandQueue 函数针对设备和上下文新建一个命令队列）； 2. 编译核心（读入 add.cl，用 clCreateProgram-WithSource 和 clBuildProgram 以及 clCreateKernel 来编译读进来的字符串，产生一个核心程序）； 3. 写入数组（用 clCreateBuffer 创建a、b、c三个内存对象，用 clEnqueueWriteBuffer 把 C 数组写到内存对象中）； 4. 运行核心（把内存对象作为核心程序函数的输入参数执行这个核心，程序会并发为 1024 个线程，每个线程执行一次相应的加法运算）； 5. 读出结果（用 clEnqueueReadBuffer 读取c内存对向，写为C的数组）； 6. 回收内存。 OpenCL 之美 让我们逐条来看前面那些问题是如何被解决的。 首先，OpenCL Framework 由 C API 和 OpenCL 语言组成，泾渭分明，所有的 GPU 变量在 C API 中，都是内存对象的形式出现，有别于 C 自建的数组。因此，你永远不会搞混两者。同理，OpenCL 核心程序是独立在 C 源程序之外的，不仅美观，也能保证你的 C 程序能被所有 C 编译器编译，因为调用 OpenCL 库和调用其他 C 的函数库没有任何不同。 其次，苹果开发出 OpenCL 后，觉得该技术甚好，索性联合 AMD、ARM、ATI、TI、Intel、IBM、Nokia 等公司，把它做成一个由 Khronos 组织主持的开放标准。不管电脑上用的显卡是 ATI 的还是 NVIDIA 的，OpenCL 都能像 OpenGL 那样在你的设备上无缝运行。事实上，OpenCL 已同 OpenAL 和 OpenGL 一样，成为 Khronos Group 旗下的三大业界标准。 再次，CUDA 是在编译时就静态产生 GPU 代码的，所以只能产生特定的 GPU 代码。而 OpenCL 的核心程序（kernel）是在运行时被编译成 GPU 指令的。由于 kernel 所用的 OpenCL 语言，仅是 C99 的一个子集，所以负责编译这个程序的是 OpenCL 运行库自带的 LLVM-Clang。这样做的好处是明显的，举例来说，如果用户有一堆 OpenCL 的程序，比如苹果最新的 Final Cut Pro X 就在许多地方采用了 OpenCL，如果某一天硬件厂商发布了一个全新的 GPU 架构，那么用户安装显卡后，只要下载或更新相关的驱动程序和运行库即可，而不需要再求软件厂商发布一个新版本的 Final Cut Pro X。因为 OpenCL 在运行时，会根据显卡厂商提供的驱动和新运行库自动优化程序到特定架构上。所以，程序兼容性问题也被圆满解决。 最后，由于 OpenCL 是个开放标准，也支持 CPU 和其他任何计算设备，比如数字信号处理芯片（DSPs）和各种专门的处理器架构。所以只要有相关的驱动和运行库，OpenCL 程序可以高效地并行运行在任何架构的运算设备上。由于 OpenCL 和 GCD 的编程模式是一样的，因此当 OpenCL 程序在 CPU 上执行时，是跑在 GCD 队列上的。 由于 OpenCL 能高速地进行并行处理（如 http://macresearch.org/opencl_episode1 的演示，OpenCL 编写的 GPU 程序比单核 CPU 能快上数十至数百倍，笔者的论文 Yue Wang, Ali Malkawi, Yun Yi, Implementing CFD (Computational Fluid Dynamics) in OpenCL for Building Simulation, 12th Conference of International Building Performance Simulation Association, 2011 也得出了类似的结论），OpenCL 被广泛地使用在很多产品中，苹果也是 OpenCL 的主要用户之一。如上面提到的 Final Cut Pro X 就是个典范，使用 GCD 和 OpenCL 进行大量并行的流媒体处理。在老版本 Final Cut 中，每当用户执行一次流媒体操作，都会弹出一个进度条来告诉用户剩余的处理时间，而 Final Cut Pro X 优化后的速度是如此实时，以至于这个进度条被去除了。Mac OS X 许多的底层库也使用 OpenCL 重写，如 Core Image，本身也是一个 GPU 加速库，使用 OpenCL 后相比原来，依然获得了可观的性能提升。 Snow Leopard 的发布标志着第一个 OpenCL 框架的完整实现，OpenCL 成为业界标准后，AMD 抛弃了原先的策略，投入开放标准的怀抱，一连放出了几个测试版本的集成 OpenCL 的 ATI Stream SDK，并在 2009 年年底发布了稳定版，2011年 8 月 8 日宣布废除原先的 Close to Metal 相关技术。NVIDIA 也是早早地在 CUDA SDK 中加入了 OpenCL 相关的库。CUDA 越来越不被看好，所以 NVIDIA 索性把 CUDA 发布为一个开源项目，并把 CUDA 架构在 LLVM 之上。这和 OpenCL 近几年的走强有很大关系。开发者的瓶颈 目前看来，OpenCL 虽然解决了上面的所有问题且速度飞快，但对普通程序员来说，依然是非常底层的技术。而且由于硬件的限制（显卡不支持指针运算），很多 C 的标准并未在 OpenCL 中出现，写链表还需要用整数去模拟地址。程序员需要手动管理内存，处理底层的核心调用以及数据读写。而显卡厂商也大多不愿公开 GPU 的技术细节，因此不像 CPU 程序很容易通过汇编指令分析计算机底层干了什么，显卡对于开发者纯粹是个黑盒，把整个问题分成多少个线程并发也没有一个规律可循，有可能不起眼的改动会使程序运行瞬间变快或变慢数十倍，开发者也不知道其中的原因，只能凭经验操作。而且由于不存在良好的调试工具，所以很难改正程序的错误。 显卡作为系统最为重要的共享资源之一，不像现代操作系统那样提供内存保护机制，因此一个用户 OpenCL 程序的错误很容易导致整个计算机崩溃，所以经常是程序跑一遍后发现操作系统挂了，重启后发现了一个可能的错误，改完后编译运行，操作系统又挂了。我用 OpenCL 编写科学计算程序时，大量时间是在重启电脑而不是写程序。这些问题仍然阻碍着 OpenCL 被广泛采纳，不过，在科学计算界，已经涌现出了越来越多相关的论文和技术，相信在不久的将来，情况会有所改观。 结语 当写完这篇技术长文时，天色已晚，走出教室，和 ENIAC 擦肩而过。ENIAC 的出现激励了之后一次次的处理器革命。2009 年发布的 Snow Leopard 可能在整个 Mac OS X 发行版历史中不算最出彩，却是对于半导体集成电路革命的一次重大收获。 Mac OS X背后的故事（十）Mac OS X 文件系统的来龙去脉 HFS+ 和 UFS 文件系统同时被引入早期的 Mac OS X，随着若干年的发展，HFS+ 提供的功能已超越 UFS，使其在 Mac OS X 10.5 之后成为成为唯一正式的 Mac OS X 系统，但因为其背负许多的历史包袱，为考虑兼容性，这些陈旧的设计并不能被推翻重来，所以苹果开始秘密研发下一代的文件系统。 著名 BSD 开发者 Marshall Kirk McKusick UFS：经典的 Unix 文件系统 在 Unix 系统刚诞生的远古时期，文件系统被简单地称为 FS。FS 只包括启动块、超级块（处于硬盘分区开头用来保存文件系统信息）、inodes（索引节点）及数据。FS 文件系统在 Unix 系统刚诞生时还能满足新老客户的需求，但随着科学技术的进步，FS 已不能符合现代文件系统的需求，且会导致抖动等一系列问题。当时还是加州大学伯克利分校研究生，后成为著名 BSD 开发者 Marshall Kirk McKusick 在 BSD 4.1b 上承接传统的 FS 文件系统实现了 FFS（Fast File System），妥善地解决了这一难题，把先前整块的磁盘文件系统分为小块，每块包含自已的索引节点和数据，因而增加了文件的局部性，减少了寻道时间。由于 Marshall Kirk McKusick 的 FFS 文件系统很好很强大，所以立即被各大 Unix 系统所使用。SunOS/Solaris、System V Release 4、HP-UX 及 Tru64 UNIX 都使用它，也成为当今各 BSD 分支（FreeBSD、OpenBSD、NetBSD 及 DragonFlyBSD）的标准文件系统。每个不同的系统，无论开源与否，又会在 FFS 文件系统上增加各种扩展，这些扩展往往不互相兼容，但神奇的是，大家又都使用和原版同样的块大小和数据块宽度。因此在很大程度上，这些山寨版 FFS 文件系统又相互兼容，至少在一个操作系统上能对另一操作系统的文件系统执行只读操作。因此，FFS 事实上已经成为 Unix 系统的标准文件系统，故它有了一个更广泛的称谓——UFS（Unix File System，即 Unix 文件系统）。 UFS 在后来的若干年又取得了长足的发展。Sun 公司在 Solaris 7 系统中，给 UFS 提供了简单的日志功能。日志文件系统指在档案系统发生变化时，先把相关的信息写入一个被称为日志的区域，然后再把变化写入主文件系统的文件系统。在文件系统发生故障（如内核崩溃或突然停电）时，日志文件系统更容易保持一致性，并且可以较快恢复。Marshall Kirk McKusick 又实现了 BSD 一度引以为豪的 Soft Update 功能，来保证计算机掉电或系统崩溃时，通过使元数据按依赖顺序更新来确保磁盘上总的文件系统保持一致的实现机制。Soft Update 的目标和日志类似，但实现代价比日志轻量许多。不过这项功能有所代价，主要是需要引入一个后台 FSCK 检查。 2009 年，Jeff Roberson 正式发表了对 UFS 的一项改进，为 Soft Update 加入了日志功能，并消除了对 FSCK 的依赖，这项改进最终集成进了 FreeBSD 9 中。TrustedBSD 项目又为 BSD 分支的文件系统设计了 ACL 访问控制表功能（Access Control Lists）。先前，Unix 文件系统的访问控制是非常简单的，其权限管理分为三个不同的类别：用户、同组用户以及其他用户，对每个类别，Unix 文件系统提供读、写、执行三种权限的管理。这样的许可管理过于粗糙，无法指定某一用户访问的权限，也无法指定更为细致的权限内容（例如准许对一文件实行删除操作）。为解决这个问题，访问控制表被增加到文件系统中，使用以存取控制矩阵为基础的存取控制方法。存取控制串列描述每一个文件对象各自的存取控制，并记录可对此物件进行存取的所有主体对对象的权限。总之，UFS 与时俱进，不断增加新的功能。HFS+：更现代的 HFS 作为 Mac OS X 的老祖宗 NeXTSTEP，因为基于 BSD，所以自然也使用 UFS。而老版的 Mac OS 则使用一个叫做 HFS 的文件系统。HFS 是一个比较古老且不思进取的文件系统，因此，在 20 世纪 90 年代末已不能满足当时的需要。在《Mac OS X 背后的故事（一）》中我们提到，为了实现 Mac OS 的现代化，Copland 项目被提出。Copland 项目的子项目 Sequoia 旨在 HFS 的基础上，加入现代文件系统所必需的新功能，如大文件支持、Unicode 文件名支持、长文件名支持、32 位文件映射表支持等。Sequoia 项目即成为后来熟知的 HFS+，由 Don Brady 领导，这个团队先花了 6 个月时间把 HFS 项目原本的 Mac 使用的 68K 处理器汇编码改写成 C 代码，然后逐渐加入新功能。 后来由于 Copland 被力挽狂澜的 Ellen Hancock 给废了，所以一些有用的更新，如 HFS+ 即被集成到 Mac OS 8.1 中。在 Mac OS X 诞生初期，HFS+ 和 UFS 文件系统同时被引入早期的 Mac OS X 中。不过由于 HFS+ 根植 Mac OS，缺乏 Unix 文件系统所必需的功能，如符号链接、硬链接及其他各种 POSIX 兼容性，所以 HFS+ 开发组又花了一些工夫在不影响和 Mac OS 兼容性的情况下引入了这些功能。由于 HFS+ 是对 HFS 的扩展，故 HFS+ 支持 Mac OS 至 Mac OS X 的平滑过渡，所以 Mac OS X 一直默认使用 HFS+。但当时的 UFS 提供比 HFS+ 更先进的功能，因此 Mac OS X 10.0 至 10.4，也都支持把系统安装在 UFS 系统上。 Mac OS X 10.0 发布后，苹果不遗余力地对 HFS+ 进行大规模的扩展和维护，增加了很多 UFS 独有的功能。这些新功能使得文件系统更加安全稳定可靠。例如 Mac OS X 10.2.2 中，HFS+ 支持日志。日志功能在 Mac OS X 10.2 服务器版中可以简单地设定，但在普通桌面版中需要使用命令行进行操作。在 Mac OS X 10.3 中，带日志功能的 HFS+（被称为 HFSJ，即 HFS+ volume with journal）成为默认设置。Mac OS X 10.3 亦增加文件名、目录名区分大小写及 Unicode 3.2 的支持。Mac OS X 10.4 中，HFS+ 更是增加了 ACL 访问控制表功能，提供更复杂的对传统 Unix 文件系统权限的扩展。 文件系统除了让用户供稳定地存放文件这一目标以外，还是各项操作系统功能的基础。Mac OS X 每个大发行版都要增加数百项新功能，许多新功能严重依赖于文件系统的实现。Mac OS X 10.3 提供了 FileVault 来加密用户文件，因此用户主目录被保存在一个 HFS+ 文件系统加密镜像中。Mac OS X 10.4 提供了系统内置的 Spotlight 桌面搜寻搜索功能，能让用户对整个磁盘系统进行快速搜寻、随打即显。这项功能要求文件系统提供任意长度文件元数据（metadata）的支持。Mac OS X 10.4 转向了对 Intel 处理器的支持，因此苹果发布了一个测试版本的 BootCamp 来让用户安装 Mac OS X、Windows 双系统，并在 Mac OS X 10.5 正式集成进系统。 哪怕在 Mac OS X 系统运行，BootCamp 也可以实时调整系统主分区的大小，来空出磁盘空间给 Windows，因此，HFS+ 又需要支持动态分区大小调整。在 Mac OS X 10.5 中集成了 Time Machine，它是苹果公司所推出备份的工具程序，于 2006 年 8 月 7 日在苹果计算机全球研发者大会（WWDC）中首次公开，成为当天观众欢呼声最高的功能。Time Machine 对于修改过的文件会在备份盘上保存一个新拷贝，而对于不变的内容，仅在备份盘上存一个指向先前文件的硬链接。因此每一次快照只保存改动的文件，而别的文件只保存占用空间很少的硬链接。但 Unix 一般只支持文件的硬链接而不支持目录的硬链接。因此 HFS+ 在这点上走得比 Unix 文件系统更远，提供了对于目录的硬链接支持。在 Mac OS X 10.6 中，HFS+ 甚至支持文件系统压缩，使得安装后占用比 Mac OS X 10.5 少得多的空间。Mac OS X 10.7 提出了 FileVault2，能加密整个磁盘而不是一个用户目录。这些功能我们在为读者介绍每个发行版时亦会提到，但总之读者看到，HFS+ 的功能随着 Mac OS X 的商业需求不断被扩展。“我在做了这么多工作后回想才发现，我们为 HFS+ 增加了那么多新功能，”苹果前文件系统开发者 Don Brady 如是说。 由于 HFS+ 经过后来若干年的发展，提供的功能已不逊于 UFS，甚至更多更好，故至 Mac OS X 10.5 砍掉了安装至 UFS 的支持。HFS+ 成为唯一正式的 Mac OS X 系统。 HFS+ 并不完美 HFS+ 自发布以来，几乎每个发行版都有令人欣喜的改动。它也逐渐成为一个非常完善的文件系统。但 HFS+ 立足于 HFS 设计，HFS 已有 27 年的历史，HFS+ 亦有 14 年历史。这个文件系统有太多的历史包袱，为考虑兼容性，这些陈旧的设计并不能被推翻重来。 HFS+ 基于B-树实现，当查找B-树中未使用的节点时，HFS+ 只能每次处理 16 位，原因是老 Mac 使用的 Motorola 的 68K 芯片原生支持 16 位的数据操作。但不管是 PowerPC 还是 Intel，寄存器都支持 256 位宽的寄存器。 HFS+ 的元数据（metadata）都以大字节序保存，原因是 Motorola 的 68k 和后来 Mac 使用的 PowerPC 都使用大字节序。但经过 Intel 迁移后，当今的 Mac 都使用 Intel 芯片，而 Intel 芯片是使用小字节序的。因此每当数据读取或存入时，还要经过小字节序和大字节序的转换。远古时期磁盘很慢，计算机处理器的速度也很低，因此进行一次磁盘操作会占用较多的时间，HFS+ 的时间分辨率为一秒，但当今的磁盘、处理器处理一次文件系统操作的时间远小于一秒，因此所有主流磁盘文件系统的时间分辨率都是一至数百纳秒级别的。 HFS+ 的元数据有全局锁，同一时间只有一个进程可以访问更新文件系统。在单核处理器连手机平板都较少见到的当今，这种设计显得很幼稚。 HFS+ 亦没有稀疏文件的支持。例如我们在 SQL 中建立了一个数据库，SQL 分配了 10GB 的文件给这个数据库，并且在文件头和文件尾写上一些字节的数据。而由于我们还没有给这个数据库添加新的数据，所以这 10GB 的文件除了头尾外其他字节都为0。现代的文件系统基本都支持稀疏文件，也就是说，当处理这个数据库操作时，事实上往磁盘写入的数据只有那文件头和文件尾的若干字节。而 HFS+ 则需要把那些 0 也写上，因此会完整写入 10GB 的数据，耗费长得多的时间。 此外，HFS+ 不具备元数据校验功能、快照功能、写入时复制功能、就地执行功能、逻辑卷管理功能等很多现代磁盘系统所具备的功能，也不能动态调整文件块大小。这些功能的加入并不容易。 其中最要命的是，HFS+ 不像一些先进的文件系统，支持写入时复制事务模型，也没有快照和克隆。这使得用户数据时时处于风险之中。例如由于因为断电、内核崩溃等原因，文件系统上写到一半的数据，小则导致个别文件损坏，大则导致整个文件系统崩溃。在生产领域，这样不可靠的文件系统，很有可能带来致命的灾难。 正是由于上述这些原因，连我们介绍过的短视的 Linus Torvalds 都认为 HFS+ 是个垃圾文件系统。苹果自然受不了这种侮辱，因此，干掉 HFS+ 势在必行。用什么取代 HFS+ 呢？苹果开始秘密研发下一代的文件系统。 由于各种缺点，干掉 HFS+ 势在必行，然而用什么取代 HFS+ 呢？苹果开始秘密研发下一代的文件系统——ZFS，然而在诸多因素的干扰下，Mac OS X 的 ZFS 支持却只是昙花一现，未来文件系统之路将走向何方？ 文件系统的新时代——ZFS 为了代替 HFS+，苹果开始为研发下一代文件系统招兵买马，准备大干一场。但这时 Sun 公司的工作让苹果的员工们为之一振。 2004 年，Sun 公司发表了其杰出的文件系统ZFS。这是一个 128 位的文件系统，本为 Solaris 操作系统开发，于 2005 年 10 月 31 日并入了 Solaris开发的主干原始码。后成为一个使用 CDDL 协议条款授权的开源项目。 ZFS 是一个具有高存储容量、文件系统与卷管理概念整合、崭新的磁碟逻辑结构的轻量级文件系统，同时也是一个便捷的存储池管理系统。 ZFS 的一个重大特点就是拥有大容量。ZFS 是一个 128 位的文件系统，这意味着它能存储 1800 亿亿（18.4×1018）倍于当前 64 位文件系统的数据。ZFS 的设计如此超前以至于这个极限就当前现实而言可能永远无法遇到。项目领导 Bonwick 曾说：“要填满一个 128 位的文件系统，将耗尽地球上所有存储设备，除非你拥有煮沸整个海洋的能量。”假设每秒钟创建 1000 个新文件，达到 ZFS 文件数的极限需要约 9000 年。 此外，ZFS 的一个重要指导思想是不单单去做一个文件系统，而是实现一套完整的卷管理方案。不同于传统文件系统需要驻留于单独设备或者需要一个卷管理系统去使用一个以上的设备，ZFS 建立在虚拟的被称为“zpools”的存储池之上。每个存储池由若干虚拟设备组成。这些虚拟设备可以是原始磁碟，也可能是一 RAID1 镜像设备，或是非标准 RAID 等级的多磁碟组。于是 zpool 上的文件系统可以使用这些虚拟设备的总存储容量。 有了卷管理方案后，ZFS 走得更远，加入了快照和克隆等实用的文件系统功能。当 ZFS 写新数据时，包含旧数据的块被保留，磁盘只写入修改过的那部分数据块。所以快照的建立非常快，只存储两个快照间的数据差异，因此快照也是空间优化的。克隆指两个独立的文件系统共享一些列的块。当任何一个克隆版本的文件系统被改变时，只创建改动的数据块，因此非常快速，也占用少得多的空间。 而 ZFS 最大的贡献在于它是第一个支持写入时复制功能（COW，copy on write）的文件系统。所有文件系统中的块都包括 256 位的校验值。含有活动数据的块从来不被覆盖；而是分配一个新块，并把修改过的数据写在新块上。所有与该块相关的元数据块都被重新读、分配和重写。因此，当一个数据写入时发生了任何意外错误，原先的数据依然可以被访问，且文件系统知道哪个操作出了错误而没有完成。ZFS 的快照和克隆正是因此项技术而得以实现。 ZFS 对于用户而言，界面友好。先前 Unix的卷管理非常烦琐，FreeBSD 因此还建了一套宏伟的框架，给逻辑卷管理做深层次的抽象。而 ZFS 文件系统自带卷管理方案，几乎所有烦琐复杂的操作都能在一两条命令内完成，我用传统的卷管理工具已有近十个年头，第一次使用 ZFS 时，完全被其易用性震撼，所以我毫不犹豫地把手头所有的服务器迁移到了 ZFS。 由于 ZFS 各种美好，加上其开源性质，所有的操作系统都想支持它。Solaris、OpenSolaris 项目一直作为标准实现供其他系统参考。Pawe Jakub Dawidek 把 ZFS 移到 FreeBSD，并在 2009 年进入了 FreeBSD 7，作为 FreeBSD 第七版最耀眼的三项功能之一（另一项功能是我们先前提到的 ULE，以及 Sun DTrace 的移植工作）。NetBSD 在 2009 年正式收纳 ZFS。Linux 则麻烦得多，因为 Linux 内核的协议 GPL 是个和很多协议都水火不容的奇葩协议，ZFS 分发所采用的 CDDL 和 GPL 会产生冲突，所以一方面 FUSE提供了用户空间层面的支持；另一方面，由 Oracle 牵头，专为 Linux 开发 Btrfs，事实上就是一个 ZFS 的山寨版，可惜折腾了几年，Oracle 自己又把 Sun 收购了，且到我撰写此文时 Btrfs 依然没有正式的稳定版本发布。 昙花一现的 ZFS 梦 刚才提到，苹果在招兵买马，雇员工开发新一代的文件系统，而 Chris Emura（Apple CoreOS 的文件系统开发经理）及 Don Brady（先前提到，此人领导 HFS+ 的开发）两个富有经验的文件系统开发者却被衣服一样晾在了一边无所事事。2006 年，刚刚提到的 Pawe Jakub Dawidek 正在往 FreeBSD 迁移 Sun 的 ZFS，这项工作立刻引起了 Chris Emura 及 Don Brady 的高度兴趣。由于 ZFS 在 Unix 系统高度的可移植性，加上 Mac OS X 本就是 FreeBSD 的近亲，闲得发慌的两人立即打算往 Mac OS X 移植 ZFS。在 2007 年 4 月 6 日，FreeBSD 的移植宣告完成，等待合并进主干。一周后，两位苹果员工亦成功地完成了 Mac OS X 的移植。 苹果一看两人的 ZFS 的移植工作大有前途，立即跟进。2007 年的苹果全球开发者大会上，苹果让 Chris Emura 及 Don Brady 举办了一场小型讲话，介绍 Mac OS X 对 ZFS 的支持。这场讲话先前并没有在官方声明中告示，但讲话的报告厅依然挤满了听众。随后 ZFS 移植的源码在 Mac OS Forge 公布。在最终版的 Mac OS X 10.5 带有试验性的 ZFS 只读支持，以命令行方式提供。用户可以挂载 ZFS 的存储池，并对池中的文件系统进行读取操作。 苹果一直使移植并使用 Sun 的关键技术，除了 Java 以外，Mac OS X 10.5 的 Xcode 套件也加入了 DTrace 的支持，并提供了一个好用的图形界面 Instruments 让开发者更方便地调用 DTrace。ZFS 除了解决 HFS+ 的所有问题，提供安全可靠的文件系统基础外，还可以简化苹果许多软件的实现。例如前文提到的 Mac OS X 10.5 的 Time Machine，实现颇为烦琐，依赖于给 HFS+ 提供新功能，功能层也需要增加很多的和备份相关的代码。而 ZFS 默认就支持快照，将大大简化 Time Machine 的实现，并使该功能更稳定可靠。事实上在 2008 年 11 月 25 日，Sun 发布了 OpenSolaris 2008.11 版，其中给 GNOME 的 Nautilus 增加了一个使用 ZFS 的快照功能的图形界面插件名为 Time Slider，和苹果的 Time Machine 提供了非常相近的功能，我在使用后感觉不错。 因此在 WWDC 2008 上，Snow Leopard 被提出，其中一项很重要的卖点就是对 ZFS 的完整的读写支持。在 Mac OS X 的服务器版，苹果也将提供一套图形界面工具来方便维护人员管理 ZFS 存储池。在当时的 Snow Leopard Server 主页上，苹果声明 ZFS 将作为一项主推功能。 但好景不长，一年后的苹果开发者大会时，ZFS 相关的内容被悄悄从任何公开的文档、网站、发布会中撤下，没有给出任何的理由。Mac OS Forge 上的 ZFS 代码和页面也被苹果移除。外界有很多对此的猜测，但没有任何猜测得到苹果官方的或是哪怕离职员工的证实。 猜测之一是当时 Sun 刚被 Oracle 收购，而 Oracle 长期投资 ZFS 的竞争产品 Btrfs。因此苹果觉得 ZFS 的前途不甚明朗。 猜测之二是 ZFS 的关键技术 Copy On Write 有专利问题，NetApp 声称他们拥有 COW 的专利因此在起诉 Sun，苹果不想在当中冒风险。 猜测之三是 ZFS 和苹果的 XNU 内核有协议冲突。我虽然不学法律，但我认为这个说法不完全对，因为 ZFS 和 DTrace 一样，是以 CDDL 发布的开源软件，既然 DTrace 可以无后顾之忧地加入到 XNU 中，ZFS 也没有理由不可以。事实上，除了 Linux 这种少数使用 GPL 这类奇葩协议的内核，大多数系统的协议都不和 CDDL 冲突。FreeBSD 也好，Mac OS X 10.5 也罢，都把 ZFS 加入内核发布。 但事实上，如果把三种猜测并在一起，我们可以看到一个更全局的可能性：对于猜测之二，苹果可能并非想使用 CDDL，而是想从 Sun 买下一个私有的协议，这样一来，Sun 不但提供更好的技术支持，出了问题（比如猜测二中的专利问题）也可以让 Sun 为自己背黑锅。结果 Sun 可能和苹果价格谈不拢，加上猜测之一提到的 Sun 大势已去，让苹果觉得还不如自己造个轮子来得方便。Sun 公司开发 ZFS 的主力 Jeff Bonwick 虽不能提供详细的信息，但他基本证实了这种说法。 无论如何，Mac OS X的 ZFS 支持，如昙花一现般消失了。 未来文件系统之路走向何方 虽然 Mac OS X的 ZFS 支持被砍了，开源社区依然想继续开发 Mac OS Forge 先前版本的移植。如 MacZFS 项目不遗余力地给 Mac OS X 10.5~10.7 提供 ZFS 读写支持。Don Brady 在苹果将对 ZFS 的支持砍掉之后从工作了 20 多年的苹果离职，开了一家名为 Ten’s Complement 的公司，该公司提供 Z-410，较 MacZFS 提供更新更稳定的移植。 不过，砍了 ZFS 后的苹果目标也变得更清晰——和 Sun 的谈判让苹果觉得与其支付高额的协议费，还不如雇人自己做个新的，再说了，作为比 Sun 大得多的 IT 公司，苹果可以轻而易举地搞个更强大的东西灭了它，因为 ZFS 其实也不如传说中的那样好。 首先，时代在进步。ZFS 之后，又有很多新的和文件系统相关的研究，如 Ohad Rodeh 的论文，即成为后来 BtrFS 实现的基础，可能比 ZFS 做得更好。 其次，ZFS 是十年前开始设计的文件系统，但十年中，存储工具已发生了重大的变化。ZFS 为传统磁盘设计，但传统磁盘的市场空间已不断被 SSD、闪存的吞食。尤其是 MacBook Air 中使用的 Flash 存储器便宜好用又小巧，可能将来会在 MacBook Pro 甚至 iMac 中得到更大的推广。采用为传统磁盘优化的 ZFS 就不显得那么有吸引力。 最后，ZFS 和苹果有不同的用户群。ZFS 目标用户是大企业的工作站和服务器。在那里，大容量的存储空间、高级的卷管理显得非常重要，但苹果面对的基本都是个人用户——先前苹果还卖服务器，但后来 Xserve 都被苹果砍了。有几个个人用户需要使用到 ZFS 这些高级的功能呢？更重要的，苹果的主要利润将移到 iPhone、iPod、iPad、Apple TV 这些小设备上，ZFS 需要占用大量的内存来实现文件系统操作，在这些小设备上，内存很少，ZFS 根本跑不起来。 苹果非常清楚这些问题，工程师们现在一定在紧锣密鼓地开发下一代文件系统。在 10.7 及 10.8 中，这套文件系统并未浮出水面，但一些细节值得留意。在 10.7 中，苹果发布了 Core Storage，但并未声张。这是一套逻辑卷管理工具，类似于前文提到的 FreeBSD 的 GEOM。这个版本的 File Vault 2 亦使用 Core Storage 重写。可以看到虽然苹果在上层不断地淡化文件系统的概念，例如 iCloud 的发布和 iOS 中对于文件这一概念的故意忽略，但苹果在底层文件系统上的动作越来越大，想必在将来，苹果定会让我们感到重大的惊喜。]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac OS X 背后的故事（补充）]]></title>
    <url>%2Fmacos%2Fstory3.html</url>
    <content type="text"><![CDATA[补充内容]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 对 gdb 进行代码签名]]></title>
    <url>%2Fmacos%2Fgdb.html</url>
    <content type="text"><![CDATA[在 macOS 使用 GDB 调试 C 语言代码，必须对 gdb 进行代码签名，否则 GDB 不能运行！ 创建证书钥匙串访问打开菜单：钥匙串访问－》证书助理－》创建证书…输入证书名称，如：gdb-cert；选择身份类型：自签名根证书 （Identity Type to Self Signed Root）选择证书类型：代码签名 （Certificate Type to Code Signing）勾选：让我覆盖这些默认签名 （select the Let me override defaults） 一路继续，直到选择存放证书地址，选择：系统 设置证书自定义信任右键刚才创建的 gdb-cert 证书，选择“显示简介” （Get Info）点击“信任”，会显示可以自定义的信任选项“代码签名”选择“总是信任” （Code Signing to Always Trust） 重启！！！将证书授予gdb1$ codesign -s gdb-cert /usr/local/bin/gdb 相关链接 http://blog.csdn.net/maxwoods/article/details/44410177 https://sourceware.org/gdb/wiki/BuildingOnDarwin]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS 使用简介]]></title>
    <url>%2Fmacos%2FREADME.html</url>
    <content type="text"><![CDATA[本文列举了 macOS 配置，常用软件。 安装镜像制作123$ sudo 拖入安装包...app/Contents/Resources/createinstallmedia \ --volume 拖入U盘 --applicationpath 拖入安装包...app \ --nointeraction 安全与隐私没有允许任何来源选项的解决办法 1$ sudo spctl --master-disable ssh 免密码登录实现123$ brew install ssh-copy-id$ ssh-keygen$ ssh root@192.168.1.101 mpv 播放器中文乱码(推荐使用 iina)编辑 ~/.config/mpv/mpv.conf 文件。 12345# Subtitlessub-auto=fuzzysub-text-font-size=48sub-codepage=utf8:gb18030 iinaGitHub: https://github.com/lhc70000/iina 国内镜像：https://mirrors.tuna.tsinghua.edu.cn/iina/ 常用软件常用搜狗输入法火狐浏览器网易云音乐Chrome迅雷VirtualBox 开发atomJetBrainsToolboxAndroid Studiojdkiterm2Etcher]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPUnit 数据库测试]]></title>
    <url>%2Fphp%2Fphpunit%2Fdatabase.html</url>
    <content type="text"><![CDATA[PHPUnit 数据库测试。 1$ composer require --dev phpunit/dbunit 123456789101112131415161718192021222324252627282930313233343536373839use PHPUnit\DbUnit\TestCaseTrait;class TestExample extends TestCase&#123; use TestCaseTrait; // 设置数据库连接，必须实现 public function getConnection() &#123; // $pdo = new PDO(); $pdo = DB::connection(); return $this-&gt;createDefaultDBConnection($pdo, ':memory'); &#125; // 创建数据集，必须实现 protected function getDataSet() &#123; // return $this-&gt;createFlatXMLDataSet(__DIR__.'/db_flat.xml'); // return $this-&gt;createXMLDataSet(__DIR__.'/db.xml'); return $this-&gt;createArrayDataSet( [ 'builds' =&gt; [ [ 'id' =&gt; 1, ], [ 'id' =&gt; 2, ], ], ]); &#125; public function test()&#123; $this-&gt;assertEquals(2, $this-&gt;getConnection()-&gt;getRowCount('builds')); &#125;&#125; 参考链接 https://segmentfault.com/a/1190000008953673]]></content>
      <categories>
        <category>PHP</category>
        <category>PHPUnit</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPUnit Mock 测试]]></title>
    <url>%2Fphp%2Fphpunit%2Fmock.html</url>
    <content type="text"><![CDATA[本文介绍了 PHPUnit Mock 测试。 请注意，final、private 和 static 方法无法对其进行上桩 (stub) 或模仿 (mock). 假设 foo 函数调用了 bar 函数，那么在对 foo 函数进行单元测试会有两个问题： foo 函数依赖于 bar 函数的结果，那么在对 foo 进行单元测试的时候必然会引入 bar ，那么这样子单元测试就没意义了，如果测试不通过，那么无法保证 bug 出在 foo 还是 bar。 bar 函数可能在测试环境不可执行，那么 foo 无法获取 bar 的执行结果，从而无法对 foo 进行单元测试。 Mock 测试就是为了解决上面的问题而出现的，使用 Mock 我们可以虚拟出一个 bar 的调用，并且假设 bar 调用返回结果。如果还是听不懂，上一段代码就知道了。 12345678910class MockTest extends \PHPUnit\Framework\TestCase &#123; public function testGet() &#123; $stub = $this-&gt;createMock(\App\UserService::class); $stub-&gt;method('get')-&gt;willReturn(3); $this-&gt;assertEquals(3,$stub-&gt;get(1)); &#125;&#125; 上面的测试函数就使用到了 Mock，一行一行代码来分析： 第一行创建了一个虚拟的 UserService 对象。 第二行假设 UserService 中的 get 函数的返回值为 3。 第三行调用 $stub-&gt;get(1) 不会真的去执行 get 函数，而是根据第二行的 willReturn 函数直接返回 3。 参考链接 https://juejin.im/post/5a40a3d551882506e50cdf70]]></content>
      <categories>
        <category>PHP</category>
        <category>PHPUnit</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHPUnit 详解]]></title>
    <url>%2Fphp%2Fphpunit%2FREADME.html</url>
    <content type="text"><![CDATA[本文介绍了 PHP 单元测试框架 PHPUnit。 官方网站：https://phpunit.de/ GitHub：https://github.com/sebastianbergmann/phpunit 安装composer 引入执行命令。 1$ composer require --dev phpunit/phpunit 使用1234567891011use PHPUnit\Framework\TestCase;// 被测试的类加 Testclass ClassTest extends TestCase&#123; // test 加被测试的函数 public function testFunction() // code&#125; 不用另外编写测试代码1234567891011121314class Calculator &#123; /** * @assert (0, 0) == 0 * @assert (0, 1) == 1 * @assert (1, 0) == 1 * @assert (1, 1) == 2 */ public function sum($a, $b) &#123; return $a + $b; &#125; &#125; 1$ phpunit --skeleton Calculator.php 命令参数1--coverage-* # clover crap4j html php text 为运行的测试生成带有代码覆盖率信息的日志文件 示例 https://github.com/khs1994-php/tencent-ai]]></content>
      <categories>
        <category>PHP</category>
        <category>PHPUnit</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPUnit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP trait]]></title>
    <url>%2Fphp%2Foop%2Ftrait.html</url>
    <content type="text"><![CDATA[通过 trait 可以实现多继承。 12345678910111213141516171819202122232425262728293031trait A&#123; public function fun1() &#123; echo __FUNCTION__; &#125;&#125;trait B&#123; public function fun2() &#123; echo __FUNCTION__; &#125;&#125;// trait 中可以使用其他 traittrait D&#123; use A, B;&#125;class C&#123; // 可以使用 use 列出多个 trait use A,B;&#125;$c=new C();$c-&gt;fun1();]]></content>
      <categories>
        <category>PHP</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 多态]]></title>
    <url>%2Fphp%2Foop%2Fpolymorphism.html</url>
    <content type="text"><![CDATA[使用接口和类型提示实现多态 根据使用类的上下文来重新定义或改变类的性质和行为 不同的对象，执行相同的方法，而又取得不同的结果 1234567891011121314151617181920212223242526272829303132interface Animal&#123; public function eat();&#125;class Cat implements Animal&#123; public function eat()&#123; echo "cat eat"; &#125;&#125;class Dog implements Animal&#123; public function eat()&#123; echo "dog eat"; &#125;&#125;class Demo&#123; public function eat(Animal $animal) &#123; $animal-&gt;eat(); &#125;&#125;$demo=new Demo;$demo-&gt;eat(new Dog());$demo-&gt;eat(new Cat());]]></content>
      <categories>
        <category>PHP</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 重载]]></title>
    <url>%2Fphp%2Foop%2Foverride.html</url>
    <content type="text"><![CDATA[overloading 动态地「创建」类属性和方法，通过魔术方法实现。 当调用当前环境下未定义或不可见的类属性或方法时，重载方法会被调用。 属性重载 __set(string $name,mixed $value) 给不可访问属性赋值时 __get(string $name) 读取不可访问属性 __isset(string $name) 对不可访问属性调用 isset() empty() __unset(string $name) 对不可访问属性调用 unset() 方法重载 __call(string $name,array $arguments) 在对象中调用不可访问的方法 __callStatic(string $name,array $arguments) 在对象中调用不可访问的静态方法]]></content>
      <categories>
        <category>PHP</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 接口]]></title>
    <url>%2Fphp%2Foop%2Finterface.html</url>
    <content type="text"><![CDATA[使用接口 interface，可以指定某个类必须实现哪些方法，但不需要（也不能）定义这些方法的具体内容。 要实现一个接口，使用 implements 操作符。 接口中定义的所有方法都必须是公有，这是接口的特性。 接口可以继承另一个接口，接口可以一次继承多个接口。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657interface D&#123; public function fun4();&#125;interface A&#123; // 接口常量不能被子类或子接口覆盖 const VERSION='0.0.1'; // 接口中的方法都没有具体实现 public function fun1(); public function fun2($num);&#125;interface C extends D&#123; public function fun3();&#125;// 一个类可以实现多个接口class B implements A, D&#123; // 子类中必须实现接口中定义的所有方法 public function fun1() &#123; echo __FUNCTION__; &#125; // 参数要求与抽象类一致 public function fun2($num, $num2=0) &#123; echo $num; &#125; public function fun3() &#123; echo __FUNCTION__; &#125; public function fun4() &#123; echo __FUNCTION__; &#125;&#125;// 接口不能被实例化$b=new B();$b-&gt;fun1();]]></content>
      <categories>
        <category>PHP</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 抽象类]]></title>
    <url>%2Fphp%2Foop%2Fabstract.html</url>
    <content type="text"><![CDATA[使用 abstract 关键字申明抽象类和抽象方法。抽象类不能被实例化，只能被其他类继承。 抽象类中可以有非抽象方法。 抽象方法没有（也不能有）具体实现。 12345678910111213141516171819202122232425262728293031323334353637383940abstract class A&#123; // 抽象方法没有函数体，即具体实现 abstract protected function fun1(); abstract protected function fun2($num); // 普通方法，即非抽象方法 public function fun3() &#123; echo __FUNCTION__; &#125;&#125;class B extends A&#123; // 子类必须定义抽象类中的所有抽象方法 public function fun1() &#123; echo __FUNCTION__; &#125; // 子类方法的访问控制，必须和抽象类中方法的访问控制一致，或更为宽松 // 参数必须一致，但子类可以定义父类方法中不存在的可选参数 public function fun2($num, $num2='0') &#123; echo $num; &#125;&#125;// 抽象类不能被实例化$b=new B();$b-&gt;fun2(1);]]></content>
      <categories>
        <category>PHP</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 面向对象]]></title>
    <url>%2Fphp%2Foop%2FREADME.html</url>
    <content type="text"><![CDATA[面向对象三大特性：封装、继承、多态。 官方文档：http://php.net/manual/zh/language.oop5.php 要创建一个类的实例，必须使用 new 关键字。如果该类属于一个命名空间，则必须使用其完整名称。 你可以使用 ClassName::class 获取一个字符串，包含了类 ClassName 的完全限定名称。 常用关键字当一个方法在类定义内部被调用时，有一个可用的伪变量 $this。$this-&gt;属性 $this-&gt;方法() $this::方法、常量、静态属性（和 self 一致） 使用 self:: 来访问方法、常量、静态属性。 使用 static:: 后期 静态绑定 ，static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。 使用 parent:: 来访问父类的方法和静态变量。 在类定义内部，可以用 new self 和 new parent 创建新对象。 常量、属性、方法属性 中的变量可以初始化，但是初始化的值必须是常数，这里的常数是指 PHP 脚本在编译阶段时就可以得到其值，而不依赖于运行时的信息才能求值。 123456789/*** 类常量可设置可见性** @since 7.1*/class A&#123; public const VERSION = '18.03';&#125; 静态 static 关键字 静态方法 静态属性 访问控制 private protected public 自动加载123spl_autoload_register(function ($class_name) &#123; require_once $class_name . '.php';&#125;); 魔术方法构造函数、析构函数 __construct() __destruct() 析构函数即使在使用 exit() 终止脚本运行时也会被调用。在析构函数中调用 exit() 将会中止其余关闭操作的运行。 重载 动态地 创建 类属性和方法 __call() __callStatic() __get() __set() __isset() __unset() 其他 __sleep() 常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。serialize() 序列化对象时，首先调用该魔术方法。 __wakeup() 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。unserialize() 反序列对象时，首先被调用。 __toString() 方法用于一个类被当成字符串时应怎样回应，例如 echo $obj。 __invoke() 当尝试以调用函数的方式调用一个对象时，此方法会被调用。例如 obj($arg)。 __set_state() 当调用 var_export() 导出类时，此静态方法会被调用。 __clone() 对象被复制时被调用 __debugInfo() 对对象使用 var_dump() 时，该方法被调用。例如 var_dump(new MyClass(42)); 多态使用接口和类型提示实现多态 根据使用类的上下文来重新定义或改变类的性质和行为 不同的对象，执行相同的方法，而又取得不同的结果 对象继承 extends一个类可以在声明中用 extends 关键字继承另一个类的方法和属性。 子类可以覆盖父类的属性或方法，当覆盖方法时，参数必须保持一致，否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数。 子类可以通过 -&gt; 调用父类的静态方法。 final 禁止继承如果父类中的方法被声明为 final，则子类无法覆盖该方法。如果一个类被声明为 final，则不能被继承。 用于 类 和 方法 前。 抽象类 abstract抽象类中的抽象方法不能有具体实现。 抽象类中的普通方法有具体的实现。 抽象类不能被实例化。用于被其他类继承，子类必须定义抽象类中 所有的 抽象方法。 接口 interface接口中的方法不能有具体实现。 接口中的方法必须公有。 实现接口 implements实现接口的类必须实现接口中定义的 所有的 方法。 一个类可以实现多个接口，使用逗号分隔。 接口也可以继承接口 extends。接口可以继承多个接口。 接口常量不能被覆盖。 多继承 trait一个类使用多个 trait使用 use，并用逗号分隔。 12345class MyClass &#123; use Hello, World; public function ...&#125; 对象比较遍历对象类型约束略 后期静态绑定 static::static:: 不再被解析为定义当前方法所在的类，而是在实际运行时计算的。也可以称之为 “静态绑定”，因为它可以用于（但不限于）静态方法的调用。 对象和引用对象序列化1234567891011121314151617181920212223242526272829// classa.inc:class A &#123; public $one = 1; public function show_one() &#123; echo $this-&gt;one; &#125;&#125;// page1.php:include("classa.inc");$a = new A;$s = serialize($a);// 把变量$s保存起来以便文件page2.php能够读到file_put_contents('store', $s);// page2.php:// 要正确了解序列化，必须包含下面一个文件include("classa.inc");$s = file_get_contents('store');$a = unserialize($s);// 现在可以使用对象$a里面的函数 show_one()$a-&gt;show_one(); 对象复制 __clone() 魔术方法深拷贝、浅拷贝 12345678910111213class AB&#123; public $a = 1; public $b = 2; public function __clone()&#123; echo "对象被克隆了"; $this-&gt;a=2; &#125;&#125;$ab = new AB();$abc = clone $ab; PHP 7 新特性匿名类12345678$a = (new class &#123; public function log($msg) &#123; echo $msg; &#125;&#125;);$a-&gt;log('hello');]]></content>
      <categories>
        <category>PHP</category>
        <category>OOP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 依赖管理工具 Composer]]></title>
    <url>%2Fphp%2Fcomposer%2FREADME.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/composer/composer 官方网站：https://getcomposer.org/ http://docs.phpcomposer.com/04-schema.html#Root-Package 版本表示方法https://cuiqingcai.com/3494.html ~1.2 ^1.2 没有区别 ~ ~1.2 相当于 &gt;=1.2 &lt;2.0.0 而 ~1.2.3 相当于 &gt;=1.2.3 &lt;1.3.0 ^ ^1.2.3 相当于 &gt;=1.2.3 &lt;2.0.0 1.0 以下较特殊 ^0.3 会被当作 &gt;=0.3.0 &lt;0.4.0 稳定性标志 dev、alpha、beta、RC、stable 本地开发从 本地 路径加载 123456"repositories":&#123; "tilte": &#123; "type":"path", "url":"/path/my-package" &#125;&#125; 从 VCS 加载包1234567891011121314151617181920212223242526272829303132333435363738394041&#123; "repositories": [ &#123; "type": "composer", "url": "http://packages.example.com" &#125;, &#123; "type": "composer", "url": "https://packages.example.com", "options": &#123; "ssl": &#123; "verify_peer": "true" &#125; &#125; &#125;, &#123; "type": "vcs", "url": "https://github.com/Seldaek/monolog" &#125;, &#123; "type": "pear", "url": "http://pear2.php.net" &#125;, &#123; "type": "package", "package": &#123; "name": "smarty/smarty", "version": "3.1.7", "dist": &#123; "url": "http://www.smarty.net/files/Smarty-3.1.7.zip", "type": "zip" &#125;, "source": &#123; "url": "http://smarty-php.googlecode.com/svn/", "type": "svn", "reference": "tags/Smarty_3_1_7/distribution/" &#125; &#125; &#125; ]&#125; 安装下载地址 https://getcomposer.org/download/ https://github.com/composer/composer/releases 下载之后移入 PATH (/usr/local/bin)，改名为 composer 中国镜像注意关注镜像网站，部分镜像可能不可用 1234# 不可用$ composer config -g repo.packagist composer https://packagist.phpcomposer.com$ composer config -g repo.packagist composer https://packagist.laravel-china.org https://pkg.phpcomposer.com/ macOS1$ brew install composer 开发一个 SDKGitHub：https://github.com/khs1994-docker/php-demo 1$ composer create-project --prefer-dist khs1994/example sdk @dev GitHub 设置 之前在 github 添加 service 的方法已经废弃，请 PHPer 注意按以下方法升级 首先在 https://github.com/settings/applications 把 Packagist Revoke 掉。 之后在 https://packagist.org 选择 github 账号登录，授予权限的时候注意将 GitHub 组织(如果有的话) 的权限一并勾选。 在 My packages 界面没有看到警告即可。 https://packagist.org/about#how-to-update-packages 在项目中使用12345$ composer require khs1994/qq-login @dev# 只在开发环境使用某包$ composer require --dev phpunit/phpunit 自动加载123&lt;?phprequire __DIR__."/vendor/autoload.php"; dist 和 源码dist 是打包版本 --prefer-dist 想要克隆源码加上 --prefer-source]]></content>
      <categories>
        <category>PHP</category>
        <category>Composer</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Composer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP JWT 详解]]></title>
    <url>%2Fphp%2Fauth%2Fjwt.html</url>
    <content type="text"><![CDATA[header.poyload.sign 官方网站：https://jwt.io/ 1$ composer require firebase/php-jwt JWT 由三部分组成。 12345678910111213141516eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c&#123; "alg": "HS256", "typ": "JWT"&#125;&#123; "sub": "1234567890", "name": "John Doe", "iat": 1516239022&#125;# 对上边两部分拼接成的字符串选择算法进行加密，生成 sign 签名 用户输入 username、password 登录。 服务器验证 username password 获取用户信息，生成 token，返回 token token 存入 cookie 认证过程 请求头中加入 Authorization: Bearer YOUR_JWT 服务器解密 token 验证过期时间，验证权限 返回结果]]></content>
      <categories>
        <category>PHP</category>
        <category>Auth</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP OAuth2 详解]]></title>
    <url>%2Fphp%2Fauth%2Foauth.html</url>
    <content type="text"><![CDATA[开放式授权。 这里以 QQ 代替 OAuth 服务器。 网站放置网址用户点击网站请求 QQ 登录页Request Token URL 未授权的令牌请求服务地址: QQ 服务器地址+特定参数 client_id （站点 ID） redirect_uri (回调地址) 用户输入用户名、密码QQ 给网站返回结果跳转到网站回调地址，带有特定参数 code 网站获取 code 参数 网站再次向 QQ 发起请求 User Authorization URL 用户授权的令牌请求服务地址: QQ 服务器+特定参数 client_id (站点 ID) client_secret (站点密钥) code （有有效期） 然后 QQ 服务器返回包含用户信息的结果，网站解析之后跳转页面 返回数据包含 AccessToken (有有效期) 网站跳转获取信息网站可以使用 AccessToken 从 QQ 获取用户的信息。 RefreshToken 刷新 AccessToken]]></content>
      <categories>
        <category>PHP</category>
        <category>Auth</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 命名空间]]></title>
    <url>%2Fphp%2Fbasic%2Fnamespace.html</url>
    <content type="text"><![CDATA[PHP 命名空间解决了可能发生的冲突的问题。 http://php.net/manual/zh/language.namespaces.php 一般规则 文件路径 + 类名（文件名与类名保持一致） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950namespace A\B; // 定义命名空间，在所有代码之前声明，除了 declare()/*** use 关键字导入命名空间* namespace 与 use 之间空一行*//*** @since 7.0 分组命名空间，7.2 允许尾部逗号*/use Foo\Bar\&#123; Foo, Bar, Baz,&#125;;use Error; // 全局空间use Foo\Bar as BarBase; // 别名use function C\D\functionName as func;use const C\D\CONSTANT;function a()&#123;&#125;class A&#123;&#125;// PHP 支持两种抽象的访问当前命名空间内部元素的方法，__NAMESPACE__ 魔术常量和 namespace 关键字。namespace\a();$my_class = __NAMESPACE__ . '\\A';$obj = new $my_class();// 在命名空间内，用一个变量来动态调用类，必须加上命名空间。// $my_class_error = 'A';// $obj = new $my_class_error();$f = \fopen(); // 调用全局的函数]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 变量与常量]]></title>
    <url>%2Fphp%2Fbasic%2Fvariables_constants.html</url>
    <content type="text"><![CDATA[本文介绍了 PHP 变量与常量。 http://php.net/manual/zh/language.variables.php http://php.net/manual/zh/language.constants.php 静态变量静态变量仅在局部函数域中存在，但当程序执行离开此作用域时，其值并不丢失。 123456function test()&#123; static $a = 0; echo $a; $a++;&#125; global 关键字$GLOBALS 数组可变变量123$a='hello';$$a='world'; // 即 $hello='world'; 超全局变量 $GLOBALS $_SERVER 服务器和执行环境信息 $_POST $_GET $_REQUEST $_FILES $_SESSION $_COOKIE $_ENV 环境变量 其他预定义变量 $http_response_header HTTP 相应头 $argc 传递给脚本的参数 数目 $argv 传递给脚本的参数数组 常量常量的范围是全局的，常量一旦定义就不能被重新定义或者取消定义。 常量的值只能是标量。 定义常量123define('FOO', 'bar');const FOO = 'bar'; const 不能用在函数、循环、if 语句之内。 获取常量 constant() 获取常量值。 get_define_constants() 获得所有已定义的常量。 魔术常量 http://php.net/manual/zh/reserved.constants.php __LINE__ __FILE__ __DIR__]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP-FIG 规范]]></title>
    <url>%2Fphp%2Fbasic%2FREADME.html</url>
    <content type="text"><![CDATA[PHP-FIG 规范 官方网站 https://www.php-fig.org/ GitHub https://github.com/php-fig https://laravel-china.org/docs/psr 必须启用严格模式1declare(strict_types=1); 编码规范关键字必须小写 true, false, null。 类类的 属性 和 方法 必须添加访问修饰符 private、protected 以及 public。 abstract 以及 final 必须声明在访问修饰符之前。 static 必须声明在访问修饰符之后。 类名大驼峰 StudlyCaps 方法小驼峰 cameCase 各个方法之间有一个空行。 属性一定不可 使用关键字 var 声明一个属性。 类的属性命名可以遵循 大写开头的驼峰式 ($StudlyCaps)、小写开头的驼峰式 ($camelCase) 又或者是 下划线分隔式 ($under_score)，无论遵循哪种命名方式，都应该在一定的范围内保持一致。这个范围可以是整个团队、整个包、整个类或整个方法。 常量类常量 大写 + 下划线 FOO_BAR 1const APP_KEY = 1; 函数名小写 + 下划线 json_to_array 各个函数之间有一个空行。 如果 return 语句之前只有一行 PHP 代码，return 语句之前不需要空行。 如果 return 语句之前有至少有两行 PHP 代码，return 语句之前加一个空行。 变量小驼峰 cameCase 常量大写 + 下划线 APP_KEY 依赖管理使用 composer 管理依赖。 More Information https://github.com/PizzaLiu/PHP-FIG/blob/master/PSR-2-coding-style-guide-cn.md]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 错误和异常处理]]></title>
    <url>%2Fphp%2Fbasic%2Ferror_exception.html</url>
    <content type="text"><![CDATA[PHP 7 可以通过 try_catch 来捕获错误 Error 和异常 Exception。 http://php.net/manual/en/class.exception.php http://php.net/manual/en/class.throwable.php 参考资料 如何捕获语法解析错误 https://segmentfault.com/a/1190000014926703 ini 设置生产环境中不启用错误显示。 打开错误报告php.ini1234567error_reporting = E_ALL # 错误报告级别display_errors = On # 是否显示错误log_errors = On # 是否记录日志error_log = /var/log/php-fpm/php/error.log 脚本中设置 http://php.net/manual/en/errorfunc.constants.php 1234567ini_set("display_errors",'On');ini_set("error_reporting" ,'32767'); # php5.3 30719 php5.2 6143 previousliy 2047ini_set("error_log", "日志文件路径");ini_set("log_errors", 'on'); 错误报告级别 http://php.net/manual/en/class.throwable.php E_[ALL | ERROR | WARNING | PARSE | NOTICE | STRICT | RECOVERABLE_ERROR | E_DEPRECATED] E_CORE_[ERROR | WARNING] E_COMPILE_[ERROR | WARNING] E_USER_[ERROR | WARNING | NOTICE | DEPRECATED] 错误与异常捕获可以像捕获异常那样来捕获错误。 12345678910111213141516171819202122232425try &#123; new A;&#125; catch (\Error $e) &#123; echo $e-&gt;getMessage(); // Class 'A' not found&#125;try &#123; throw new Exception('发生异常');&#125; catch (\Exception $e) &#123; echo $e-&gt;getMessage(); // 发生异常&#125;/** 一个 catch 使用管道（|）捕获多个错误或异常。** @since 7.1*/try&#123;&#125;catch (MyException | MyOtherException $e)&#123;&#125; 错误与异常种类 https://segmentfault.com/a/1190000004219265#articleHeader0 https://github.com/khs1994-php/error Error 和 Exception 都实现了 Throwable 接口。 ArithmeticError 算术运算错误 DivisionByZeroError 除数为 0 时错误 AssertionError 断言错误 ParseError 语法错误 TypeError 函数类型错误（1.参数类型约束；2.返回值类型约束；3.参数个数少于函数参数） ArgumentCountError 参数错误，函数传入参数个数少于函数参数。 自定义异常类和错误类 https://github.com/khs1994-php/qq-login/blob/master/src/QQLogin/Error/QQError.php]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 流程控制]]></title>
    <url>%2Fphp%2Fbasic%2Fcontrol_structures.html</url>
    <content type="text"><![CDATA[PHP 流程控制 http://php.net/manual/zh/language.control-structures.php 123456789101112131415$a = 0;switch ($a)&#123; // switch(true) case $a &gt;= 0: echo 0; break; case $a &gt;=10: echo 1; break; default: echo 2; break;&#125;exit(); 结果为 1。switch($a) 实际为 switch(false)，所以匹配 false 123456789if (condition) &#123; # code...&#125;if (condition) &#123; # code...&#125; else &#123; # code...&#125; 123456789switch (variable) &#123; case 'value': # code... break; default: # code... break;&#125; 123while ($a &lt;= 10) &#123; # code...&#125; 123do &#123; # code...&#125; while ($a &lt;= 10); 123for ($i=0; $i &lt; ; $i++) &#123; # code...&#125; 123foreach ($variable as $key =&gt; $value) &#123; # code...&#125; 1234567goto a;echo 'Foo';a:echo 'Bar';// 结果 Bar]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP curl 详解]]></title>
    <url>%2Fphp%2Fbasic%2Fcurl.html</url>
    <content type="text"><![CDATA[本文详细记录了 PHP 使用 curl 遇到的问题。 http://php.net/manual/zh/book.curl.php GitHub：https://github.com/khs1994-php/curl Windows Curl SSLhttps://curl.haxx.se/docs/caextract.html 点击最新的日期，下载文件放到 c:\cacert-2018-03-07.pem php.ini 增加如下配置 1curl.cainfo="c:\cacert-2018-03-07.pem" 初始化1$ch=curl_init(); 设置网址1curl_setopt($ch, CURLOPT_URL, $url); post123curl_setopt($ch, CURLOPT_POST, 1);curl_setopt($ch, CURLOPT_POSTFIELDS, $data) post 表单1234567$data=[ $media=new CURLFile($filePath)];# 旧版本是 @加文件名，新版已废弃。curl_setopt($ch, CURLOPT_POSTFIELDS, $data); https1234567891011121314151617curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, 1);// 设置 CA 根证书路径curl_setopt($ch, CURLOPT_CAINFO, $value);// 检查证书域名curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, $value);// 设置私钥路径curl_setopt($ch, CURLOPT_SSLKEY, $value);// 设置公钥路径curl_setopt($ch, CURLOPT_SSLCERT, $value); htpasswd1curl_setopt($ch, CURLOPT_USERPWD, $user.':'.$password); 参考链接 http://blog.csdn.net/linvo/article/details/8816079 https://segmentfault.com/a/1190000006220620]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 日期相关函数]]></title>
    <url>%2Fphp%2Fbasic%2Fdate.html</url>
    <content type="text"><![CDATA[设置时区 http://php.net/manual/zh/function.date.php 123date_default_timezone_get();date_default_timezone_set('PRC'); 时间戳1time(); 得到指定时间的时间戳 1mktime( [$hour, $min, $sec, $mon, $day, $year]); 将英文文本的日期或时间转换成时间戳 123strtotime($time [, $now]);strtotime('+1 day'); 微秒 123microtime(); // 0.17627900 1519217007microtime(true); // 1519217011.4827 输出时间123date($format [, $timestamp]);date('Y/m/d H:i:s'); 其他 getdate() 返回包含日期时间的数组 gettimeofday() 返回包含时间信息的数组 checkdate() 验证时间是否合法]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP JSON XML YAML 相关函数]]></title>
    <url>%2Fphp%2Fbasic%2Fjson_xml.html</url>
    <content type="text"><![CDATA[本文介绍了 JSON XML YAML 相关函数。 JSON http://php.net/manual/zh/book.json.php json_encode() 将 数组 编码为 json 1json_encode($value [, $options, $depth]); $options中文 JSON_UNESCAPED_UNICODE 以字面编码多字节 Unicode 字符（默认是编码成 \uXXXX） json_decode() 将 json 解码为数组 1json_decode($json [, $assoc, $depth, $options]); XML http://php.net/manual/zh/refs.xml.php YAML http://php.net/manual/zh/book.yaml.php yaml 转数组 yaml_parse() 数组转 yaml yaml_emil()]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 执行 Shell 命令]]></title>
    <url>%2Fphp%2Fbasic%2Fshell.html</url>
    <content type="text"><![CDATA[主要有 exec() shell_exec() system() popen()。 exec()1string exec(string $command [, array $output [, int $return_var ]] ) 返回最后一条结果。 如果使用了 output 参数，shell 命令的每行结果会填充到该数组中。 shell_exec()1string shell_exec(string $cmd) 以 字符串 形式返回执行的全部结果。 system()1string system(string $command [, int $return_value]) 输出全部结果。 成功则返回命令输出的最后一行， 失败则返回 FALSE popen()123456789$ph=popen('ls','r');// 返回类型为资源// 读取命令执行结果var_dump(stream_get_contents($ph));pclose($ph); 反引号反引号不能在双引号字符串中使用。 1echo `ls`; 其他请查看：http://php.net/manual/zh/ref.exec.php]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 文件相关函数]]></title>
    <url>%2Fphp%2Fbasic%2Fstorage.html</url>
    <content type="text"><![CDATA[本文介绍了 PHP 文件的相关函数。本文只是部分列举，详情请查看官方文档。 http://php.net/manual/zh/book.dir.php http://php.net/manual/zh/book.filesystem.php 读取文件最后一行12345678910111213$pos = -2; //偏移量$eof = " "; //行尾标识$data = "";while ($line &gt; 0)&#123;//逐行遍历 while ($eof != "\n")&#123; //不是行尾 fseek($fp, $pos, SEEK_END);//fseek成功返回0，失败返回-1 $eof = fgetc($fp);//读取一个字符并赋给行尾标识 $pos--;//向前偏移 &#125; $eof = " "; $data .= fgets($fp);//读取一行 $line--;&#125; HTML 上传文件1234&lt;form action="url" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="name" id='file' /&gt; &lt;input type="submit" /&gt;&lt;/form&gt; PHP 会将文件存到临时文件中，脚本结束就会销毁，所以必须存到另外的位置。 12345678910111213141516171819$file = $_FILE['file'];// 文件名$file['name'];// 类型$file['type'];// 临时文件名$file['tmp_name'];// error$file['error'];// size$file['size'];// 保存文件move_uploaded_file($_FILES['file']['tmp_name'], '/path/filename'); 获取路径 执行命令所在路径 getcwd() 文件所在路径 __FILE__ 文件所在目录路径 __DIR__ dirname(__FILE__) 目录相关函数1resource opendir( string $path [, resource $context ] ) 打开一个目录句柄，可用于之后的 closedir() readdir() rewinddir()。 12345678if (is_dir($dir)) &#123; if ($dh = opendir($dir)) &#123; while (($file = readdir($dh)) !== false) &#123; echo "filename: $file : filetype: " . filetype($dir . $file) . "\n"; &#125; closedir($dh); &#125;&#125; readdir() 从目录句柄中读取条目。 chdir() 改变目录 chroot() 改变根目录 closedir() 关闭目录句柄 dir() 返回一个 Directory 类实例 1234567$d=dir($path);$d-&gt;handle;$entry=$d-&gt;read();$d-&gt;close(); getcwd() 取得当前工作目录 rewinddir() 倒回目录句柄 scandir() 列出指定路径中的文件和目录 1array scandir ( string $directory [, int $sorting_order [, resource $context ]] ) 返回包含文件和目录的数组。 SPLSplFileInfo12345$file = SplFileInfo('file');$file-&gt;getExtension();$file-&gt;getRealPath(); SplFileObject12345$file = new SplFileObject($file_name [, $open_mode, $use_include_path, $context])$file-&gt;eof();$file-&gt;fgets(); 文件操作相关函数 更改权限 chgrp() chmod() chown() 复制 copy() 删除 unlink() unset() 判断 is_dir() is_file() is_executable() is_link() 读写文件官方文档：http://php.net/manual/zh/function.file-get-contents.php file_get_contents($filePath) file_put_contents($filePath, $content) 可以通过设置第三个参数，将内容追加，而不是覆盖。 官方文档：http://php.net/manual/zh/function.stream-get-contents.php stream_get_contents($resource) 读取资源流到一个字符串 stream_context_create($array) 创建资源流上下文，参数必须为 关联数组 官方文档：http://php.net/manual/zh/function.fopen.php 123456789101112131415$fh = fopen($filePath, $mode);// 返回类型为资源fgetc($fp); // 读取一个字符fgets($fh); // 读取一行fread($fh, $length);fwrite($fh, $string);fclose($fh);file($filePath); // 返回结果为数组，一行一个值]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Session]]></title>
    <url>%2Fphp%2Fbasic%2Fsession.html</url>
    <content type="text"><![CDATA[Session 保存在服务端。保存在超全局变量 $_SESSION。 http://php.net/manual/zh/book.session.php Session 文件驱动注意 阻塞 问题。 Session 过期1234567session.gc_maxlifetime=1440session.gc_probability=1session.gc_divisor=1000 # divisor 除数、分母; 回收概率 session.gc_divisor 与 session.gc_probability 合起来定义了在每个会话初始化时启动 gc 进程的概率。此概率用 gc_probability/gc_divisor 计算得来。例如 1/100 意味着在每个请求中有 1% 的概率启动 gc 进程。 比如：session.gc_maxlifetime=30，session.gc_divisor=1000，session.gc_probability=1，就表示每一千个用户调用 session_start() 就百分百的会执行一次垃圾回收机制。 所以过期 session 是由 gc 处理的，不是自己自动消失的。 假设 gc_maxlifetime=120 如果某个 session 文件最后修改时间是 120 秒之前，那么在下一次回收（ 1/100 的概率）发生前，这个 session 仍然是有效的。所以并不是 session 过了有效期，就一定访问不到！ 严格控制过期时间 http://www.laruence.com/2012/01/10/2469.html 设置 Cookie 过期时间 30 分钟, 并设置 Session 的 lifetime 也为 30 分钟. 自己为每一个 Session 值增加 Time stamp. 每次访问之前, 判断时间戳. 123456789101112ini_set('session.gc_maxlifetime', "1800"); // sini_set('session.cookie_lifetime', '1800'); // sif(isset($_SESSION['expiretime'])) &#123; if($_SESSION['expiretime'] &lt; time()) &#123; unset($_SESSION['expiretime']); header('Location: logout.php?TIMEOUT'); // 登出 exit(0); &#125; else &#123; $_SESSION['expiretime'] = time() + 3600; // 刷新时间戳 &#125;&#125; 设置 Session12345session_start([$options]);$_SESSION(['username'])='username';session_write_close(); PHPSESSIONID 保存在服务端文件中，也将 id 保存在 Cookie 中，也可以通过 url 传递。 通过 Cookie 设置 Session 生存期1234567session_id(); // 设置 session idsession_name(); // 设置 session name，以上两个必须在 start 之前调用。session_start();setcookie(session_name(),session_id(),time()+3600) 传递 Session id]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Cookie]]></title>
    <url>%2Fphp%2Fbasic%2Fcookie.html</url>
    <content type="text"><![CDATA[Cookie 保存在客户端，分为 内存 Cookie 和 硬盘 Cookie。 http://php.net/manual/zh/function.setcookie.php 设置 Cookie1setcookie($name [, $value, $expires, $path, $domain, $secure, $httponly]) $expires 时间戳 $path 有效路径，默认是当前目录及其子目录 $domain 作用域，默认在本域下 $secure 只能通过 https 传输 $httponly 只使用 HTTP 访问 Cookie，如果设置为 true，客户端 JS 无法操作、无法读取这个 Cookie 1234567/*** 参数相同** 不会对值进行 `urlencode()` 编码*/setrawcookie() 读取 Cookie存储在 超全局变量 中 $_COOKIE 更新 Cookiesetcookie() 设置新值 删除 Cookie1setcookie($key,'',time()-1) header 操作 Cookie1header("Set-Cookie:name=value[;expires=data]") 数组形式的 Cookie12setcookie('userInfo[username]','username')setcookie('userInfo[email]','khs1994@khs1994.com')]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 函数]]></title>
    <url>%2Fphp%2Fbasic%2Ffunction.html</url>
    <content type="text"><![CDATA[PHP 函数简介。 常用函数 sys_get_temp_dir() 返回用于临时文件的目录 htmlspecialchars() 将特殊字符转换为 HTML 实体 匿名函数123456789101112131415161718$example=function ($arg)&#123; echo $arg;&#125;;$example(1);# 使用 use 使用外部变量$message='hello';$example=function () use ($message)&#123; return $message;&#125;$example();# use 引用变量# 略 把第一个参数作为回调函数调用。 call_user_func($callback,$parameter,$parameter2) call_user_func_array($callback,$array) 类型约束参数匿名函数类型 Closure。 返回值1234567891011121314151617181920declare(strict_types=1);class C &#123;&#125;function getC(): C // 限定返回类型&#123; return new C;&#125;var_dump(getC());/*** :void 表明函数不返回数据** @since 7.1*/function fun1(): void&#123; return;&#125; 可变函数将函数名赋值给变量，通过变量调用函数。 12345678function a()&#123;&#125;$var='a';$var(); // 调用函数 a 同理，也可以将类的方法赋值给变量，通过调用变量调用方法。 函数参数可变参数123456function fun1(...$a)&#123; var_dump($a); // array&#125;fun1(1, 2, 3, 4);]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 认证总结]]></title>
    <url>%2Fphp%2Fauth%2FREADME.html</url>
    <content type="text"><![CDATA[PHP 实现多种认证方式总结。本文对 C-S 方式进行简单总结，其他方式请本查看分类下的文章。 Cookie Session 认证]]></content>
      <categories>
        <category>PHP</category>
        <category>Auth</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 系统内置常量]]></title>
    <url>%2Fphp%2Fbasic%2Fconst.html</url>
    <content type="text"><![CDATA[本文列举了 PHP 内置的常量。 PHP_EOL 换行符 DIRECTORY_SEPARATOR 路径分割符（Linux / Windows \） PATH_SEPARATOR 多路径分割符（Linux : Windows ;）]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 数组相关函数]]></title>
    <url>%2Fphp%2Fbasic%2Ftypes%2Farray.html</url>
    <content type="text"><![CDATA[本文列举了 PHP 数组相关函数。 常用函数 count(mixed $var [, int $mode = COUNT_NORMAL]) 数组长度，也可以返回对象的属性个数 list($a, $b, $c) = [1, 2, 3] list(&#39;a&#39; =&gt; $a) = [&#39;a&#39; =&gt; 1] 把数组中的值赋给一组变量 array_filter($arg [, $callback, $use_keys]) 去掉数组中的空值 array_merge($arr1, $arrays...); 字符串与数组转化 string implode( string $glue, array $array) 一维数组转化为字符串 返回一个字符串，由 $glue（默认为空） 分隔开的数组的值。 array explode( string $delimiter , string $string [, int $limit]) 分隔字符串，返回数组 使用特定的分隔符 ($delimiter) 分隔字符串 ($string)，返回一个数组。 $limit 限制返回数组的元素个数，如果结果大于 $limit，则最后一个元素包含剩余的结果。 判断数组某一值是否存在1234567891011121314151617181920$name = [ "name" =&gt; "tom", "age=&gt;12", 'desc' =&gt; [ 23,34,35 ]];// 判断数组中是否存在指定的 keybool array_key_exists('id', $name['desc']);// 检查数组中是否存在某个值bool in_array(23, $name['desc']);// 搜索值，返回键名var_dump(array_search(34,$name['desc'])); 排序12345678910111213141516171819// 升序sort(&amp;$arg [, $sort_flags]);// 降序rsort(&amp;$arg [, $sort_flags]);// 按键排序ksort(&amp;$arg [, $sort_flags]);krsort(&amp;$arg [, $sort_flags]);// 按值排序asort(&amp;$arg [, $sort_flags]);arsort(&amp;$arg [, $sort_flags]);]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
        <category>Types</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 字符串相关函数]]></title>
    <url>%2Fphp%2Fbasic%2Ftypes%2Fstring.html</url>
    <content type="text"><![CDATA[本文列举了 PHP 字符串相关函数。 替换1mixed str_replace( mixed $search, mixed $replace , mixed $subject [, int &amp;$count]); $count 如果被指定，它的值将被设置为替换发生的次数。 上述函数区分大小写，str_ireplace() 不区分大小写。 特殊字符相关函数增加反斜线以 C 语言风格使用反斜线转义字符串中的字符 1string addcslashes ( string $str , string $charlist ) 使用反斜线引用字符串 单引号（’）、双引号（”）、反斜线（\）与 NUL 1string addslashes ( string $str ) 去掉反斜线1string stripcslashes ( string $str ) \&#39; 转换为 &#39; 等等 1string stripslashes ( string $str ) 单引号想要输出 \，须输入 echo &#39;\\&#39;。 echo &#39;\r&#39;; 等会原样输出。 双引号能够解析特殊字符 1234567echo "$a";echo "&#123;$a&#125;b"; echo "$&#123;a&#125;b"echo "\$a"; // 使用反斜杠转义echo "$a[1]"; // 返回字符串中指定位置的字符 heredoc12345678910&lt;&lt;&lt;EOF$a // 能解析变量EOF;&lt;&lt;&lt;"EOF"EOF; nowdoc12345&lt;&lt;&lt;'EOF'$a // 不能解析变量EOF; 生成随机字符串12345/*** @since 7.1*/session_create_id(); // 更好，重复数据出现可能性低 uniqid() 可能有重复数据 https://blog.csdn.net/ghostyusheng/article/details/53788087 其他 首字母大写/小写 ucfirst() lcfirst() 字符串中每个单词首字母大写 ucwords(&#39;a b c&#39;)]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
        <category>Types</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 数据类型]]></title>
    <url>%2Fphp%2Fbasic%2Ftypes%2FREADME.html</url>
    <content type="text"><![CDATA[PHP 支持三大类 8 种数据类型。 官方文档：http://php.net/manual/zh/language.types.php 标量（4） 布尔 boolean 整型 integer 浮点型 float or double 字符型 string 复合类型（2） 数组 array 对象 object 特殊类型 （2） 资源 resource NULL 其他类型 回调类型 callback 伪变量 ...$var 函数返回值为空 void 相关函数 var_dump() 查看值和类型 gettype() 获得类型 is_type 函数，例如 is_int() is_string() 返回布尔类型 类型转换，强制转换或 settype() 函数 转化 (int) false 将布尔类型转化为整数 More Information PHP 类型比较表: http://php.net/manual/zh/types.comparisons.php]]></content>
      <categories>
        <category>PHP</category>
        <category>Basic</category>
        <category>Types</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm 使用详解]]></title>
    <url>%2Fnodejs%2Fnpm.html</url>
    <content type="text"><![CDATA[npm 是 Node.js 的包管理工具。 换源1$ echo "registry=https://registry.npm.taobao.org" &gt;&gt; ~/.npmrc npm 升级1$ npm i -g npm 常用工具npm-check 1$ npm install -g npm-check 相关链接 http://npm.taobao.org/]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node.js 安装配置]]></title>
    <url>%2Fnodejs%2FREADME.html</url>
    <content type="text"><![CDATA[node.js 版本更新较快，建议官网下载安装，并将安装目录下的 bin 加入 PATH。 官方网站：https://nodejs.org/en/download/current/ 镜像源：http://mirrors.ustc.edu.cn/node/ Hello World!1console.log("Hello World!"); 执行 1$ node index.js]]></content>
      <categories>
        <category>Node.js</category>
      </categories>
      <tags>
        <tag>Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.1 新特性]]></title>
    <url>%2Fphp%2Frelease%2F7.1%2FREADME.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/php/php-src/releases/tag/php-7.1.0 官方文档：http://cn2.php.net/manual/zh/migration71.php 部分列出 可为空类型 ?String foo传入的参数或者函数返回的结果要么是给定的类型，要么是 null 1234function testReturn(?string $a): ?string&#123; return 'elePHPant';&#125; 新的返回值类型 : void返回值声明为 void 类型的方法要么干脆省去 return 语句，要么使用一个空的 return 语句。 对于 void 函数来说，NULL 不是一个合法的返回值。 1234public function FunctionName(): void&#123; return;&#125; 类常量可见性多异常捕获一个 catch 可捕获多个异常，用 | 分隔 12345try&#123;&#125;catch(Error | Exception $e )&#123; echo $e-&gt;getMessage();&#125;]]></content>
      <categories>
        <category>PHP</category>
        <category>Release</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 扩展安装配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fextension.html</url>
    <content type="text"><![CDATA[本文记录 PHP 扩展及其简单安装方法。 修订记录 PHP 7.2+ php.ini 中扩展的配置写法发生了变化 依赖安装扩展时可能需要安装一些依赖库，查询出错信息，安装对应的依赖库即可。 总体步骤第一步：得到扩展文件（Linux 编译 / Linux pecl install / Windows 直接下载） 第二步：修改 php.ini 配置文件 第三步：重启 php-fpm。 pecl install下面列举了一些常用参数，更多参数使用 pecl help 查看，注意 pecl install [ext1] [ext2] ... 一次可以安装多个扩展。 以下命令可能需要加上 sudo 12345678910111213141516171819202122$ sudo pecl channel-update pecl.php.net# 设置$ sudo pecl config-show# pecl pear 同时设置了 ini 路径才能在使用 pecl 安装扩展时自动生成配置$ sudo pecl config-set php_ini /usr/local/php/etc/php.ini$ sudo pear config-set php_ini /usr/local/php/etc/php.ini# 安装扩展$ sudo pecl install extname# 测试版$ sudo pecl install extname-beta# 指定版本$ sudo pecl install extname-0.1 编译安装请在 http://pecl.php.net 搜索下载 安装 autoconf 等软件 1234567891011$ wget http://pecl.php.net/get/redis-3.1.2.tgz# 解压、进入$ phpize$ ./configure --with-php-config=/usr/local/php/bin/php-config$ make$ sudo make install 通过以上两种方法得到扩展文件，查看： 1$ cd /usr/local/php/lib/php/extensions/no-debug-zts-20160303 在里边可以看到 redis.so 文件 其他扩展的 编译安装 方法类似，这里不再介绍。 修改配置文件12345678910111213141516171819202122232425262728$ vi /usr/locla/php/etc/php.ini# 注意 php.ini 中只能使用 ; 注释# 文件最后增加如下内容,扩展不在默认编译路径（ext 指令设置的路径），请填写绝对路径## 格式 extension=&lt;ext&gt;## @since 7.2# @link https://github.com/khs1994-php/ini/compare/7.1.0...7.2.0#diff-93ba055b6b5afa0ffd531ce1ff45508aR874#extension=redis# 旧的，未来可能废弃的写法## extension=redis.so## extension=php_redis.dll (Windows)## zend 扩展，例如 xdebug opcache ,格式为 zend_extension=&lt;ext&gt; ，请不要与普通扩展混淆# 注意替换为自己的实际路径，每个 PHP 版本目录名可能不同zend_extension=xdebug# zend_extension=c:/php-ext/php_xdebug 验证使用 phpinfo() 查看或 $ php -m 其他扩展简要说明一下 php-mongodbmododb 数据库有两个扩展 mongo（已废弃，不支持 PHP7） mongodb。 1$ sudo pecl install mongodb php-memcached12345$ sudo apt install libmemcached-dev$ sudo pecl install memcached# 提示 libmemcached directory [no] : 回车跳过即可 pdo-mysqlPHP 编译选项添加 --with-pdo-mysql 相关链接 官方文档 http://blog.csdn.net/jt521xlg/article/details/47757109]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7 配置详解]]></title>
    <url>%2Fphp%2Fdevelopment%2Fconfig.html</url>
    <content type="text"><![CDATA[本文简要介绍了 PHP 常用配置。 PHP-FPMPHP-FPM 后台执行1daemonize = yes 忽略配置文件，通过命令方式指定后台或前台运行。 1$ sudo php-fpm -D | -F 进程数量管理方式1234567pm = dynamic | static | ondemand; static 静态，固定数量 ( pm.max_children )的子进程; dynamic 动态 最大数量、启动时数量 ( pm.start_servers )、空闲状态下的最小、最大进程数量 (pm.min_spare_servers); ondemand 当有连接时启动进程，闲置 pm.process_idle_timeout 秒后杀掉进程。 队列长度 1listen.backlog 最大请求数优化，指一个 php-fpm 的工作进程在处理多少个请求后就终止掉 1pm.max_requests 最长执行时间 1request_terminate_timeout php.ini 变更历史：https://github.com/php/php-src/commits/master/php.ini-development php.ini 中文版：http://www.jinbuguo.com/php/php52-ini.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7 编译安装]]></title>
    <url>%2Fphp%2Fdevelopment%2Fbuild.html</url>
    <content type="text"><![CDATA[本文介绍了手动编译安装 PHP 的具体步骤。 GitHub：https://github.com/khs1994-php/builder 修订记录 Debian9 Ubuntu17.04 出现错误请详细查看后边说明(PHP 7.1.9 不会报错了)。出现错误强烈建议使用 https://stackoverflow.com 进行搜索！ 有些编译报错，你确实是正确的安装了依赖包，可以通过建立软链接解决 本文随着 PHP 版本升级而更新，一些增加、修改已经在注释中列出，注意查看。 用户与用户组PHP-FPM 系统默认用户与用户组 Debian：www-data RedHat: apache 安装依赖包RedHat12345678910111213141516171819$ yum install gcc \ gcc-c++ \ libxml2 \ libxml2-devel \ openssl \ openssl-devel \ libcurl \ libcurl-devel \ freetype \ freetype-devel \ libjpeg \ libjpeg-devel \ libpng \ libpng-devel \ libxslt \ libxslt-devel \ systemd-devel \ libicu-devel \ libedit-devel Debian1234567891011121314151617181920212223242526272829$ sudo apt install autoconf \ dpkg-dev \ file \ ca-certificates \ curl \ xz-utils \ libc6-dev \ make \ pkg-config \ re2c \ gcc g++ \ libedit-dev \ libsodium-dev \ zlib1g-dev \ libxml2-dev \ libssl-dev \ libsqlite3-dev \ libfreetype6-dev \ libxslt1-dev \ libcurl4-gnutls-dev \ libpq-dev \ libmemcached-dev \ libpng-dev \ libjpeg-dev \ libzip-dev # libzip-dev 7.2.0 # ubuntu 16.04 没有 libargon2-0 ，17.04 + 才有，php 7.2.0 新特性 # libargon2-0 \ 编译123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051$ ./configure --prefix=/usr/local/php \ --with-config-file-path=/usr/local/php/etc \ --with-config-file-scan-dir=/usr/local/php/etc/conf.d \ --disable-cgi \ --enable-fpm \ --with-fpm-user=www-data \ --with-fpm-group=www-data \ --enable-ftp \ --with-curl \ --with-gd \ --with-gettext \ --with-iconv-dir \ --with-kerberos \ --with-libedit \ --with-openssl \ --with-pcre-regex \ --with-pdo-mysql \ --with-pdo-pgsql \ --with-xsl \ --with-zlib \ --with-mhash \ --with-png-dir=/usr/lib \ --with-jpeg-dir=/usr/lib\ --with-freetype-dir=/usr/lib \ --enable-mysqlnd \ --enable-bcmath \ --enable-libxml \ --enable-inline-optimization \ --enable-gd-jis-conv \ --enable-mbregex \ --enable-mbstring \ --enable-opcache \ --enable-pcntl \ --enable-shmop \ --enable-soap \ --enable-sockets \ --enable-sysvsem \ --enable-xml \ --enable-zip \ --enable-calendar \ --enable-intl \ --enable-exif \ --with-sodium \ --with-libzip # # --enable-gd-native-ttf 7.2.0 remove # # --with-libzip 7.2.0 add # ubuntu 16.04 没有 libargon2-0 ，17.04 + 才有，php 7.2.0 新特性 # --with-password-argon2 \ 若编译 Apache 模块请添加 --with-apxs2=/usr/local/apache2/bin/apxs 参数。 注意：Apache 模块方式运行 PHP 太古老，请采用新的 PHP-FPM 模式！https://www.khs1994.com/php/development/apache-php.html 错误排查configure: error: no acceptable C compiler found 123$ yum install -y gcc gcc-c++$ sudo apt install gcc g++ configure: error: xml2-config not found. Please check your libxml2 installation. 123$ yum install libxml2 libxml2-devel$ sudo apt install libxml2-dev configure: error: Cannot find OpenSSL… 123$ yum install openssl openssl-devel$ sudo apt install libssl-dev configure: error: png.h not found. 123$ yum install libcurl libcurl-devel$ sudo apt install libcurl4-openssl-dev configure: error: freetype-config not found. 123$ yum install freetype freetype-devel libjpeg libjpeg-devel libpng libpng-devel$ sudo apt install libfreetype6-dev configure: error: xslt-config not found. Please reinstall the libxslt &gt;= 1.1.0 distribution 123$ yum install libxslt libxslt-devel$ sudo apt install libxslt1-dev Debian 9具体查看参考链接2 12checking for cURL in default path not foundconfigure: error: Please reinstall the libcurl distribution easy.h should be in /include/curl/ 123$ sudo apt install libcurl4-gnutls-dev$ sudo ln -s /usr/include/x86_64-linux-gnu/curl /usr/local/include/ 安装123$ make -j "$(nproc)"$ sudo make install 加入环境变量编辑 ~/.bash_profile 1export PATH=/usr/local/php/sbin:/usr/local/php/bin:$PATH 编辑 /etc/sudoers 注意：必须编辑此文件，否则 sudo 会找不到命令。 1Defaults secure_path="/usr/local/php/bin:/usr/local/php/sbin:..." 升级 pecl1$ sudo pecl update-channels 复制配置文件将源文件中的 php.ini-development 复制到安装目录中的 etc 子目录 ，并改名为 php.ini。 在源文件夹中执行以下命令，复制 systemd 文件。 123$ cp sapi/fpm/php-fpm.serviceq /etc/systemd/system/$ systemctl daemon-reload 将安装目录中的 etc 子目录中的 php-fpm.conf.default 复制为 php-fpm.conf。 将安装目录中的 etc/php-fpm.d 子目录中的 www.conf.default 复制为 www.conf。 systemd已经在上一步中配置，这里贴出文件内容，便于学习。 1234567891011121314151617# It's not recommended to modify this file in-place, because it# will be overwritten during upgrades. If you want to customize,# the best way is to use the "systemctl edit" command.[Unit]Description=The PHP FastCGI Process ManagerAfter=network.target[Service]Type=notifyPIDFile=/usr/local/php/var/run/php-fpm.pidExecStart=/usr/local/php/sbin/php-fpm --nodaemonize --fpm-config /usr/local/php/etc/php-fpm.confExecReload=/bin/kill -USR2 $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 启动1234567891011$ sudo php-fpm# 或者使用 system$ sudo systemctl daemon-reload$ sudo systemctl start php-fpm# 也可以设置开机自启动$ sudo systemctl enable php-fpm More Information https://segmentfault.com/a/1190000005363212 https://stackoverflow.com/questions/42300393/php-7-1-2-compilation-and-libcurl-error]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Let's Encrypt SSL 证书配置详解]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Flets-encrypt.html</url>
    <content type="text"><![CDATA[首先确保你的网站是可以访问的（ nginx 配置好 80 端口），申请证书时 let&#39;s Encrypt 会访问网站上的某一文件来确认网站归属（当然也可以通过 DNS 确认）。 第三方小工具 acme.shGitHub: https://github.com/Neilpang/acme.sh 请仔细阅读 README.md。 安装 acme.sh12345678$ git clone https://github.com/Neilpang/acme.sh.git$ cd ./acme.sh$ ./acme.sh --install# 脚本会自动建立别名# Installing alias to '/home/ubuntu/.profile'# 文件位于 ~/.acme.sh/ 生成请使用绝对路径或将 ~/.acme.sh/ 加入 PATH 123456789101112$ acme.sh --issue \ -d mydomain.com \ -d www.mydomain.com \ --webroot /home/wwwroot/mydomain.com/# ECC证书$ acme.sh --issue \ -w /home/wwwroot/example.com \ -d example.com \ -d www.example.com \ --keylength ec-256 生成的文件位于 ~/.acme.sh/域名/。 转移证书文件nginx12345$ acme.sh --install-cert \ -d login.khs1994.com \ --key-file /data/etc/nginx/conf.d/lets-acme/login.khs1994.com.key \ --fullchain-file /data/etc/nginx/conf.d/lets-acme/login.khs1994.com.cer \ --ecc apache请查看官方文档。 官方工具（不建议使用）会安装很多依赖软件。 12345678$ git clone https://github.com/letsencrypt/letsencrypt$ cd letsencrypt$ ./letsencrypt-auto certonly --email 邮箱 \ -d 域名 -d 域名 \ --webroot -w 网站目录完整路径 \ --agree-tos 生成的证书位于 /etc/letsencrypt/live/ nginx 配置如下 12ssl_certificate /etc/letsencrypt/live/域名/fullchain.pem; ssl_certificate_key /etc/letsencrypt/live/域名/privkey.pem; 相关链接 acme.sh Wiki: https://github.com/Neilpang/acme.sh/wiki/%E8%AF%B4%E6%98%8E]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX HTTPS 配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Fhttps.html</url>
    <content type="text"><![CDATA[本文详细介绍了 HTTPS 配置。 GitHub：https://github.com/khs1994-website/https 完整配置文件HSTSHTTP 严格传输安全（HTTP Strict transport security，HSTS），配置浏览器对整个域名空间使用 HTTPS 来加密 1add_header Strict-Transport-Security "max-age=31536000; includeSubdomains; preload"; HPKP(废弃)谷歌浏览器开发团队宣布将停止支持 HPKP 公钥固定 证书加密类型RSAECC HTTPS 配置生成工具GitHub：https://github.com/mozilla/server-side-tls https://mozilla.github.io/server-side-tls/ssl-config-generator/ 国内加速访问 GitHub：https://github.com/khs1994-website/server-side-tls https://khs1994.gitee.io/server-side-tls/ssl-config-generator/ https://khs1994-website.github.io/server-side-tls/ssl-config-generator/ SSL 测试网站 https://myssl.com/ https://httpsecurityreport.com/?report=www.khs1994.com https://www.ssllabs.com/ssltest/index.html 相关链接 https://www.fujieace.com/jingyan/nginx/hsts-hpkp.html https://linux.cn/article-5282-1.html http://www.scalescale.com/tips/nginx/hsts-nginx/ https://imququ.com/post/ecc-certificate.html]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX 配置陷阱和常见错误(转载)]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Ferror-config.html</url>
    <content type="text"><![CDATA[NGINX 配置陷阱。 原文：https://www.nginx.com/resources/wiki/start/topics/tutorials/config_pitfalls/ 翻译：http://www.7rack.info/Nginx-Config-Pitfalls.html 关于本指南最常见的是有人试图从其他指南拷贝配置片段。并非所有的指南是错误的，但绝大部分是有问题的。 甚至 Linode library 的质量也不高，NGINX 社区成员有义务去尝试更正。这些文档由社区成员创建并审核。存在该指南的意义在于社区成员常见及反复出现的问题。 我的问题未列出你遇到的问题在这里没有看到，也许我们在这里没有指明你经历的问题。不要以为你无缘无故的浏览到该页面，你看到这些是因为你做错的事情列在这里。 当涉及到支持许多用户的很多问题，社区成员不想去支持未遵守约定的配置。通过阅读以下指南，修复你的配置。 Chmod 777绝不使用 777。它可能是个漂亮的号码，即使在测试中也表现的你没有任何线索在做什么。在整个路径中 查看权限，想想会发生什么。 轻松的显示路径权限，可以使用： 1$ namei -om /path/to/check Root 在 Location 区块BAD123456789101112131415server &#123; server_name www.example.com; location / &#123; root /var/www/nginx-default/; # [...] &#125; location /foo &#123; root /var/www/nginx-default/; # [...] &#125; location /bar &#123; root /var/www/nginx-default/; # [...] &#125;&#125; 这有效。把 root 放在 location 区块可以生效而且完全有效。错误之处在于开始添加 location 区块，如果你在每个 location 区块添加 root 指令，没有匹配 location 区块将没有 root。下面看看正确的配置。 GOOD12345678910111213server &#123; server_name www.example.com; root /var/www/nginx-default/; location / &#123; # [...] &#125; location /foo &#123; # [...] &#125; location /bar &#123; # [...] &#125;&#125; 多重 Index 指令BAD123456789101112131415161718192021http &#123; index index.php index.htm index.html; server &#123; server_name www.example.com; location / &#123; index index.php index.htm index.html; # [...] &#125; &#125; server &#123; server_name example.com; location / &#123; index index.php index.htm index.html; # [...] &#125; location /foo &#123; index index.php; # [...] &#125; &#125;&#125; 为什么在不需要时重复那么多行。简单的使用一次 index 指令。仅仅需要添加到 http{} 区块，将会被继承。 GOOD123456789101112131415161718http &#123; index index.php index.htm index.html; server &#123; server_name www.example.com; location / &#123; # [...] &#125; &#125; server &#123; server_name example.com; location / &#123; # [...] &#125; location /foo &#123; # [...] &#125; &#125;&#125; 使用 If有几个页面介绍使用 if 语句。它叫做 IfIsEvil，你真的应该看看。让我们看看使用 if 的坏处。If Is Evil Server Name (if)BAD123456789server &#123; server_name example.com *.example.com; if ($host ~* ^www\.(.+)) &#123; set $raw_domain $1; rewrite ^/(.*)$ $raw_domain/$1 permanent; &#125; # [...] &#125;&#125; 这里有3个问题。第一个是 if，我们关心的。当 NGINX 接受一个请求不管是子域名 www.example.com 还是 example.com，if 指令总是会判断。因为你要求 NGINX 检查每个请求的 Host 头。 这样效率低下，你应该避免。像下面一样使用 2 个 server 指令。 GOOD12345678server &#123; server_name www.example.com; return 301 $scheme://example.com$request_uri;&#125;server &#123; server_name example.com; # [...]&#125; 除了配置文件更易于阅读，这种方法减少 NGINX 处理需求。我们摆脱了虚假的 if，同时使用 $scheme,没有硬编码 URI 的结构，可以是 http 或者 https。 检查文件 (if) 存在使用 if 去检查文件是否存在是糟糕的。如果你使用最新版本的 NGINX ，应该看看 try_files,更易使用。 BAD12345678server &#123; root /var/www/example.com; location / &#123; if (!-f $request_filename) &#123; break; &#125; &#125;&#125; GOOD123456server &#123; root /var/www/example.com; location / &#123; try_files $uri $uri/ /index.html; &#125;&#125; 这里我们判断 $uri 是否存在不再需要 if。使用 try_files 意味着可以依序测试。 如果 $uri 不存在，尝试 $uri/，如果还不存在，尝试备用的 location。 在这个案例中，会先查看 $uri 文件是否存在，存在就返回。如果不存在，就检查该目录是否存在。 如果不存在，将返回 index.html,你必须确定存在该文件。 Front Controller 模式 WEB 应用“Front Controller 模式”设计是受欢迎的，且用在许多最流行的 PHP 软件包中。 很多实例比应有的更复杂。让 Drupal, Joomla 等运行，使用： 1try_files $uri $uri/ /index.php?q=$uri&amp;$args; 注解 - 参数名称根据你使用的包是不同的。例如 “q” 是 Drupal、Joomla、WordPress 使用的参数 “page” 是 CMS Made Simple 使用的参数 一些软件甚至不用查询字符串，而且可以从 REQUEST_URI 读取（ WordPress 支持，例如）： 1try_files $uri $uri/ /index.php; 当然你的情况可能不同，你可能根据需求添加复杂的规则，但一个基本的网站，这些将完美的工作。 你可以从简单的开始。 如果你不在乎目录是否存在，你也可以决定跳过目录检查，从中删除 $uri/。 把不受控制的请求给 PHP很多对 PHP 的 NGINX 配置样例把每个以 .php 结尾的 URI 给 PHP 解释器。请注意在大多数 PHP 设置中，这将是个严重的安全问题，因为它允许任意第三方代码执行。 出问题的区域通常如下： 1234location ~* \.php$ &#123; fastcgi_pass backend; # [...]&#125; 这里每一个以 .php 结尾文件的请求将会给 FastCGI 后端。 这里的问题是如果全路径并不指向文件系统上实际的文件，默认的 PHP 配置会试图猜测你需要执行哪个文件。 例如，如果请求不存在的文件 /forum/avatar/1232.jpg/file.php，但 /forum/avatar/1232.jpg 存在， PHP 解释器将处理 /forum/avatar/1232.jpg。如果它包含 PHP 代码，这段代码将相应的执行。 下面的选项可以避免上述情况： 在 php.ini 中设置 cgi.fix_pathinfo=0。使得 PHP 解释器仅尝试给出的路径，如果文件没有找到就停止处理。 保证 NGINX 仅传给后端指定的 PHP 123456789101112131415161718192021222324252627location ~* (file_a|file_b|file_c)\.php$ &#123; fastcgi_pass backend; # [...]&#125; # 特别地在任何包含用户上传的目录中禁用 PHP 文件的执行location /uploaddir &#123; location ~ \.php$ &#123;return 403;&#125; # [...]&#125; # 使用try_files指令过滤location ~* \.php$ &#123; try_files $uri =404; fastcgi_pass backend; # [...]&#125; # 使用嵌套的 location 过滤location ~* \.php$ &#123; location ~ \..*/.*\.php$ &#123;return 404;&#125; fastcgi_pass backend; # [...]&#125; Script Filename 中的 FastCGI Path一些指南倾向使用绝对路径得到信息。这在 PHP 区块很常见。当你从源安装 NGINX ，通常你能够把 include fastcgi_params;加入到配置中。该文件通常在 NGINX 配置目录/etc/nginx/。 GOOD1fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; BAD1fastcgi_param SCRIPT_FILENAME /var/www/yoursite.com/$fastcgi_script_name; $document_root在哪里设置？是通过 root 指令在 server 区块设置。root 指令没有配置？看看 第一个陷阱。 繁杂的 Rewrites不要感觉糟糕，正则表达式容易让人困惑。实际上，我们应该努力保持整洁、简单，不增加繁琐的东西，这容易做到。 BAD1rewrite ^/(.*)$ http://example.com/$1 permanent; GOOD1rewrite ^ http://example.com$request_uri? permanent; BETTER1return 301 http://example.com$request_uri; 第一个 rewrite 捕获在第一个/之后的 URI。通过使用内建变量 $request_uri，我们可以有效的避免做任何捕获或者匹配。 Rewrite 丢失 http://rewrite 是简单，记得添加scheme。 BAD1rewrite ^ example.com permanent; GOOD1rewrite ^ http://example.com permanent; 在上面可以看到，我们在 rewrite 添加了http://。简单有效。 代理一切BAD123456789server &#123; server_name _; root /var/www/site; location / &#123; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass unix:/tmp/phpcgi.socket; &#125;&#125; 令人讨厌的，在这种情况下把所有的请求都给 PHP 处理。为什么？Apache 也许是这样做，但你不必。让我这么说吧… try_files 指令存在的原因，它按特定的顺序尝试文件。意味着 NGINX 可以先尝试提供静态内容。如果不能，继续尝试。 这样 PHP 根本不参与，快的多。特别是如果你通过 PHP 提供 1MB 图片的时间是直接提供的1000倍，让我们看看该怎么做。 GOOD123456789101112server &#123; server_name _; root /var/www/site; location / &#123; try_files $uri $uri/ @proxy; &#125; location @proxy &#123; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass unix:/tmp/phpcgi.socket; &#125;&#125; Also GOOD123456789101112server &#123; server_name _; root /var/www/site; location / &#123; try_files $uri $uri/ /index.php; &#125; location ~ \.php$ &#123; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_pass unix:/tmp/phpcgi.socket; &#125;&#125; 很简单，是不是？如果请求的 URI 存在，NGINX 直接提供。如果不存在，检查目录是否存在。如果不存在，传递给你的代理。 只有当 NGINX 不能直接服务请求的 URI，你的代理将参与开销。 现在想想你的多少请求是静态资源，比如 images、css、javascript 等。你可能节省很多开销。 配置更改没有生效浏览器缓存。你的配置也许是很棒的，但你会坐在那，撞墙一个月。问题出在你的浏览器缓存。 当你下载了东西，你的浏览器会保存下来。同时也保存了文件是如何提供的。如果你配置有 types 区块，你会遇到这情况。 处理方法： 在 Firefox 浏览器中按 Ctrl+Shift+Delete，检查缓存，点击 Clear Now。其他浏览器，可搜索下方法。 每次更改之后都清除下，会为你节省不少麻烦。 使用 curl。 VirtualBox如果这不起作用,而且你在 VirtualBox 中的虚拟机中运行 NGINX，也许是 sendfile()引起的问题。 简单的注释掉 sendfile 指令，或者设置为 off。 sendfile off; 缺失的 HTTP 头如果你没有明确的设置 underscores_in_headers on，NGINX 将会默默地忽略掉带有下划线的头信息（根据 HTTP 标准是完全有效的）。 这样做为了防止头信息映射到 CGI 变量过程中破折号和下划线都映射成下划线引起歧义。 没有使用标准的 Document Root Locations有些目录在任何文件系统中不应该用于托管数据。其中包括 / 和 /root。你不应该使用这些作为网站根目录。 这样作让你的隐私数据毫无预期的返回给请求。 永远不要这样做！！！ 1234567891011server &#123; root /; location / &#123; try_files /web/$uri $uri @php; &#125; location @php &#123; # [...] &#125;&#125; 当一个请求 /foo，因为文件找不到将代理到 php 。这看起来正常，直到请求 /etc/passwd。是的，你给了服务器上所有用户列表。 在某些情况下，Nginx 服务器进程被设置以 root 用户运行。是的，我们现在有你的用户列表以及密码 hash 密码，以及如何 hash 的。 文件系统层级标准定义了数据应该存在哪里。你应该看看。 简而言之，你的 web 内容可以存放在/var/www/、/srv、/usr/share/www。 使用默认的 Document RootUbuntu、Debian 等其他操作系统中 NGINX 包，作为易于安装的包会提供默认的配置文件用作一个例子，而且会包含网站根目录存储基本的 HTML 文件。 多数系统包不检查默认的 Document Root中文件是否存在或者修改。这样会在软件包升级时导致代码丢失。经验丰富的系统管理员没有期望在 升级期间默认的 document root 内容保持不变。 你不应该对将网站的关键文件使用默认的 document root。在你的系统升级或者更新 NGINX 包时有很大可能性会导致默认的 document root 内容会改变。 使用 Hostname 去解析地址BAD12345678upstream &#123; server http://someserver;&#125;server &#123; listen myhostname:80; # [...]&#125; 你不应该在 listen 指令中使用 hostname。也许这样有效，也将会有大量的问题。 其中一个问题是在服务启动或者重启时 hostname 不能解析。这会引起 NGINX 无法绑定到特定的 TCP 端口，最终 NGINX 启动失败。 更安全的做法是知道需要绑定的 IP 地址，并使用 IP 而不是 hostname。 阻止 NGINX 需要查找 IP ，不依赖内部或者外部的解析。 upstream 区块也有同样的问题。并不是总要在 upstream 区块避免使用 hostname，这不是好的做法，使用时要考虑清楚。 GOOD12345678upstream &#123; server http://10.48.41.12;&#125;server &#123; listen 127.0.0.16:80; # [...]&#125; HTTPS 中使用 SSLv3由于 SSLv3 的 POODLE 漏洞，建议在 SSL 的网站不启用 SSLv3。你可以很简单的禁用 SSLv3，只提供 TLS 协议。 1ssl_protocols TLSv1 TLSv1.1 TLSv1.2;]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX 配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Fconfig.html</url>
    <content type="text"><![CDATA[本文详细介绍了 NGINX 常用配置。 官方文档：https://www.nginx.com/resources/wiki/start/topics/examples/full/ HTTPS https://github.com/khs1994-website/https 内置变量 https://github.com/khs1994-docker/lnmp/issues/447 中文文档 https://github.com/oopsguy/nginx-docs) 修改主配置文件 /etc/nginx/nginx.conf 12345678910111213worker_processes auto;http &#123; # 配置首页 # 在 http 段配置好，就不用在 server 段里配置了 index index.php index.htm index.html; # 引入子配置文件 include /etc/nginx/conf.d/*.conf;&#125; 命令12345678910# stop 是快速停止 nginx，可能并不保存相关信息，quit 是完整有序的停止 nginx 并保存相关信息$ nginx -s stop$ nginx -s quit# 重新打开日志文件命令$ nginx -s reopen# 重新载入配置文件$ nginx -s reload 超时设置1234567891011121314151617181920212223242526272829# 配置段: http, server, location 参数是一个请求完成之后还要保持连接多久，不是请求时间多久，目的是保持长连接keepalive_timeout 75s;# 配置段: http, server, location 接收客户端 body 超时client_body_timeout 20s;# 配置段: http, server, location 接收客户端 header 超时client_header_timeout 10s;# 配置段: http, server, location 服务端向客户端传输数据的超时时间。send_timeout 30s;# nginx 与 upstream server 的连接超时时间proxy_connect_timeout 60s;# nginx 接收 upstream server 数据超时, 默认 60sproxy_read_timeout 60s;# nginx 发送数据至 upstream server 超时proxy_send_timeout 60s;# 设置了某一个 upstream 后端失败了指定次数（max_fails）后，该后端不可操作的时间，默认为10秒proxy_upstream_fail_timeout 10s;# fastcgi php-fpm 等配置下列选项，上边的无用fastcgi_connect_timeout 300;fastcgi_send_timeout 300;fastcgi_read_timeout 300; PHP12345678910ini_set('max_execution_time', '0'); // set_time_limit(0);print str_repeat(" ", 4096); //先输出4096的字节，保证缓冲数据量For ($j = 1; $j &lt;= 1000000; $j++) &#123; echo $j.''; ob_flush(); flush();//这一部会使cache新增的内容被挤出去，显示到阅读器上 sleep(1);//让程序“睡”一秒钟，会让你把效果看得更清楚&#125; PHP1234567891011121314151617181920server&#123; root /var/www2/www; location ~ \.php$ &#123; # fastcgi_pass unix:/run/php-fpm.sock; # # socket 方式不建议使用，WSL 必须用该方式 # fastcgi_pass phpfpm:9000; fastcgi_index index.php; # 包管理工具 apt yum 安装的 nginx 不包含 fastcgi.conf # 必须使用注释的配置 # fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; # include fastcgi_params; include fastcgi.conf; &#125;&#125; default_server1234server &#123; listen 80 default_server; server_name oschina.net www.oschina.net;&#125; listen 指令后面有一个参数 default_server ，这个参数是在 0.8.21 版本以后才有的，而之前是 default 指令。Nginx的虚拟主机是通过 HTTP 请求中的 Host 值来找到对应的虚拟主机配置，如果找不到，那 Nginx 就会将请求送到指定了 default_server 的节点来处理，如果没有指定为 default_server 的话，就跑到 localhost 的节点，如果没有 localhost 的节点，那只好 404 了。 目录浏览功能Nginx 默认是不允许列出整个目录的。如需此功能，在配置文件中 server 或 location 段里添加上 autoindex on; 来启用目录浏览。 123456789autoindex on;# 默认为on，显示出文件的确切大小，单位是bytes。改为off后，显示出文件的大概大小，单位是kB或者MB或者GBautoindex_exact_size off;# 默认为off，显示的文件时间为GMT时间。改为on后，显示的文件时间为服务器时间autoindex_localtime on; 负载均衡123456789101112upstream fzjh &#123; server 111.206.227.118 weight=2; server 123.206.62.18;&#125;server &#123; listen 80; server_name f.khs1994.com; location / &#123; proxy_pass http://fzjh; &#125;&#125; alias假设请求 url 为 http://localhost/appImg/abc.jpg 12345678910111213server &#123; location ^~ /appImg/ &#123; root /home/nginx; # /home/nginx/appImg/abc.jpg 路径拼接到了一起 &#125; location ^~ /appImg/ &#123; # # alias 只能用在 location 块中 # alias /home/nginx/; # 路径后必须加上 / ，/home/nginx/abc.jpg 会丢弃 location 匹配到的路径 &#125;&#125; 相关链接 http://blog.csdn.net/benbendy1984/article/details/6025663 http://nginx.org/en/docs/http/ngx_http_autoindex_module.html]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NGINX 编译安装]]></title>
    <url>%2Fphp%2Fdevelopment%2Fnginx%2Fbuild.html</url>
    <content type="text"><![CDATA[本文介绍了手动编译安装 NGINX 的具体步骤。 建立用户及用户组123$ groupadd -r nginx$ useradd -r -g nginx -s /bin/false -M nginx Alpine 较特殊123$ addgroup -S nginx$ adduser -D -S -h /var/cache/nginx -s /sbin/nologin -G nginx nginx http://git.alpinelinux.org/cgit/aports/tree/main/apache2/apache2.pre-install?h=v3.3.2 http://git.alpinelinux.org/cgit/aports/tree/main/lighttpd/lighttpd.pre-install?h=v3.3.2 http://git.alpinelinux.org/cgit/aports/tree/main/nginx-initscripts/nginx-initscripts.pre-install?h=v3.3.2 安装依赖包RedHat 系 1$ yum install -y gcc gcc-c++ pcre-devel openssl-devel zlib-devel Debian 系 1$ sudo apt install gcc g++ libpcre3 libpcre3-dev libssl-dev zlib1g-dev zlib1g 编译1234567891011121314151617181920212223242526$ ./configure --prefix=/etc/nginx \ --sbin-path=/etc/nginx/sbin/nginx \ --conf-path=/etc/nginx/nginx.conf \ --user=nginx \ --group=nginx \ --with-http_ssl_module \ --with-http_realip_module \ --with-http_addition_module \ --with-http_sub_module \ --with-http_dav_module \ --with-http_flv_module \ --with-http_mp4_module \ --with-http_gunzip_module \ --with-http_gzip_static_module \ --with-http_random_index_module \ --with-http_secure_link_module \ --with-http_stub_status_module \ --with-http_auth_request_module \ --with-threads \ --with-stream \ --with-stream_ssl_module \ --with-http_slice_module \ --with-mail \ --with-mail_ssl_module \ --with-file-aio \ --with-http_v2_module 错误排查错误1checking for OSLinux 3.10.0-327.36.1.el7.x86_64 x86_64checking for C compiler … not found./configure: error: C compiler cc is not found 123$ yum install -y gcc gcc-c++$ sudo apt install gcc g++ 错误2./configure: error: the HTTP rewrite module requires the PCRE library.You can either disable the module by using –without-http_rewrite_moduleoption, or install the PCRE library into the system, or build the PCRE librarystatically from the source with nginx by using –with-pcre=option. 123$ yum install pcre-devel$ sudo apt install libpcre3 libpcre3-dev 错误3./configure: error: SSL modules require the OpenSSL library.You can either do not enable the modules, or install the OpenSSL libraryinto the system, or build the OpenSSL library statically from the sourcewith nginx by using –with-openssl=option. 123$ yum install openssl-devel$ sudo apt install libssl-dev 错误4./configure: error: the HTTP gzip module requires the zlib library. 123$ yum install zlib-devel$ sudo apt install zlib1g-dev zlib1g 安装123$ make$ sudo make install 加入环境变量编辑 ~/.bash_profile 1export PATH=/etc/nginx/sbin:$PATH 编辑 /etc/sudoers 注意：必须编辑此文件，否则 sudo 会找不到命令。 1Defaults secure_path="/etc/nginx/sbin:..." systemd在 /etc/systemd/system/ 下增加 nginx.service 文件，以下路径根据实际自己修改。 12345678910111213141516[Unit]Description=nginx - high performance web serverDocumentation=http://nginx.org/en/docs/After=network.target remote-fs.target nss-lookup.target[Service]Type=forkingPIDFile=/etc/nginx/run/nginx.pidExecStartPre=/etc/nginx/sbin/nginx -t -c /etc/nginx/nginx.confExecStart=/etc/nginx/sbin/nginx -c /etc/nginx/nginx.confExecReload=/bin/kill -s HUP $MAINPIDExecStop=/bin/kill -s QUIT $MAINPIDPrivateTmp=true[Install]WantedBy=multi-user.target 启动123$ sudo nginx -t$ sudo nginx 相关链接 http://bbs.qcloud.com/thread-10429-1-1.html]]></content>
      <categories>
        <category>PHP</category>
        <category>NGINX</category>
      </categories>
      <tags>
        <tag>NGINX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache PHP 配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fapache%2Fphp.html</url>
    <content type="text"><![CDATA[本文简要介绍了 Apache 解析 PHP 文件。 GitHub：https://github.com/khs1994-website/https 修改默认首页123# 搜索 DirectoryIndex 修改，不要再添加 DirectoryIndex！DirectoryIndex index.php index.html PHP-FPM1234567LoadModule proxy_module modules/mod_proxy.soLoadModule proxy_fcgi_module modules/mod_proxy_fcgi.so# PHP 文件只使用 .php 后缀，避免使用其他后缀！文件伪装除外AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps Apache 配置1234567891011121314151617&lt;VirtualHost *:80&gt; DocumentRoot "/var/www/htdocs" ServerName b.org ServerAlias www.b.org ErrorLog "logs/b.org.err" CustomLog "logs/b.org.access" combined &lt;FilesMatch \.php$&gt; SetHandler "proxy:fcgi://127.0.0.1:9000" &lt;/FilesMatch&gt; &lt;Directory "/app/test" &gt; AllowOverride All Require all granted &lt;/Directory&gt; &lt;/VirtualHost&gt; 模块方式 该方式太老，不建议使用 /usr/local/apache2/modules/ 有 libphp7.so 文件。 PHP7 编译安装时加上参数 --with-apxs2=/usr/local/apache2/bin/apxs 1234LoadModule php7_module modules/libphp7.soAddType application/x-httpd-php .phpAddType application/x-httpd-php-source .phps]]></content>
      <categories>
        <category>PHP</category>
        <category>HTTPD</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HTTPD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache 配置]]></title>
    <url>%2Fphp%2Fdevelopment%2Fapache%2Fconfig.html</url>
    <content type="text"><![CDATA[本文简要介绍了 Apache 配置 https 、子域名。 GitHub：https://github.com/khs1994-website/https 如果启动出现错误，搜索一下错误信息，一般启用某些模块就行了。 访问控制一般出现 403 错误，可能是访问控制出了问题，对照说明检查一下配置。 2.2.x使用 Order(排序), Allow(允许), Deny(拒绝),Satisfy(满足)指令来实现。 2.4.xRequire 对比123456789101112131415Order deny,allow # 排序，先拒绝后允许Deny from all # 拒绝所有Require all denied # 拒绝所有Order allow,deny # 排序，先允许后拒绝Allow from all # 允许所有Require all granted # 允许所有Order Deny,Allow # 排序，先拒绝后允许Deny from all # 拒绝所有Allow from splaybow.com # 允许 splaybow.comRequire host splaybow.com # 允许 splaybow.com 123456789Require all granted # 允许所有来源访问Require all denied # 拒绝所有来源访问Require expr expression # 允许表达式为true时访问Require ip 10 172.20 192.168.2 # 允许特定IP段访问，多个段之前用空格隔开。每个段使用开头几项表示Require host splaybow.com # 只允许来自域名splaybow.com的主机访问 参考资料 http://www.splaybow.com/post/apache-forbidden-directory-require.html https修改主配置文件 /usr/local/apache2/conf/httpd.conf 123LoadModule socache_shmcb_module modules/mod_socache_shmcb.soLoadModule ssl_module modules/mod_ssl.so 为了方便这里不启用 /usr/local/apache2/conf/extra/httpd-ssl.conf 直接在 /usr/local/apache2/conf/extra/httpd-vhosts.conf 增加内容 123456789101112Listen 443SSLCipherSuite HIGH:MEDIUM:!MD5:!RC4:!3DESSSLProxyCipherSuite HIGH:MEDIUM:!MD5:!RC4:!3DESSSLHonorCipherOrder onSSLProtocol all -SSLv3SSLProxyProtocol all -SSLv3SSLSessionCache "shmcb:/usr/local/apache2/logs/ssl_scache(512000)"SSLSessionCacheTimeout 300 多主机配置修改主配置文件 /usr/local/apache2/conf/httpd.conf 12# Virtual hosts 取消注释Include conf/extra/httpd-vhosts.conf 修改子配置文件 /usr/local/apache2/conf/extra/httpd-vhosts.conf 基于 域名、IP、端口来实现多主机，具体看示例配置。 不建议使用以上方式，参考 NGINX 配置方式，我们可以把某一个目录中全部的 *.conf 文件包含进来。 1Include conf/conf.d/*.conf 一个虚拟主机一个文件（conf/conf.d/*.conf）。 目录列表是否显示目录列表 12345&lt;Directory "/app"&gt;Options Indexes FollowSymLinks&lt;Directory "/app"&gt; 重写1234567&lt;Directory "/app"&gt;AllowOverride NoneAllowOverride AllAllowOverride FileInfo AuthConfig Limit&lt;Directory "/app"&gt;]]></content>
      <categories>
        <category>PHP</category>
        <category>HTTPD</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>HTTPD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache 编译]]></title>
    <url>%2Fphp%2Fdevelopment%2Fapache%2Fbuild.html</url>
    <content type="text"><![CDATA[本文介绍了手动编译安装 Apache 的具体步骤。 用户及用户组 Debian www-data yum 方式安装1234567$ yum install wget epel-release$ wget https://centos7.iuscommunity.org/ius-release.rpm$ rpm -Uvh ius-release.rpm$ yum install httpd24u 编译安装所需软件1$ yum install gcc gcc-c++ make uuid-devel libuuid-devel unzip -y apr 中包含了一些通用的开发组件，包括 mmap，DSO 等等 apr-util 该目录中也是包含了一些常用的开发组件。这些组件与 apr 目录下的相比，它们与 apache 的关系更加密切一些。比如存储段和存储段组，加密等等。 apr-iconv 包中的文件主要用于实现 iconv 编码。目前的大部分编码转换过程都是与本地编码相关的。在进行转换之前必须能够正确地设置本地编码。因此假如两个非本地编码 A 和 B 需要转换，则转换过程大致为 A-&gt;Local 以及 Local-&gt;B 或者 B-&gt;Local 以及 Local-&gt;A。 安装 apr12345678910111213$ wget http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-1.5.2.tar.gz$ tar zxvf apr-1.5.2.tar.gz$ cd apr-1.5.2$ ./configure --prefix=/usr/local/apr#下同$ make$ make install 安装 apr-iconv1234567$ wget http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-iconv-1.2.1.tar.gz$ tar -zxvf apr-iconv-1.2.1.tar.gz$ cd apr-iconv-1.2.1$ ./configure --prefix=/usr/local/apr-iconv --with-apr=/usr/local/apr 安装 apr-util12345678$ wget http://mirrors.tuna.tsinghua.edu.cn/apache//apr/apr-util-1.5.4.tar.gz$ tar zxvf apr-util-1.5.4.tar.gz$ cd apr-util-1.5.4$ ./configure --prefix=/usr/local/apr-util --with-apr=/usr/local/apr \ --with-apr-iconv=/usr/local/apr-iconv/bin/apriconv 安装 pcre1234567$ wget http://120.52.73.44/nchc.dl.sourceforge.net/project/pcre/pcre/8.38/pcre-8.38.zip$ unzip -o pcre-8.38.zip$ cd pcre-8.38$ ./configure --prefix=/usr/local/pcre 编译安装 Apache123456789101112131415# 替换 url 为实际的下载地址$ wget url$ tar zxvf httpd-2.4.20.tar.gz$ cd httpd-2.4.20$ ./configure --prefix=/usr/local/apache2 \ --enable-defalte --enable-expires \ --enable-headers --enable-modules=most \ --enable-so --with-mpm=worker \ --enable-rewrite --with-apr=/usr/local/apr \ --with-apr-util=/usr/local/apr-util \ --with-pcre=/usr/local/pcre systemdyum 方式安装会生成 httpd.service 文件，编译安装使用 apache.service 新建 /etc/systemd/system/apache.service 文件。 123456789101112131415161718192021[Unit]Description=The Apache HTTP ServerAfter=network.target remote-fs.target nss-lookup.targetDocumentation=man:httpd(8)Documentation=man:apachectl(8)[Service]Type=simpleExecStart=/usr/local/apache2/bin/httpd -DFOREGROUNDExecReload=/usr/local/apache2/bin/httpd -k gracefulExecStop=/bin/kill -WINCH $&#123;MAINPID&#125;# We want systemd to give httpd some time to finish gracefully, but still want# it to kill httpd after TimeoutStopSec if something went wrong during the# graceful stop. Normally, Systemd sends SIGTERM signal right after the# ExecStop, which would kill httpd. We are sending useless SIGCONT here to give# httpd time to finish.KillSignal=SIGCONTPrivateTmp=true[Install]WantedBy=multi-user.target]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>HTTPD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LAMP CentOS7 开发环境配置]]></title>
    <url>%2Fphp%2Fdevelopment%2FREADME.html</url>
    <content type="text"><![CDATA[本文简要介绍了手动搭建 LNMP 开发环境的步骤。 Docker使用 Docker 可以很方便的搭建 LNMP 环境，具体请查看以下链接。 khs1994-docker/lnmp Windows https://www.khs1994.com/php/development/wnamp.html macOS https://www.khs1994.com/php/development/mnamp.html NGINX编译安装。 MySQLmysql-community-client-5.7.13-1.el7.x86_64.rpmmysql-community-common-5.7.13-1.el7.x86_64.rpmmysql-community-libs-5.7.13-1.el7.x86_64.rpmmysql-community-server-5.7.13-1.el7.x86_64.rpm 123456789$ rpm -qa | grep mariadb$ rpm -e --nodeps mariadb-libs-5.5.37-1.el7_0.x86_64$ yum install *.rpm$ service mysqld start$ service mysqld status 找到初始密码1234567$ sudo grep 'temporary password' /var/log/mysqld.log$ mysql -uroot -p# 修改密码$ ALTER USER 'root'@'localhost' IDENTIFIED BY 'NewPassword'; 远程登录添加登录用户1$ GRANT ALL PRIVILEGES ON *.* TO 'admin'@'%' IDENTIFIED BY 'MyPassword' WITH GRANT OPTION; 修改监听地址编辑 /etc/mysql/my.conf 文件。 12[mysqld]bind-address=127.0.0.1 改为 bind-address=0.0.0.0 PHP该版本为 PHP7。 12345$ rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm$ yum install php70w-fpm$ yum install php70w-mysqlnd # PHP与数据库连接 启动服务1234567# 开启 PHP-FPM 服务$ systemctl start php-fpm.service# 开机自启动$ systemctl enable php-fpm.service]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>PHPer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 配置工具 Ignition 官方示例]]></title>
    <url>%2Fdocker%2Fcoreos%2Fignition.html</url>
    <content type="text"><![CDATA[CoreOS 配置工具已由 Ignition 代替 cloud-config。 GitHub：https://github.com/coreos/ignition 使用 Ignition 需要两步： 第一步编写 Container Linux Config ( yaml 格式 ) 第二步使用 container-linux-config-transpiler 将 Container Linux Config 转化为 Ignition Config (json 格式) 1$ ct-v0.5.0-x86_64-apple-darwin -in-file ignition.yaml &gt; ignition.json container-linux-config-transpiler 安装方法在 https://github.com/coreos/container-linux-config-transpiler/releases 下载二进制文件移入 PATH，并赋予可执行权限之后即可使用。 brew123$ brew install coreos-ct$ ct -help 官方文档：https://coreos.com/os/docs/latest/overview-of-ct.html 常用配置举例etcd1234567etcd: name: coreos3 discovery: https://discovery.etcd.io/249ea9815631abc753fe4a4743f147d2 advertise_client_urls: http://192.168.57.102:2379 initial_advertise_peer_urls: http://192.168.57.102:2380 listen_client_urls: http://192.168.57.102:2379,http://0.0.0.0:4001 listen_peer_urls: http://0.0.0.0:2380 网络配置通过与网络接口名称（ enp0s3 等）匹配来设置静态或动态 IP 地址 12345678910111213141516networkd: units: - name: 10-static.network contents: | [Match] Name=enp0s3 [Network] Address=192.168.57.102/24 - name: 20-dhcp.network contents: | [Match] Name=enp0s8 [Network] DHCP=yes 用户123456789passwd: users: - name: core ssh_authorized_keys: - ssh-rsa SSH_PUB groups: - wheel - sudo - docker systemd unit123456789101112systemd: units: - name: settimezone.service enable: true contents: | [Unit] Description=Set the time zone [Service] ExecStart=/usr/bin/timedatectl set-timezone PRC RemainAfterExit=yes Type=oneshot 文件12345678910111213storage: files: - filesystem: "root" path: "/etc/hostname" mode: 0644 contents: inline: coreos3 - filesystem: "root" path: "/etc/resolv.conf" mode: 0644 contents: inline: | nameserver 114.114.114.114 示例文件https://github.com/khs1994-docker/lnmp-k8s/blob/master/coreos/disk/example/ignition-1.example.yaml 相关链接 https://coreos.com/os/docs/latest/migrating-to-clcs.html https://coreos.com/blog/introducing-ignition.html]]></content>
      <categories>
        <category>CoreOS</category>
        <category>Ignition</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
        <tag>Ignition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoreOS 配置工具 Ignition v2.2]]></title>
    <url>%2Fdocker%2Fcoreos%2Fconfiguration-v2_2-experimental.html</url>
    <content type="text"><![CDATA[This pre-release version of the specification is experimental and is subject to change without notice or regard to backward compatibility. https://github.com/coreos/ignition/blob/master/doc/configuration-v2_2-experimental.md The Ignition configuration is a JSON document conforming to the following specification, with italicized entries being optional: ignition (object): metadata about the configuration itself. version (string): the semantic version number of the spec. The spec version must be compatible with the latest version (2.2.0-experimental). Compatibility requires the major versions to match and the spec version be less than or equal to the latest version. -experimental versions compare less than the final version with the same number, and previous experimental versions are not accepted. config (objects): options related to the configuration. append (list of objects): a list of the configs to be appended to the current config. source (string): the URL of the config. Supported schemes are http, https, s3, tftp, and data. Note: When using http, it is advisable to use the verification option to ensure the contents haven’t been modified. verification (object): options related to the verification of the config. hash (string): the hash of the config, in the form &lt;type&gt;-&lt;value&gt; where type is sha512. replace (object): the config that will replace the current. source (string): the URL of the config. Supported schemes are http, https, s3, tftp, and data. Note: When using http, it is advisable to use the verification option to ensure the contents haven’t been modified. verification (object): options related to the verification of the config. hash (string): the hash of the config, in the form &lt;type&gt;-&lt;value&gt; where type is sha512. timeouts (object): options relating to http timeouts when fetching files over http or https. httpResponseHeaders (integer) the time to wait (in seconds) for the server’s response headers (but not the body) after making a request. 0 indicates no timeout. Default is 10 seconds. httpTotal (integer) the time limit (in seconds) for the operation (connection, request, and response), including retries. 0 indicates no timeout. Default is 0. storage (object): describes the desired state of the system’s storage devices. disks (list of objects): the list of disks to be configured and their options. device (string): the absolute path to the device. Devices are typically referenced by the /dev/disk/by-* symlinks. wipeTable (boolean): whether or not the partition tables shall be wiped. When true, the partition tables are erased before any further manipulation. Otherwise, the existing entries are left intact. partitions (list of objects): the list of partitions and their configuration for this particular disk. label (string): the PARTLABEL for the partition. number (integer): the partition number, which dictates it’s position in the partition table (one-indexed). If zero, use the next available partition slot. size (integer): the size of the partition (in device logical sectors, 512 or 4096 bytes). If zero, the partition will fill the remainder of the disk. start (integer): the start of the partition (in device logical sectors). If zero, the partition will be positioned at the earliest available part of the disk. typeGuid (string): the GPT partition type GUID. If omitted, the default will be 0FC63DAF-8483-4772-8E79-3D69D8477DE4 (Linux filesystem data). guid (string): the GPT unique partition GUID. raid (list of objects): the list of RAID arrays to be configured. name (string): the name to use for the resulting md device. level (string): the redundancy level of the array (e.g. linear, raid1, raid5, etc.). devices (list of strings): the list of devices (referenced by their absolute path) in the array. spares (integer): the number of spares (if applicable) in the array. filesystems (list of objects): the list of filesystems to be configured and/or used in the “files” section. Either “mount” or “path” needs to be specified. name (string): the identifier for the filesystem, internal to Ignition. This is only required if the filesystem needs to be referenced in the “files” section. mount (object): contains the set of mount and formatting options for the filesystem. A non-null entry indicates that the filesystem should be mounted before it is used by Ignition. device (string): the absolute path to the device. Devices are typically referenced by the /dev/disk/by-* symlinks. format (string): the filesystem format (ext4, btrfs, xfs, vfat, or swap). wipeFilesystem (boolean): whether or not to wipe the device before filesystem creation, see the documentation on filesystems for more information. label (string): the label of the filesystem. uuid (string): the uuid of the filesystem. options (list of strings): any additional options to be passed to the format-specific mkfs utility. create (object, DEPRECATED): contains the set of options to be used when creating the filesystem. force (boolean, DEPRECATED): whether or not the create operation shall overwrite an existing filesystem. options (list of strings, DEPRECATED): any additional options to be passed to the format-specific mkfs utility. path (string): the mount-point of the filesystem. A non-null entry indicates that the filesystem has already been mounted by the system at the specified path. This is really only useful for “/sysroot”. files (list of objects): the list of files to be written. filesystem (string): the internal identifier of the filesystem in which to write the file. This matches the last filesystem with the given identifier. path (string): the absolute path to the file. contents (object): options related to the contents of the file. compression (string): the type of compression used on the contents (null or gzip). Compression cannot be used with S3. source (string): the URL of the file contents. Supported schemes are http, https, tftp, s3, and data. When using http, it is advisable to use the verification option to ensure the contents haven’t been modified. verification (object): options related to the verification of the file contents. hash (string): the hash of the config, in the form &lt;type&gt;-&lt;value&gt; where type is sha512. mode (integer): the file’s permission mode. Note that the mode must be properly specified as a decimal value (i.e. 0644 -&gt; 420). user (object): specifies the file’s owner. id (integer): the user ID of the owner. name (string): the user name of the owner. group (object): specifies the group of the owner. id (integer): the group ID of the owner. name (string): the group name of the owner. directories (list of objects): the list of directories to be created. filesystem (string): the internal identifier of the filesystem in which to create the directory. This matches the last filesystem with the given identifier. path (string): the absolute path to the directory. mode (integer): the directory’s permission mode. Note that the mode must be properly specified as a decimal value (i.e. 0755 -&gt; 493). user (object): specifies the directory’s owner. id (integer): the user ID of the owner. name (string): the user name of the owner. group (object): specifies the group of the owner. id (integer): the group ID of the owner. name (string): the group name of the owner. links (list of objects): the list of links to be created filesystem (string): the internal identifier of the filesystem in which to write the link. This matches the last filesystem with the given identifier. path (string): the absolute path to the link user (object): specifies the symbolic link’s owner. id (integer): the user ID of the owner. name (string): the user name of the owner. group (object): specifies the group of the owner. id (integer): the group ID of the owner. name (string): the group name of the owner. target (string): the target path of the link hard (boolean): a symbolic link is created if this is false, a hard one if this is true. systemd (object): describes the desired state of the systemd units. units (list of objects): the list of systemd units. name (string): the name of the unit. This must be suffixed with a valid unit type (e.g. “thing.service”). enable (boolean, DEPRECATED): whether or not the service shall be enabled. When true, the service is enabled. In order for this to have any effect, the unit must have an install section. enabled (boolean): whether or not the service shall be enabled. When true, the service is enabled. When false, the service is disabled. When omitted, the service is unmodified. In order for this to have any effect, the unit must have an install section. mask (boolean): whether or not the service shall be masked. When true, the service is masked by symlinking it to /dev/null. contents (string): the contents of the unit. dropins (list of objects): the list of drop-ins for the unit. name (string): the name of the drop-in. This must be suffixed with “.conf”. contents (string): the contents of the drop-in. networkd (object): describes the desired state of the networkd files. units (list of objects): the list of networkd files. name (string): the name of the file. This must be suffixed with a valid unit type (e.g. “00-eth0.network”). contents (string): the contents of the networkd file. passwd (object): describes the desired additions to the passwd database. users (list of objects): the list of accounts that shall exist. name (string): the username for the account. passwordHash (string): the encrypted password for the account. sshAuthorizedKeys (list of strings): a list of SSH keys to be added to the user’s authorized_keys. uid (integer): the user ID of the account. gecos (string): the GECOS field of the account. homeDir (string): the home directory of the account. noCreateHome (boolean): whether or not to create the user’s home directory. This only has an effect if the account doesn’t exist yet. primaryGroup (string): the name of the primary group of the account. groups (list of strings): the list of supplementary groups of the account. noUserGroup (boolean): whether or not to create a group with the same name as the user. This only has an effect if the account doesn’t exist yet. noLogInit (boolean): whether or not to add the user to the lastlog and faillog databases. This only has an effect if the account doesn’t exist yet. shell (string): the login shell of the new account. system (bool): whether or not to make the account a system account. This only has an effect if the account doesn’t exist yet. create (object, DEPRECATED): contains the set of options to be used when creating the user. A non-null entry indicates that the user account shall be created. This object has been marked for deprecation, please use the users level fields instead. uid (integer): the user ID of the new account. gecos (string): the GECOS field of the new account. homeDir (string): the home directory of the new account. noCreateHome (boolean): whether or not to create the user’s home directory. primaryGroup (string): the name or ID of the primary group of the new account. groups (list of strings): the list of supplementary groups of the new account. noUserGroup (boolean): whether or not to create a group with the same name as the user. noLogInit (boolean): whether or not to add the user to the lastlog and faillog databases. shell (string): the login shell of the new account. groups (list of objects): the list of groups to be added. name (string): the name of the group. gid (integer): the group ID of the new group. passwordHash (string): the encrypted password of the new group.]]></content>
      <categories>
        <category>CoreOS</category>
        <category>Ignition</category>
      </categories>
      <tags>
        <tag>CoreOS</tag>
        <tag>Ignition</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux systemd journal]]></title>
    <url>%2Flinux%2Fsystemd%2Fjournal.html</url>
    <content type="text"><![CDATA[journal 是 systemd 的日志管理工具。 More Information http://www.jinbuguo.com/systemd/journalctl.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux systemd 定时器 timer]]></title>
    <url>%2Flinux%2Fsystemd%2Ftimer.html</url>
    <content type="text"><![CDATA[用来取代 crontab systemd 系列文章请查看：https://www.khs1994.com/tags/systemd/ 要使用定时器必须编写两个文件： name.timer 配置时间。 name.service 配置具体执行的命令。 注意：这两个文件的名称是相同的，只是后缀不同。 编写脚本/usr/local/bin/name.sh 123#!/bin/bashdate &gt;&gt; /tmp/name.txtecho 1 &gt;&gt; /tmp/name.txt 在 /etc/systemd/system 文件夹内编写下面的两个文件。 name.timer123456789101112[Unit]# 描述信息Description=My systemd timer Demo[Timer]# 首次运行要在启动后10分钟后OnBootSec=10min# 每次运行间隔时间OnUnitActiveSec=1h[Install]WantedBy=multi-user.target 详细信息请查看以下网址： http://www.jinbuguo.com/systemd/systemd.timer.html https://www.freedesktop.org/software/systemd/man/systemd.timer.html 用法举例12345678910[Timer]OnCalendar=*-*-* *:*:00 # 每分钟执行，与 crontab 类似。# hourly → *-*-* *:00:00# daily → *-*-* 00:00:00# monthly → *-*-01 00:00:00# weekly → Mon *-*-* 00:00:00# yearly → *-01-01 00:00:00# quarterly → *-01,04,07,10-01 00:00:00# semiannually → *-01,07-01 00:00:00 name.service1234567[Unit]# 描述信息Description=My systemd timer Demo[Service]Type=simpleExecStart=/usr/local/bin/name.sh 启用定时器12345$ sudo systemctl daemon-reload$ sudo systemctl enable name.timer$ sudo systemctl start name.timer 查看定时器1$ systemctl list-timer 查看日志。 1$ sudo journalctl -u name.service]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux systemd 详解]]></title>
    <url>%2Flinux%2Fsystemd%2FREADME.html</url>
    <content type="text"><![CDATA[目前几乎所有的 Linux 发行版已切换到 systemd。 GitHub：https://github.com/systemd/systemd 官方网站：https://www.freedesktop.org/wiki/Software/systemd/ systemd 系列文章请查看：https://www.khs1994.com/tags/systemd/ 拼写systemd 均为小写，其他任何写法都不正确。 命令systemctlstart stop restart kill reload sudo systemctl daemon-reload enable disable systemd-analyzehostnamectl查看或者设置当前主机信息。 1$ sudo hostnamectl set-hostname NAME localectl控制系统的本地化与键盘布局。 1$ sudo localectl set-locale LANG=zh_CN.utf8 | LANG=en_US.UTF-8 timedatectl设置时间、时区 1234567$ timedatectl set-time TIME$ timedatectl set-timezone ZONE# 查看时区列表 /usr/share/zoneinfo/$ timedatectl list-timezones loginctl查看当前登录用户 Unit主要分为以下几种 Service Target Timer 列出正在运行的 Unit1$ sudo systemctl list-units 列出所有的 Unit1$ sudo systemctl list-units -all 查看依赖关系1$ sudo systemctl list-dependencies docker.service Unit 配置文件/etc/systemd/system /usr/lib/systemd/system 列出所有配置文件1$ sudo systemctl list-unit-files 查看 Unit 配置文件1$ sudo systemctl cat docker.service 状态enabled disabled static 没有 Installl，无法执行，只能作为其他配置文件的依赖。 masked 该配置文件被禁止建立启动链接 12345678910111213141516171819202122232425262728293031[Unit] 服务的说明 Description= 描述服务Documentation= 文档地址Requires= 当前 Unit 依赖的其他 UnitWants= 与当前 Unit 配合的其他 UnitBindsTo= 与 Requires 类似，其指定的 Unit 如果退出，则当前 Unit 也将停止运行Before= 该字段指定的 Unit 要启动，那么必须在当前 Unit 之后启动After= 该字段指定的 Unit 要启动，那么必须在当前 Unit 之前启动Conflicts= 该字段指定的 Unit 不能与当前 Unit 同时启动[Service] 服务运行参数的设置Environment= 设置环境变量Type=forking 是后台运行的形式ExecStartPre= 启动当前服务之前执行的命令 ExecStart= 服务的具体运行命令ExecStartPost= 启动当前服务之后执行的命令ExecReload= 重启命令ExecStop= 停止命令ExecStopPost= 停止当前服务之后执行的命令RestartSec= 自动重启当前服务间隔的秒数Restart= 定义何种情况 systemd 会自动重启当前服务，可能的值包括 always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdogTimeoutSec 定义 systemd 停止当前服务之前等待的秒数# [Service]的启动、重启、停止命令全部要求使用绝对路径 [Install]WantedBy= 值为一个或多个 Target，当前 Unit 被 enable 时，符号链接放到 /etc/systemd/system/ 目录下面# 以 Target+ .wants 后缀构成的子目录中RequireBy=Alias= 当前 Unit 可用于启动的别名Also= 当前 Unit 被 enable 时，激活该字段指定的 Unit TargetTarget 是一组 Unit 的集合 日志管理 journalctl查看某个 Unit 的日志1$ sudo journalctl -u docker.service 定时器单元 取代 Cron*.timer 相关链接 http://www.jinbuguo.com/systemd/ http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html https://www.ibm.com/developerworks/cn/linux/1407_liuming_init3/ http://blog.jobbole.com/97248/ http://www.cnblogs.com/piscesLoveCc/p/5867900.html Arch wiki systemd]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>systemd</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH 隧道与转发内网穿透（转载）]]></title>
    <url>%2Flinux%2Fssh%2Fproxy.html</url>
    <content type="text"><![CDATA[大家都知道 SSH 是一种安全的传输协议，用在连接服务器上比较多。不过其实除了这个功能，它的隧道转发功能更是吸引人。下面是个人根据自己的需求以及在网上查找的资料配合自己的实际操作所得到的一些心得。 SSH/plink 命令的基本资料123$ ssh -C -f -N -g -L listen_port:DST_Host:DST_port user@Tunnel_Host$ ssh -C -f -N -g -R listen_port:DST_Host:DST_port user@Tunnel_Host$ ssh -C -f -N -g -D listen_port user@Tunnel_Host 相关参数的解释： -f Fork into background after authentication. 后台认证用户/密码，通常和 -N 连用，不用登录到远程主机。 -L port:host:hostport 将本地机(客户机)的某个端口转发到远端指定机器的指定端口. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 同时远程主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有 root 才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -R port:host:hostport 将远程主机(服务器)的某个端口转发到本地端指定机器的指定端口. 工作原理是这样的, 远程主机上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转向出去, 同时本地主机和 host 的 hostport 端口建立连接. 可以在配置文件中指定端口的转发. 只有用 root 登录远程主机才能转发特权端口. IPv6 地址用另一种格式说明: port/host/hostport -D port 指定一个本地机器「动态的」应用程序端口转发. 工作原理是这样的, 本地机器上分配了一个 socket 侦听 port 端口, 一旦这个端口上有了连接, 该连接就经过安全通道转发出去, 根据应用程序的协议可以判断出远程主机将和哪里连接. 目前支持 SOCKS4 协议, 将充当 SOCKS4 服务器. 只有 root 才能转发特权端口. 可以在配置文件中指定动态端口的转发. -C Enable compression. 压缩数据传输。 -N Do not execute a shell or command. 不执行脚本或命令，通常与 -f 连用。 -g Allow remote hosts to connect to forwarded ports. 在 -L/-R/-D 参数中，允许远程主机连接到建立的转发的端口，如果不加这个参数，只允许本地主机建立连接。 注：这个参数我在实践中似乎始终不起作用。 建立本地 SSH 隧道例子在我们计划建立一个本地 SSH 隧道之前，我们必须清楚下面这些数据： 中间服务器 d 的 IP 地址要访问服务器 c 的 IP 地址和端口 现在，我们把上面这张图变得具体一些，给这些机器加上 IP 地址。并且根据下面这张图列出我们的计划： 需要访问 234.234.234.234 的 FTP 服务，也就是端口 21，中间服务器是 123.123.123.123 现在我们使用下面这条命令来达成我们的目的 1234$ ssh -N -f -L 2121:234.234.234.234:21 123.123.123.123$ ftp localhost:2121# 现在访问本地2121端口，就能连接234.234.234.234的21端口了 这里我们用到了 SSH 客户端的三个参数，下面我们一一做出解释： -N 告诉SSH客户端，这个连接不需要执行任何命令。仅仅做端口转发 -f 告诉SSH客户端在后台运行 L 做本地映射端口，被冒号分割的三个部分含义分别是 需要使用的本地端口号 需要访问的目标机器IP地址（IP: 234.234.234.234） 需要访问的目标机器端口（端口: 21) 最后一个参数是我们用来建立隧道的中间机器的IP地址(IP: 123.123.123.123) 我们再重复一下 -L 参数的行为。-L X:Y:Z 的含义是，将 IP 为 Y 的机器的 Z 端口通过中间服务器映射到本地机器的 X 端口。 在这条命令成功执行之后，我们已经具有绕过公司防火墙的能力，并且成功访问到了我们喜欢的一个 FTP 服务器了。 如何建立远程 SSH 隧道通过建立本地 SSH 隧道，我们成功地绕过防火墙开始下载 FTP 上的资源了。那么当我们在家里的时候想要察看下载进度怎么办呢？大多数公司的网络是通过路由器接入互联网的，公司内部的机器不会直接与互联网连接，也就是不能通过互联网直接访问。通过线路 D-B-A 访问公司里的机器 a 便是不可能的。也许你已经注意到了，虽然 D-B-A 这个方向的连接不通，但是 A-B-D 这个方向的连接是没有问题的。那么，我们能否利用一条已经连接好的 A-B-D 方向的连接来完成 D-B-A 方向的访问呢？答案是肯定的，这就是远程 SSH 隧道的用途。 与本地 SSH 一样，我们在建立远程 SSH 隧道之前要清楚下面几个参数： 需要访问内部机器的远程机器的IP地址（这里是123.123.123.123） 需要让远程机器能访问的内部机器的IP地址(这里因为是想把本机映射出去，因此IP是127.0.0.1) 需要让远程机器能访问的内部机器的端口号(端口:22) 在清楚了上面的参数后，我们使用下面的命令来建立一个远程SSH隧道 1$ ssh -N -f -R 2222:127.0.0.1:22 123.123.123.123 现在，在 IP 是 123.123.123.123 的机器上我们用下面的命令就可以登陆公司的 IP 是 192.168.0.100 的机器了。 1$ ssh -p 2222 localhost -N -f 这两个参数我们已经在本地 SSH 隧道中介绍过了。我们现在重点说说参数 -R。该参数的三个部分的含义分别是: 远程机器使用的端口（2222） 需要映射的内部机器的IP地址(127.0.0.1) 需要映射的内部机器的端口(22) 例如：-R X:Y:Z 就是把我们内部的Y机器的Z端口映射到远程机器的X端口上。 建立 SSH 隧道的几个技巧自动重连隧道可能因为某些原因断开，例如：机器重启，长时间没有数据通信而被路由器切断等等。因此我们可以用程序控制隧道的重新连接，例如一个简单的循环或者使用 djb’s daemontools . 不管用哪种方法，重连时都应避免因输入密码而卡死程序。关于如何安全的避免输入密码的方法，请参考我的 如何实现安全的免密码ssh登录 。这里请注意，如果通过其他程序控制隧道连接，应当避免将SSH客户端放到后台执行，也就是去掉-f参数。 保持长时间连接有些路由器会把长时间没有通信的连接断开。SSH 客户端的 TCPKeepAlive 选项可以避免这个问题的发生，默认情况下它是被开启的。如果它被关闭了，可以在 ssh 的命令上加上 -o TCPKeepAlive=yes 来开启。 另一种方法是，去掉 -N 参数，加入一个定期能产生输出的命令。例如: top 或者 vmstat。下面给出一个这种方法的例子： 1$ ssh -R 2222:localhost:22 123.123.123.123 "vmstat 30" 检查隧道状态有些时候隧道会因为一些原因通信不畅而卡死，例如：由于传输数据量太大，被路由器带入 stalled 状态。这种时候，往往 SSH 客户端并不退出，而是卡死在那里。一种应对方法是，使用 SSH 客户端的 ServerAliveInterval 和 ServerAliveCountMax 选项。 ServerAliveInterval 会在隧道无通信后的一段设置好的时间后发送一个请求给服务器要求服务器响应。如果服务器在 ServerAliveCountMax 次请求后都没能响应，那么 SSH 客户端就自动断开连接并退出，将控制权交给你的监控程序。这两个选项的设置方法分别是在 ssh 时加入 -o ServerAliveInterval=n 和 -o ServerAliveCountMax=m。 如何将端口绑定到外部地址上使用上面的方法，映射的端口只能绑定在 127.0.0.1 这个接口上。也就是说，只能被本机自己访问到。如何才能让其他机器访问这个端口呢？我们可以把这个映射的端口绑定在 0.0.0.0 的接口上，方法是加上参数 -b 0.0.0.0。同时还需要打开 SSH 服务器端的一个选项 －GatewayPorts。默认情况下它应当是被打开的。如果被关闭的话，可以在 /etc/sshd_config 中修改 GatewayPorts no 为 GatewayPorts yes 来打开它。 通过 SSH 隧道建立 SOCKS 服务器如果我们需要借助一台中间服务器访问很多资源，一个个映射显然不是高明的办法（事实上，高明确实没有用这个方法）。幸好，SSH 客户端为我们提供了通过SSH隧道建立 SOCKS 服务器的功能。 通过下面的命令我们可以建立一个通过 123.123.123.123 的 SOCKS 服务器。 12345$ ssh -N -f -D 1080 123.123.123# 将端口绑定在127.0.0.1上$ ssh -N -f -D 0.0.0.0:1080 123.123.123.123# 将端口绑定在0.0.0.0上 通过 SSH 建立的 SOCKS 服务器使用的是 SOCKS5 协议，在为应用程序设置 SOCKS 代理的时候要特别注意。 相关链接 http://blog.chinaunix.net/uid-7530389-id-2050093.html]]></content>
      <categories>
        <category>Linux</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSH 配置详解]]></title>
    <url>%2Flinux%2Fssh%2FREADME.html</url>
    <content type="text"><![CDATA[本文详细介绍了 SSH 的配置。 无密码登录12345678# 产生公钥与私钥对$ ssh-keygen# 按三次回车键# 将本机的公钥 id_rsa.pub 复制到远程机器的 ~/.ssh/authorized_keys 文件中$ ssh-copy-id user@ip UbuntuSSH 分客户端 openssh-client 和服务端 openssh-server 如果你只是想登陆别的机器只需要安装客户端 1$ sudo apt install openssh-client 如果要使本机开放 SSH 服务就需要安装服务端 1$ sudo apt install openssh-server 然后确认 SSH 服务端是否启动了： 1$ ps -e |grep ssh 如果看到 sshd 那说明 SSH 服务端已经启动了,如果没有则可以这样启动： 1$ sudo /usr/sbin/sshd 配置ssh-server 配置文件位于 /etc/ssh/sshd_config 在这里可以定义 SSH 的服务端口，默认端口是 22，你可以自己定义成其他端口号。 不允许密码登录,只允许公钥登录12345678910# 务必配置此项PubkeyAuthentication yes# To disable tunneled clear text passwords, change to no here!PasswordAuthentication no#PermitEmptyPasswords no# Change to yes to enable challenge-response passwords (beware issues with# some PAM modules and threads)ChallengeResponseAuthentication no 之后重启 sshd 服务。现在我们在一台不带信任 key 的机器尝试登录，那么会提示如下信息: 12⋊&gt; ~ ssh ubuntu@123.206.62.18Permission denied (publickey). 解决自动断开服务端设置环境变量 TMOUT=0，在客户端 ~/.ssh/config 文件中进行如下配置: 12Host * ServerAliveInterval 60 相关链接 http://www.cnblogs.com/kqdongnanf/p/6517836.html http://blog.csdn.net/iloveyin/article/details/11808377]]></content>
      <categories>
        <category>Linux</category>
        <category>SSH</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>SSH</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PXE Linux 自动部署]]></title>
    <url>%2Flinux%2Fserver%2Fpxe.html</url>
    <content type="text"><![CDATA[Linux 自动部署需要以下软件 PXE dhcp tftp vsftpd kickstart。 服务器 IP 192.168.57.101 安装软件1$ yum install tftp-server dhcp syslinux vsftpd xinetd DHCP修改 /etc/dhcp/dhcpd.conf 文件 1234567891011121314allow booting;allow bootp;ddns-update-style interim;ignore client-updates ;subnet 192.168.57.0 netmask 255.255.255.0 &#123; option routers 192.168.57.1; option subnet-mask 255.255.255.0; range dynamic-bootp 192.168.57.101 192.168.57.200; default-lease-time 21600; max-lease-time 43200; next-server 192.168.57.101; #注意改地址 filename "pxelinux.0";&#125; TFTP配置 xinetd将 /etc/xinetd.d/tftp 中的 disable 值设为 no syslinux挂载安装光盘在 root 家目录新建 cdrom 文件夹，挂载光盘 12$ mkdir cdrom$ mount /dev/cdrom cdrom 复制引导文件123456$ cd /var/lib/tftpboot$ cp /usr/share/syslinux/pxelinux.0 .$ cp ~/cdrom/images/pxeboot/&#123;initrd.img,vmlinuz&#125; .$ cp ~/cdrom/isolinux/&#123;vesamenu.c32,*.msg&#125; .$ mkdir pxelinux.cfg$ cp ~/cdrom/isolinux/isolinux.cfg pxelinux.cfg/default 编辑 pxelinux.cfg/default 文件。 12345678910#第1行default linux#第64行append initrd=initrd.img inst.stage2=ftp://192.168.57.101 ks=ftp://192.168.57.101/pub/ks.cfg quiet#第70行append initrd=initrd.img inst.stage2=ftp://192.168.57.101 rd.live.check ks=ftp://192.168.57.101/pub/ks.cfg quiet VSFTP复制光盘镜像内容到 ftp 目录1$ cp -r ~/cdrom/* /var/ftp kickstart12$ cp ~/anaconda-ks.cfg /var/ftp/pub/ks.cfg$ chmod +r /var/ftp/pub/ks.fg 修改 /var/ftp/pub/ks.cfg 文件 1234567891011#第6行url --url=ftp://192.168.57.101#第21行timezone Asia/Shanghai --isUtc#第28行clearpart --all -initlabel 开机自启动服务123$ systemctl enable dhcpd$ systemctl enable vsftpd$ systemctl enable xinetd 客户端设置网卡为第一启动项]]></content>
      <categories>
        <category>Linux</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PXE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[E-mail 服务器配置]]></title>
    <url>%2Flinux%2Fserver%2Femail.html</url>
    <content type="text"><![CDATA[电子邮件是—种用电子手段提供信息交换的通信方式，是互联网应用最广的服务。本次实验采用 二级域名邮箱:4s.khs1994.com DNS设置hostnamePostfix (SMTP) 发送安装配置main.cf编辑 /etc/postfix/main.cf 文件 创建账号启动服务Dovecot (IMAP、POP3) 接收安装配置dovecot.conf10-mail.conf10-ssl.conf12345ssl = yes# Preferred permissions: root:root 0444ssl_cert = &lt;/etc/ssl/certs/dovecot.pem# Preferred permissions: root:root 0400ssl_key = &lt;/etc/ssl/private/dovecot.pem 20-imap.conf1234protocol imap &#123; ssl_cert = &lt;/etc/ssl/certs/imap.pem ssl_key = &lt;/etc/ssl/private/imap.pem&#125; 创建储存目录启动服务相关链接 http://wiki.dovecot.org/SSL/DovecotConfiguration http://blog.csdn.net/stwstw0123/article/details/47130293]]></content>
      <categories>
        <category>Linux</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>E-mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DHCP 服务器配置]]></title>
    <url>%2Flinux%2Fserver%2Fdhcp.html</url>
    <content type="text"><![CDATA[DHCP（Dynamic Host Configuration Protocol，动态主机配置协议）是一个局域网的网络协议，使用 UDP 协议工作，给内部网络或网络服务供应商自动分配 IP 地址。 12$ yum install dhcp$ cp /usr/share/doc/dhcp-4.2.5/dhcpd.conf.example /etc/dhcp/dhcpd.conf 编辑 /etc/dhcp/dhcpd.conf 文件 12345678910subnet 192.168.3.0 netmask 255.255.255.0 &#123;range 192.168.3.10 192.168.3.254;option routers 192.168.3.1;option broadcast-address 192.168.3.31;default-lease-time 3600;max-lease-time 7200;#指向pxe服务器next-server 192.168.3.10;filename "pxelinux.0";&#125; 重启服务 1$ systemctl start dhcpd.service 查看一些资料时的配置选项可能会在新版删除，使用dhcpd启动若有错误会有详细说明]]></content>
      <categories>
        <category>Linux</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>DHCP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DNS 服务器配置]]></title>
    <url>%2Flinux%2Fserver%2Fdns.html</url>
    <content type="text"><![CDATA[DNS（Domain Name System，域名系统），因特网上作为域名和 IP 地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的 IP 数串。 安装1$ yum install bind bind-chroot 修改主配置文件编辑 /etc/named.conf 文件 1234...listen-on port 53 &#123; any; &#125;;...allow-query &#123; any; &#125;; 增加域名编辑 /etc/named.rfc1912.zones 文件 1234567#增加以下内容zone "tkhs1994.com" In &#123; type master; file "tkhs1994.com.zone"; allow-update &#123; none; &#125;;&#125;; 配置文件编辑 /var/named/tkhs1994.com.zone 文件。 12345$TTL 7200@ IN SOA @ khs1994.tkhs1994.com. (222 1H 15M 1W 1D)@ IN NS dns1.tkhs1994.com.dns1 IN A 192.168.56.200* IN A 127.0.0.1]]></content>
      <categories>
        <category>Linux</category>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>DNS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 初始化配置]]></title>
    <url>%2Flinux%2Fubuntu.html</url>
    <content type="text"><![CDATA[本文简要介绍了 Ubuntu 常用配置。 网络配置静态IP编辑 /etc/network/interface 文件。 12345678# The primary network interfaceauto enp0s3iface enp0s3 inet dhcpauto enp0s8iface enp0s8 inet staticaddress 192.168.56.130netmask 255.255.255.0 DNS编辑 /etc/resolvconf.conf 文件 12# configure your subscribers configuration files below.name_servers=127.0.0.1 常用软件12$ sudo apt install gcc g++ \ openssl libssl-dev mail1$ apt install mailutils update-alternatives http://persevere.iteye.com/blog/1479524 娱乐网易云音乐 http://music.163.com/#/download mpv 播放器 https://mpv.io/ https://launchpad.net/~mc3man/+archive/ubuntu/mpv-tests 123$ sudo add-apt-repository ppa:mc3man/mpv-tests$ sudo apt update$ sudo apt install mpv 工具AtomChrometilix 终端 https://github.com/gnunn1/tilix 123$ sudo add-apt-repository ppa:webupd8team/terminix$ sudo apt update$ sudo apt install terminix B 站介绍视频 http://www.bilibili.com/video/av5879001/ OBS 录屏工具123$ sudo apt-get install ffmpeg$ sudo add-apt-repository ppa:obsproject/obs-studio$ sudo apt-get update &amp;&amp; sudo apt-get install obs-studio https://github.com/jp9000/obs-studio/wiki/Install-Instructions#linux Firefox Flash 插件 https://get.adobe.com/flashplayer/?loc=cn 1$ sudo cp /home/khs1994/下载/libflashplayer.so /usr/lib/firefox-addons/plugins Adobe重新支持Linux平台：Flash Player 23开始测试 虚拟机 https://www.virtualbox.org/ 双网卡 卡1桥接 卡2hostonly 搜狗拼音输入法 http://pinyin.sogou.com/linux/?r=pinyin PDF https://code-industry.net/free-pdf-editor/ 主题不建议使用，使用默认就好 123#移动启动器到底部和恢复默认$ gsettings set com.canonical.Unity.Launcher launcher-position Bottom $ gsettings set com.canonical.Unity.Launcher launcher-position Left]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 7 最小化安装初始化配置]]></title>
    <url>%2Flinux%2Fcentos.html</url>
    <content type="text"><![CDATA[本文简要介绍了 CentOS 7 常用配置。 yum 源配置阿里云开源镜像http://mirrors.aliyun.com 1234$ mv /etc/yum.repos.d/CentOS-Base.repo \ /etc/yum.repos.d/CentOS-Base.repo.backup$ wget -O /etc/yum.repos.d/CentOS-Base.repo \ http://mirrors.aliyun.com/repo/Centos-7.repo EPEL12$ wget -O /etc/yum.repos.d/epel.repo \ http://mirrors.aliyun.com/repo/epel-7.repo 网络设置编辑 /etc/sysconfig/network-scripts/ifcfg-enp0s8 1234567BOOTPROTO=static # 静态 IP...IPADDR=192.168.56.121NETMASK=225.225.225.0NAME=enp0s8DEVICE=enp0s8ONBOOT=yes # 开机自动连接网络 路由编辑 /etc/sysconfig/network-scripts/route-enp0s8 文件 123192.168.56.0/24 via 192.168.56.1 dev enp0s8# 虚拟机采用双网卡，网卡1桥接模式；网卡2 host-only 模式此处添加网卡2 ip段 192.168.56.0、24 静态路由 显示路由表1$ ip route show|column -t 添加静态路由1$ ip route add 10.15.150.0/24 via 192.168.150.253 dev enp0s3 删除静态路由123$ ip route del 10.15.150.0/24$ nmcli dev disconnect enp0s3 &amp;&amp; nmcli dev connect enp0s3 存在多个网卡时，默认路由似乎是随机经由某个网卡设备。检查了所有连接配置文件后发现，第一网卡的默认连接配置文件 ifcfg-eth0 设置了GATEWAY0（此设置会覆盖/etc/sysconfig/network 定义的全局默认网关），第二网卡的连接配置文件 ifcfg-eth1 使用的是dhcp，会在启动时也分配默认网关，两个默认网关让计算机糊涂了。这是在测试系统里经常发生的现象，生产系统一般不会让网卡用dhcp，或者即使是用了也会仔细分配默认网关防止冲突。 DNS（重要）编辑 /etc/NetworkManager/NetworkManager.conf 1234[main]plugins=ifcfg-rh#增加dns=nonedns=none 编辑 /etc/resolv.conf 文件 1nameserver 114.114.114.114 重启网络 1$ systemctl restart NetworkManager.service 常用软件包12345678$ yum install zip unzip \ wget \ gcc gcc-c++ gdb \ git \ openssl-devel \ bash-completion \ tree \ vim 安全配置关闭防火墙、selinux1$ systemctl status firewalld 停止 firewall1$ systemctl stop firewalld.service 禁止 firewall 开机启动12$ systemctl disable firewalld.service$ /usr/sbin/sestatus -v 关闭 SELINUX编辑 /etc/selinux/config 文件。 1234#SELINUX=enforcing #注释掉#SELINUXTYPE=targeted #注释掉#增加SELINUX=disabled 执行以下命令生效，或者重启电脑 1$ setenforce 0 删除旧内核12$ rpm -qa | grep kernel$ yum remove kernel-3.10.0-514.10.2.el7.x86_64 常用命令查看硬盘 UUID1$ blkid 相关链接 http://www.centoscn.com/CentOS/Intermediate/2015/1211/6508.html]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Debian 系包管理工具 apt 简介]]></title>
    <url>%2Flinux%2Fpackage_management%2Fapt.html</url>
    <content type="text"><![CDATA[apt 是 Debian Ubuntu 上的包管理工具。 源文件位于 /etc/apt/sources.list installremove删除包 autoremove删除无用的包 purge删除包及其配置文件 update升级包列表 upgrade升级包 list1234$ apt list gitListing... Donegit/stable,stable,now 1:2.11.0-3+deb9u2 amd64 [installed] 不加包名的话，列出所有的包。 show显示包信息 1$ apt show git search查找包 1$ apt search git full-upgrade升级系统 edit-sources编辑 apt 源文件 dpkgdpkg 命令安装本地的 deb 包。 dpkg -i 安装包 当缺少依赖的包时，可以使用 apt install -f 来安装依赖的包。 dpkg -r 删除包 dpkg -P 卸载包，并删除配置文件 dpkg -s 显示包的详细信息 dpkg -c 查询 deb 包文件中所包含的文件]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RedHat 系包管理工具 yum 简介]]></title>
    <url>%2Flinux%2Fpackage_management%2Fyum.html</url>
    <content type="text"><![CDATA[yum 是 CentOS 上的包管理工具。 install]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Alpine Linux 包管理工具 apk 简介]]></title>
    <url>%2Flinux%2Fpackage_management%2Fapk.html</url>
    <content type="text"><![CDATA[官方 Wiki：https://wiki.alpinelinux.org/wiki/Alpine_Linux_package_management 由于基于 Alpine 的 Docker 镜像体积较 Debian 小很多，很有必要学习一下 Alpine 的包管理工具 apk。就像 CentOS 的 yum，Ubuntu 的 apt。 源文件位于 /etc/apk/repositories 你可以在这里搜索所有的包 http://pkgs.alpinelinux.org/packages 安装1$ apk add 参数--no-cache 用法举例123$ apk add --no-cache --virtual .name git openssh-client$ apk del .name 这种用法在 Dockerfile 中很常见，将多个包的集合命名为一个名称，方便了后续卸载。 卸载1$ apk del 更新更新包列表1$ apk update 升级所有已安装的包1$ apk upgrade 搜索1$ apk search 查看包信息1234567# 列出所有已安装的包$ apk info# 列出某个包的详情$ apk info git]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 网络相关]]></title>
    <url>%2Flinux%2Fnetwork%2FREADME.html</url>
    <content type="text"><![CDATA[https://www.imooc.com/learn/344 12345$ telnet 192.168.199.120 80$ nc -z 192.192.193.211 22$ nc -vz 192.168.120 20-30 谁占用了端口WindowsPowerShell 12345$ netstat -ano | select-string port# 结果最后一行为 pid$ stop-process pid Linux12345$ lsof -i$ lsof -i:8000$ netstat -anp | grep 80 ss http://man.linuxde.net/ss 1$ ss -h Other nslookup ip route list 查看路由表 tracepath 追踪并显示报文到达目的主机所经过的路由信息 traceroute]]></content>
      <categories>
        <category>Linux</category>
        <category>Network</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CocoaPods 安装配置]]></title>
    <url>%2Fother%2Fios%2FREADME.html</url>
    <content type="text"><![CDATA[首先安装配置好 ruby，CocoaPods 需要 Ruby 的版本大于 2.2.2，不然会报错： 1Error installing pods: activesupport requires Ruby version &gt;= 2.2.2 macOS 默认自带是 2.0 版本，所以需要升级。 123$ brew update$ brew install ruby 删除 gem 源12345$ gem sources --remove https://rubygems.org/# 据说淘宝源已停止维护，以前添加过淘宝源的删除$ gem sources --remove https://ruby.taobao.org/ 添加 gem 国内源12345678$ gem sources -a https://gems.ruby-china.org/$ gem sources -l*** CURRENT SOURCES ***https://gems.ruby-china.org/# 出现以上提示说明添加成功 安装1$ sudo gem install -n /usr/local/bin cocoapods 若 Xcode 为预览版 ，在命令后边添加 --pre 查看版本123$ pod --version$ sudo xcode-select --switch /Applications/Xcode.app 克隆仓库123$ pod setup# 本质是从 GitHub 克隆代码，一些国内镜像源停止更新，通过修改 host 加速 GitHub 测试1$ pod search AFNetworking 可能出现错误 1[!] Unable to find a pod with name, author, summary, or description matching `AFNetworking` 解决方法 1$ rm ~/Library/Caches/CocoaPods/search_index.json 使用切换到 Xcode 项目文件夹1$ cd Desktop/swiftweahter 编辑配置文件12345678910111213$ vi Podfileplatform :ios, '10.0'use_frameworks!target 'MyApp' do pod 'AFNetworking', '~&gt; 2.6' pod 'ORStackView', '~&gt; 3.0' pod 'SwiftyJSON', '~&gt; 2.3'end# 输入以上内容，target '＊＊＊＊' do 单引号内填入你自己的项目名称 安装1$ pod install --verbose --no-repo-update 打开项目打开项目用CocoaPodsDemo.xcworkspace 更新1$ sudo gem update --system 卸载1# 待补充 相关链接 http://www.cocoachina.com/bbs/read.php?tid=193398&amp;page=1 http://blog.csdn.net/ralbatr/article/details/39082937 http://www.jianshu.com/p/2ef8a38416c4]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 使用详解]]></title>
    <url>%2Fother%2Fjava%2Fgradle.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>Java</category>
        <category>Gradle</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 使用详解]]></title>
    <url>%2Fother%2Fjava%2Fmaven.html</url>
    <content type="text"><![CDATA[Maven 简单配置说明。 配置镜像、中央仓库配置文件位于~/.m2/settings.xml 1234567891011121314151617&lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- &lt;mirror&gt; &lt;id&gt;google-maven-central&lt;/id&gt; &lt;name&gt;Google Maven Central&lt;/name&gt; &lt;url&gt;https://maven-central.storage.googleapis.com &lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; --&gt;&lt;/mirrors&gt; 项目配置文件位于项目下 pom.xml 12345678910111213&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;releases&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled&gt;true&lt;/enabled&gt; &lt;/snapshots&gt; &lt;/repository&gt;&lt;/repositories&gt; 命令查看版本1$ mvn -v 编译1$ mvn compile 测试1$ mvn test 打包，生成 .jar 文件123$ mvn package$ mvn clean 安装jar包到本地仓库1$ mvn install 自动创建目录骨架交互方式1$ mvn archetype:generate 命令模式123456$ mvn archetype:generate -DgroupId=com.khs1994.maven -DartifactId=maven-demo -Dversion=1.0-SNAPSHOT \ -Dpackage=com.khs1994.maven.demo# groupId com.khs1994.项目名# artifactId 项目名-模块名 More Information Maven仓库：http://mvnrepository.com/]]></content>
      <categories>
        <category>Java</category>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Java 初始化配置]]></title>
    <url>%2Fother%2Fjava%2FREADME.html</url>
    <content type="text"><![CDATA[Linux 可能自带 openjdk，先将其卸载，之后官网下载再进行安装。 卸载自带 openjdk12345$ rpm -qa | grep java$ rpm -qa | grep jdk$ rpm -e --nodeps *** Debian 系请使用 apt 卸载。 增加环境变量配置编辑 /etc/profile 文件，在末尾加入下面的内容。​ 1234export JAVA_HOME=/usr/local/jdk1.8.0_92export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH Hello World!12345public class HelloWorld &#123; public static void main(String[] args)&#123; System.out.println("Hello World!"); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash set 详解]]></title>
    <url>%2Flinux%2Fshell%2Fset.html</url>
    <content type="text"><![CDATA[http://www.ruanyifeng.com/blog/2017/11/bash-set.html set -u 遇到不存在的变量就会报错，并停止执行。 set -x 用来在运行结果之前，先输出执行的那一行命令。 set -e 脚本只要发生错误，就终止执行 set +e 表示关闭 -e 选项 set -o pipefail 管道中只要有命令失败就退出。]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Shell date 命令详解]]></title>
    <url>%2Flinux%2Fshell%2Fdate.html</url>
    <content type="text"><![CDATA[以给定的格式显示当前时间。 123456789101112131415161718192021222324252627282930313233343536373839404142434445%% 一个文字的 %%a 当前locale 的星期名缩写(例如： 日，代表星期日)%A 当前locale 的星期名全称 (如：星期日)%b 当前locale 的月名缩写 (如：一，代表一月)%B 当前locale 的月名全称 (如：一月)%c 当前locale 的日期和时间 (如：2005年3月3日 星期四 23:05:25)%C 世纪；比如 %Y，通常为省略当前年份的后两位数字(例如：20)%d 按月计的日期(例如：01)%D 按月计的日期；等于%m/%d/%y%e 按月计的日期，添加空格，等于%_d%F 完整日期格式，等价于 %Y-%m-%d%g ISO-8601 格式年份的最后两位 (参见%G)%G ISO-8601 格式年份 (参见%V)，一般只和 %V 结合使用%h 等于%b%H 小时(00-23)%I 小时(00-12)%c 按年计的日期(001-366)%k 时(0-23)%l 时(1-12)%m 月份(01-12)%M 分(00-59)%n 换行%N 纳秒(000000000-999999999)%p 当前locale 下的"上午"或者"下午"，未知时输出为空%P 与%p 类似，但是输出小写字母%r 当前locale 下的 12 小时时钟时间 (如：11:11:04 下午)%R 24 小时时间的时和分，等价于 %H:%M%s 自UTC 时间 1970-01-01 00:00:00 以来所经过的秒数%S 秒(00-60)%t 输出制表符 Tab%T 时间，等于%H:%M:%S%u 星期，1 代表星期一%U 一年中的第几周，以周日为每星期第一天(00-53)%V ISO-8601 格式规范下的一年中第几周，以周一为每星期第一天(01-53)%w 一星期中的第几日(0-6)，0 代表周一%W 一年中的第几周，以周一为每星期第一天(00-53)%x 当前locale 下的日期描述 (如：12/31/99)%X 当前locale 下的时间描述 (如：23:13:48)%y 年份最后两位数位 (00-99)%Y 年份%z +hhmm 数字时区(例如，-0400)%:z +hh:mm 数字时区(例如，-04:00)%::z +hh:mm:ss 数字时区(例如，-04:00:00)%:::z 数字时区带有必要的精度 (例如，-04，+05:30)%Z 按字母表排序的时区缩写 (例如，EDT) 默认情况下，日期的数字区域以 0 填充，以下可选标记可以跟在 % 后: 12345- (连字符)不填充该域_ (下划线)以空格填充0 (数字0)以0 填充^ 如果可能，使用大写字母# 如果可能，使用相反的大小写]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash 条件判断与流程控制相关语句详解]]></title>
    <url>%2Flinux%2Fshell%2Fif-case-etc.html</url>
    <content type="text"><![CDATA[介绍 if case 等语句。 条件判断语句字符串判断str1 = str2 当两个字符串有相同内容、长度时为真 str1 != str2 当字符串 str1 和 str2 不等时为真 -n str1 当字符串的长度大于 0 时为真(串非空) -z str1 当字符串的长度为 0 时为真(空串) str1 当字符串 str1 为非空时为真 数值的判断int1 -eq int2 两数相等为真 int1 -ne int2 两数不等为真 int1 -gt int2 int1 大于 int2 为真 int1 -ge int2 int1 大于等于 int2 为真 int1 -lt int2 int1 小于 int2 为真 int1 -le int2 int1 小于等于 int2 为真 文件相关的判断语句-r file 用户可读为真 -w file 用户可写为真 -x file 用户可执行为真 -f file 文件为普通文件为真 -d file 文件为目录为真 -c file 文件为字符特殊文件为真 -b file 文件为块特殊文件为真 -s file 文件大小非 0 时为真 -t file 当文件描述符(默认为 1 )指定的设备为终端时为真 逻辑判断-a 与 -o 或 ! 非 if基本结构1234567if [ 条件判断 ]; thendo something hereelif [ 条件判断 ]; thendo another thing hereelsedo something else herefi 或者 123456if [ 条件判断 ]then Commandelse Commandfi 举例如下 123456789101112131415# 获取操作系统类型SYSTEM=`uname -s`# [] 内两边必须有空格# if 与 then 在同一行，判断语句后加上 ;if [ $SYSTEM = "Linux" ];thenecho "Linux"elseecho "OS is not Linuix"fi# 写在一行if [ $SYSTEM = "Linux" ];then echo "Linux"; else echo "OS is not Linuix"; fi 也可以写成 12345678SYSTEM=`uname -s`if [ $SYSTEM = "Linux" ]thenecho "Linux"elseecho "OS is not Linuix"fi case基本结构12345678910111213case $1 in 模式1 ） 命令序列1 ;; 模式2 ） 命令序列2 ;; * ） 默认执行的命令序列 ;;esac for123for (( i = 0; i &lt; 10; i++ )); do #statementsdone for in1234for arg in "$@"do echo $argdone while123while [[ condition ]]; do #statementsdone until123until [[ condition ]]; do #statementsdone 参考链接 http://www.cnblogs.com/huai371720876/p/4561195.html]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash 函数详解]]></title>
    <url>%2Flinux%2Fshell%2Ffunction.html</url>
    <content type="text"><![CDATA[默认情况下，脚本中定义的任何变量均为 全局变量，可以在函数内访问。 创建函数123456789101112131415161718# function关键字创建函数function func1 &#123; echo "this is func1"&#125;# 接近其它语言形式的函数func2() &#123; echo "this is func2"&#125;# sh 函数命名使用下划线分隔fun_read()&#123; echo "sh function"&#125; 注意，为了兼容 sh，尽量使第二种方法。 引用函数12func1func2 返回值return 只能用来返回整数值（0-255 之间）。 变量作用范围默认情况下，脚本中定义的任何变量均为 全局变量，可以在函数内访问。可以使用 local 关键字来定义局部变量。 位置参数变量 &quot;$*&quot; 被双引号扩住，所有参数被认为是一个字段 for in 循环只会循环一次 &quot;$@&quot; 被双引号扩住，参数会以空格划分开 $# 传入的参数个数。可以为 0 $$ 脚本的当前进程 ID 号。 shift n n 默认为 1 ，该命令用于偏移位置参数变量，原来的 $2 变为 $1，以此类推。 m=${1:-start}如果 $1 存在且不为空，m 就是 $1 如果 $1 不存在或为空，那么 m 就是 start 参考链接 http://www.cnblogs.com/dyllove98/p/3189998.html]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Bash echo read 命令详解]]></title>
    <url>%2Flinux%2Fshell%2Fecho-read.html</url>
    <content type="text"><![CDATA[echo 命令用来输出内容，read 命令用于读取用户输入。 echo 高亮输出格式如下： 12345678$ echo -e "\033[字背景颜色；文字颜色m字符串\033[0m"$ echo -e "\033[41;36m something string \033[0m"$ echo -e "\033[31m 红色字 \033[0m"$ echo -e "\033[34m 黄色字 \033[0m"$ echo -e "\033[41;33m 红底黄字 \033[0m"$ echo -e "\033[41;37m 红底白字 \033[0m" readread 命令从标准输入中读取一行，并把输入行的每个字段的值指定给 shell 变量。 提示语句-p 参数 命令计数-n 参数 当输入的字符数目达到预定数目时，自动退出，并将输入的数据赋值给变量。 等待时间-t 参数 ，单位为秒 关闭回显-s参数，能够使 read 命令中输入的数据不显示在显视器上，例如密码。 printfprintf format-string [arguments] 和 c 类似。 参考链接 http://www.cnblogs.com/lr-ting/archive/2013/02/28/2936792.html]]></content>
      <categories>
        <category>Linux</category>
        <category>Shell</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GitBook 使用详解]]></title>
    <url>%2Fgit%2Fgitbook.html</url>
    <content type="text"><![CDATA[GitBook 示例：https://github.com/yeasy/docker_practice 安装好 Node.js，运行以下命令安装 gitbook 1$ npm install -g gitbook-cli 初始化1$ gitbook init 生成 SUMMARY.md README.md 文件 编写目录编写 SUMMARY.md 文件，之后执行 gitbook init 生成空白的 *.md 文件。 也可以先写内容（*.md 文件），再增加到目录到 SUMMARY.md 文件中。 插件编辑 book.json 文件，之后执行以下命令，安装插件。 1$ gitbook install 生成123$ gitbook build# 静态文件位于 _book 文件夹 插件列表 -sharing ：自带风享 -highlight ：自带代码高亮 -livereload ：自带实时生成 tbfed-pagefooter@git+https://github.com/khs1994/gitbook-plugin-tbfed-pagefooter.git prism ：代码高亮 toggle-chapters ：左侧折叠 expandable-chapters ：左侧折叠 anchor-navigation-ex ：目录、锚点 favicon ：网站图标 相关链接 https://github.com/zhangjikai/gitbook-use]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>GitBook</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git 使用详解]]></title>
    <url>%2Fgit%2FREADME.html</url>
    <content type="text"><![CDATA[本文列举了 Git 的常用配置及使用方法。 123$ git config -g user.name "khs1994"$ git config -g user.email "khs1994@khs1994.com" 常见错误将本地分支与远程分支关系建立起来1$ git branch --set-upstream dev origin/dev 永久删除大文件 https://help.github.com/articles/removing-sensitive-data-from-a-repository/ 自行替换 *.db 为自己的文件规则 12345678$ git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch *.db' --prune-empty --tag-name-filter cat -- --all$ rm -rf .git/refs/original/$ git reflog expire --expire=now --all$ git gc --prune=now$ git gc --aggressive --prune=now$ git push origin --force --all$ git push origin --force --tags 子模块1234# 拉取子模块$ git submodule update --init --recursive$ git submodule add URL DIR 拉取 PR123$ git fetch origin pull/365/merge:branch-fix-1$ git checkout branch-fix-1 配置查看配置 1$ git config -l 或者直接编辑 ~/.gitconfig 文件，但不推荐。 代理设置--unset 取消代理 123$ git config --global [--unset] http.proxy 127.0.0.1:1080$ git config --global [--unset] https.proxy 127.0.0.1:1080 分支查看当前位于哪个分支12345# 准确打印分支，可能在 shell 脚本中用的多$ git rev-parse --abbrev-ref HEAD# git branch 基本操作1234567$ git checkout -b NEW_BRANCH# 等价于以下命令$ git branch NEW_BRANCH ; git checkout NEW_BRANCH$ git branch &#123;-D | -d&#125; BRANCH_NAME 恢复本地仓库与远程仓库保持一致(强制覆盖)123456789# 拉取远程所有分支$ git fetch [origin] [branch] [--all]# 假设当前位于 master 分支，想要与远程的 master 分支保持一致# 若是其他分支请将 master 换为其他分支名即可$ git reset --hard origin/master 恢复某文件到上一次 commit 状态（未 add）1$ git checkout -- modify.md 将 add 的文件移出1$ git reset HEAD file.md fork 与上游代码保持更新12345678910$ git remote -v$ git remote add source URL$ git fetch source# 假设当前位于 master 分支，想要与上游的 master 分支保持一致# 若是其他分支请将 master 换为其他分支名即可$ git rebase source/master 拉取远程仓库的分支（本地分支不存在）1$ git fetch remote_repo remote_branch_name:local_branch_name 本地分支推送到不同名远程分支1$ git push origin master:gh-pages tag123456789$ git tag TAG_NAME commit号$ git tag -a TAG_NAME -m "DESCRIPT" commit号$ git show TAG_NAME$ git tag -d TAG_NAME # delete$ git push origin &#123;TAG_NAME | --tags&#125; 删除远程标签1$ git push origin --delete tag &lt;tagName&gt; Stash暂时储藏已修改未提交的文件，修复 bug 时会用到。 123456789101112131415$ git stash# 返回到了上次 commit 的状态,开始修复问题$ vi bug_file$ git add . ; git commit -m "fix xxx"$ git stash list$ git stash apply [stash@&#123;0&#125;]$ git stash pop # apply last stash and remove it from the list$ git stash clear commit1$ git commit --amend # 重新编辑上一次提交 相关链接 http://www.jianshu.com/p/633ae5c491f5 https://blog.zengrong.net/post/1746.html https://github.com/liuhui998/gitbook]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LNMP Docker 安装配置]]></title>
    <url>%2Fdocker%2Flnmp.html</url>
    <content type="text"><![CDATA[目标：一条命令建立 LNMP 环境（MySQL、Redis、PHP-fpm、Nginx，etc）。 这里只简单列举单容器运行方式，实际请使用 Docker Compose https://github.com/khs1994-docker/lnmp。 GitHub：https://github.com/khs1994-docker/lnmp-quickstart 修订说明 官方建议不再使用 --link，而是使用 Docker 容器网络来连接容器(服务，也即容器互通)。 官方建议不再使用 -v 或者 --volume，而是使用 --mount Docker 17.06+ 准备123$ git clone --depth=1 https://github.com/khs1994-docker/lnmp-quickstart$ cd lnmp-quickstart 创建网络123$ docker network ls$ docker network create -d bridge lnmp 创建 Volume123$ docker volume ls$ docker volume create lnmp-mysql-data MySQL环境变量含义请到这里查看：https://github.com/docker-library/docs/tree/master/mysql 12345678910111213$ docker run -dit \ --network lnmp \ --name mysql \ -p 3306:3306 \ # 若只允许本地登录，可以加上监听的 IP，默认监听全部 IP # –p 127.0.0.1:3306:3306 \ # 设置 root 密码 -e MYSQL_ROOT_PASSWORD=mytest \ # 启动时新建一个数据库 -e MYSQL_DATABASE=test \ # -v lnmp-mysql-data:/var/lib/mysql \ --mount source=lnmp-mysql-data,target=/var/lib/mysql \ mysql Redis12345$ docker run -dit \ --network lnmp \ --name redis \ -p 6379:6379 \ redis:alpine PHP7php-fpm 官方镜像需要通过 Dockerfile 增加 PHP 扩展 增加扩展编辑 Dockerfile 增加 PHP 扩展 12345678FROM php:fpm-alpine3.6RUN docker-php-ext-install pdo_mysqlRUN apk add --no-cache --virtual .build-deps $PHPIZE_DEPS \ &amp;&amp; pecl install redis \ &amp;&amp; docker-php-ext-enable redis \ &amp;&amp; apk del .build-deps 注意: 安装扩展极有可能需要安装依赖包，请使用 RUN apk add --no-cache PACKAGE_NAME 安装依赖。 构建镜像1$ docker build -t username/php:fpm-alpine3.6 . 运行容器123456$ docker run -dit \ --network lnmp \ --name php7 \ # -v $PWD/app:/app \ --mount type=bind,source=$PWD/app,target=/app,readonly \ username/php:fpm-alpine3.6 Nginx12345678910$ docker run -dit \ --network lnmp \ -p 80:80 \ -p 443:443 \ --name nginx \ # -v $PWD/app:/app \ --mount type=bind,source=$PWD/app,target=/app,readonly \ # -v $PWD/conf.d:/etc/nginx/conf.d \ --mount type=bind,source=$PWD/conf.d,target=/etc/nginx/conf.d,readonly \ nginx:alpine 测试 LNMP1234567$ docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe77477b89a65 nginx:alpine "nginx -g 'daemon of…" 3 seconds ago Up 4 seconds 0.0.0.0:80-&gt;80/tcp, 0.0.0.0:443-&gt;443/tcp nginxe74dda1abdb8 username/php:fpm-alpine3.6 "docker-php-entrypoi…" 25 seconds ago Up 26 seconds 9000/tcp php755eb02c94a3a redis:alpine "docker-entrypoint.s…" 46 seconds ago Up 47 seconds 0.0.0.0:6379-&gt;6379/tcp redis314d54410929 mysql "docker-entrypoint.s…" About a minute ago Up About a minute 0.0.0.0:3306-&gt;3306/tcp mysql 访问 127.0.0.1 看到 phpinfo 页面。 访问 127.0.0.1/redis.php 测试 PHP redis 扩展。 1234$ docker exec -it mysql mysql -uroot -pmytestmysql&gt; create database test;Query OK, 1 row affected (0.00 sec) 访问 127.0.0.1/pdo-mysql.php 测试 PHP pdo_mysql 扩展。 docker-compose请访问 khs1994-docker/lnmp 查看。]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>LNMP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git LFS]]></title>
    <url>%2Fgit%2Flfs.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/git-lfs/git-lfs 官方网站：https://git-lfs.github.com/ install二进制软件包在官网自行下载，之后执行 1$ git lfs install 此命令只需执行一次。 跟踪文件123456$ git lfs track "design-resources/design.psd"$ git lfs track "*.png"# list$ git lfs track 推送像往常那样推送就行！ 12345$ git add .$ git commit -m "commit message"$ git push origin master clone1$ git lfs clone url More Information https://coding.net/help/doc/git/.html/git-lfs]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker 安装 Gogs]]></title>
    <url>%2Fgit%2Fgogs.html</url>
    <content type="text"><![CDATA[使用 Docker Compose 安装 Gogs。 GitHub：https://github.com/khs1994-docker/ci docker-compose.yaml编写 docker-compose.yml 文件 123456789101112131415161718192021version: '3'services: gogs: image: gogs/gogs ports: - "22:22" - "10080:3000" volumes: - ./data:/data - ./app.prod.ini:/data/gogs/conf/app.ini - ./ssl:/data/ssl links: - mysql:mysql mysql: image: mysql env_file: .env# ports:# - "3306:3306" volumes: - ./var/lib/mysql:/var/lib/mysql 编写 .env 文件 1MYSQL_ROOT_PASSWORD=mytest HTTPS准备好 ssl 证书，上传到 ./ssl，两个 ssl 文件分别改名（名字与下边 app.prod.ini 文件中的配置名字匹配即可）。 修改 app.prod.ini 文件，修改内容 12345[server]PROTOCOL = httpsROOT_URL = https://git.domain.comCERT_FILE = /data/ssl/git.domain.com.crtKEY_FILE = /data/ssl/git.domain.com.key 使用如下命令启动容器 1$ docker-compose up -d nginx 配置123456789101112131415161718192021222324server &#123; listen 80; server_name git.domain.com; return 301 https://$server_name$request_uri;&#125;upstream git &#123; server 127.0.0.1:10080;&#125;server &#123; listen 443 ssl http2; server_name git.domain.com; ssl_certificate conf.d/ssl/git.domain.com.crt; ssl_certificate_key conf.d/ssl/git.domain.com.key; ssl_session_cache shared:SSL:1m; ssl_session_timeout 5m; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / &#123; proxy_pass https://git; &#125;&#125; 访问网页，开始安装。 升级12345$ docker pull gogs/gogs$ docker-compose down$ docker-compose up -d 相关链接 https://github.com/gogits/docs/blob/master/zh-CN/intro/faqs.md http://blog.hypriot.com/post/run-your-own-github-like-service-with-docker/]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Gogs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker 安装 Gitlab]]></title>
    <url>%2Fgit%2Fgitlab.html</url>
    <content type="text"><![CDATA[使用 Docker Compose 搭建 GitLab。 GitHub：https://github.com/khs1994-docker/gitlab docker-compose.yml123456789101112version: '3'services: gitlab: restart: always image: gitlab/gitlab-ce ports: - "22:22" - "443:443" volumes: - ./config/gitlab:/etc/gitlab - ./logs:/var/log/gitlab - ./data:/var/opt/gitlab ssl在 ./config/nginx/ ./config/gitlab/ 中分别新建 ssl 文件夹，并放入证书文件。 git.domain.com.crt git.domain.com.key nginx在 ./config/nginx/ 新建 gitlab.conf，并写入以下内容。 123456789101112131415161718server &#123; listen 80; server_name git.domain.com; return 301 https://git.domain.com;&#125;server &#123; listen 443 ssl http2; server_name git.domain.com; ssl_certificate conf.d/ssl/git.domain.com.crt; ssl_certificate_key conf.d/ssl/git.domain.com.key; location / &#123; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass https://gitlab:443; &#125;&#125; 使用以下命令启动 1$ docker-compose up -d GitLab 配置修改 ./config/gitlab/gitlab.rb 12# note the 'https' belowexternal_url "https://git.domain.com" 使用以下命令重新启动 1$ docker-compose restart 访问网页，设置密码。默认用户名为 root。 参考链接 官方文档]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Gitlab</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux 安装 Docker]]></title>
    <url>%2Fdocker%2FREADME.html</url>
    <content type="text"><![CDATA[本文介绍最新版本的 Docker CE 安装。 本文内容来自我参与维护的 《Docker 从入门到实践》 项目。 CentOS 7配置 REPOInstall yum-utils, which provides the yum-config-manager utility: 123$ sudo yum install -y yum-utils \ device-mapper-persistent-data \ lvm2 12345678910# 官方源# $ sudo yum-config-manager \# --add-repo \# https://download.docker.com/linux/centos/docker-ce.repo# 国内源$ sudo yum-config-manager \ --add-repo \ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 需要启用的版本，包含 Stable Edge Test (即稳定版、最新版、测试版)。 12345$ sudo yum-config-manager --enable docker-ce-edge$ sudo yum-config-manager --enable docker-ce-test$ sudo yum-config-manager --disable docker-ce-edge 安装123456789101112$ sudo yum install docker-ce# 或者安装指定版本# 列出可用版本$ yum list docker-ce --showduplicates | sort -r# 安装指定版本$ sudo yum install docker-ce-&lt;VERSION&gt;# 例如 $ sudo yum install docker-ce-17.06.1.ce Debian12345678910111213141516171819202122232425262728293031323334353637$ sudo apt install \ apt-transport-https \ ca-certificates \ curl \ gnupg2 \ software-properties-common# 官方源# $ curl -fsSL https://download.docker.com/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -## $ sudo add-apt-repository \# "deb [arch=amd64] https://download.docker.com/linux/$(. /etc/os-release; echo "$ID") \# $(lsb_release -cs) \# stable"# 国内源$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/$(. /etc/os-release; echo "$ID")/gpg | sudo apt-key add -$ sudo add-apt-repository \ "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/$(. /etc/os-release; echo "$ID") \ $(lsb_release -cs) \ stable"$ sudo apt-get update$ sudo apt-get install docker-ce# 或者安装指定版本# 查看可供安装版本$ apt-cache madison docker-ce$ sudo apt-get install docker-ce=&lt;VERSION&gt;# 例如 $ sudo apt-get install docker-ce=17.09.0~ce-0~debian Ubuntu123456789101112131415161718192021222324252627282930313233343536$ sudo apt-get install \ apt-transport-https \ ca-certificates \ curl \ software-properties-common# 官方源# $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -# $ sudo add-apt-repository \# "deb [arch=amd64] https://download.docker.com/linux/ubuntu \# $(lsb_release -cs) \# stable"# 国内源$ curl -fsSL https://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -$ sudo add-apt-repository \ "deb [arch=amd64] https://mirrors.aliyun.com/docker-ce/linux/ubuntu \ $(lsb_release -cs) \ stable"$ sudo apt-get update$ sudo apt-get install docker-ce# 或者安装指定版本# 查看可供安装版本$ apt-cache madison docker-ce$ sudo apt-get install docker-ce=&lt;VERSION&gt;# 例如 $ sudo apt-get install docker-ce=17.09.0~ce-0~ubuntu Linux 安装之后配置1234567891011$ sudo systemctl enable docker.service$ sudo systemctl start docker$ sudo groupadd docker$ sudo usermod -aG docker $USER# 重新登录用户，有图形界面的 Linux，重新登录之后下面命令执行失败的，请重启电脑。$ docker run --rm hello-world 国内镜像加速/etc/docker/daemon.json 1234567891011&#123; "registry-mirrors": [ "https://registry.docker-cn.com" ], "debug": true, "dns": [ "114.114.114.114", "8.8.8.8" ], "experimental": true&#125; 卸载RedHat 系 1$ sudo yum remove docker-ce Debian 系 1$ sudo apt-get purge docker-ce 1$ sudo rm -rf /var/lib/docker 工具Compose 一次运行多个容器 Registry v2 私有仓库 Machine Docker Machine 的产生简化了这一过程，让你可以使用一条命令在你的计算机、公有云平台以及私有数据中心创建及管理 Docker 主机。 相关链接 https://github.com/docker https://github.com/moby https://mobyproject.org https://github.com/linuxkit https://docs.docker.com/engine/installation/linux/docker-ce/centos/ https://yq.aliyun.com/articles/110806]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vim 常用设置]]></title>
    <url>%2Ftools%2Fvim.html</url>
    <content type="text"><![CDATA[配置文件位于 ~/.vimrc。 配色一般不用设置 12colorscheme desertsyntax on 中文乱码设置环境变量 12$ export LANG=en_US.UTF-8$ export LC_ALL=en_US.UTF-8]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Atom 配置插件记录]]></title>
    <url>%2Ftools%2Fatom.html</url>
    <content type="text"><![CDATA[Find and run available commands using cmd-shift-p (macOS) or ctrl-shift-p (Linux/Windows) in Atom. 插件加速~/.atom/.apmrc 1registry = https://registry.npm.taobao.org 命令行方式安装 apm - Atom Package Manager powered by https://atom.io 1apm install sync-settings 插件列表sync-settings 备份插件、配置 gitst: 80a9978333b86f4a6deb5cb2ddca56ad https://gist.github.com/khs1994/80a9978333b86f4a6deb5cb2ddca56ad 按下全局命令搜索面板Ctrl+shift+p搜索sync ,会有可选项: sync-settings:backup – 备份当前的配置 sync-settings:restore – 恢复配置 sync-settings:view-backup – 查询备份 sync-settings:check-backup – 查询最后一次是否正常 Other file-icons recent-projects language-docker language-nginx platformio-ide-terminal 相关链接 http://blog.csdn.net/crper/article/details/47291063 插件列表]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Atom</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 复制(主从)]]></title>
    <url>%2Fcache%2Fredis%2Freplication.html</url>
    <content type="text"><![CDATA[https://redis.io/topics/replication http://www.redis.cn/topics/replication.html 5.0.0 + 请将 slave 替换为 replica 主节点不用修改，从节点选择以下三种方法进行配置。 123456789101112131415# 1.修改配置文件slaveof master-ip master-port# replicaof master-ip master-port# 2.不修改配置文件，直接在启动时加上参数也可以$ redis-server --port 6380 --slaveof 127.0.0.1 6379# $ redis-server --port 6380 --replicaof 127.0.0.1 6379# 3. redis-cli 中修改redis&gt; SLAVEOF 127.0.0.1 6379 # REPLICAOFredis&gt; SLAVEOF NO ONE # 使当前数据库停止接收其他数据库的同步，转成主数据库]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 其他操作]]></title>
    <url>%2Fcache%2Fredis%2Fother.html</url>
    <content type="text"><![CDATA[Redis 其他操作介绍。 地理位置信息 GEO geoadd KEY long lat ‘member’ long lat ‘member2’ geopos KEY ‘member’ ‘member2’ # 返回 KEY 中指定成员的经纬度 geodist KEY ‘member’ ‘member2’ [ m | km | mi |ft ] # 计算距离 georadius KEY long lat radius [单位] # 以给定的经纬度为中心， 返回键包含的位置元素当中， 与中心的距离不超过给定最大距离的所有位置元素。 georadiusbymember 中心位置为成员 geohash KEY ‘member’ ‘member2’ # 返回一个或多个位置元素的 Geohash 表示。 发布订阅事务]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcached 安装配置]]></title>
    <url>%2Fcache%2Fmemcached%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：http://memcached.org/ 安装下载，解压，进入文件夹 1234567$ sudo apt install libsasl2-dev libevent-dev$ ./configure --prefix=/usr/local/memcached --enable-sasl$ make$ make install 服务端启动1$ memcached -d -l 127.0.0.1 -p 11211 -m 1024 -u root 客户端安装安装 libmemcached使用包管理工具安装Debian 系 1$ apt install libmemcached-dev RedHat 系 1$ yum install libmemcached-devel 编译安装官方网站：http://libmemcached.org/libMemcached.html 12345$ ./configure --prefix=/usr/local/libmemcached$ make$ make install 各种语言的扩展这里不再列举。]]></content>
      <categories>
        <category>Cache</category>
        <category>Memcached</category>
      </categories>
      <tags>
        <tag>Memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 配置文件详解]]></title>
    <url>%2Fcache%2Fredis%2Fconfig.html</url>
    <content type="text"><![CDATA[https://redis.io/topics/config http://www.redis.cn/topics/config.html]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Memcached 使用详解]]></title>
    <url>%2Fcache%2Fmemcached%2Fquickstart.html</url>
    <content type="text"><![CDATA[以 PHP 为例使用 Memcached。 系统类1234567891011121314$m=new Memcached();$m-&gt;addServer('memcached',11211);// 多台服务器$m-&gt;addServers([ ['127.0.0.1',11211], ['127.0.0.2',11211]]);$m-&gt;getVersion(); // array$m-&gt;getStats(); // array 数据操作12345678910111213141516// 600 为过期时间$m-&gt;add('key','value',600); // 若对 key 再次执行 add 一个新值 value2 不能改变原值。$m-&gt;replace('key','value',600); // 替换$m-&gt;set('key','value',600); // set会替换原值，注意与 add 的区别$m-&gt;append(); // 追加键值对$m-&gt;prepend(); // 向已存在 key(键) 的 value(数据值) 前面追加数据$m-&gt;get('key');$m-&gt;delete('key'); cas用于执行一个”检查并设置”的操作。它仅在当前客户端最后一次取值后，该 key 对应的值没有被其他客户端修改的情况下， 才能够将值写入 1$m-&gt;cas() 清空$m-&gt;flush(); 增减$m-&gt;increment(&#39;num&#39;,5); $m-&gt;decrement(&#39;num&#39;,5); 一次操作多条数据12345678910$array=[ 'key'=&gt;'value', 'key2'=&gt;'value2']$m-&gt;setMulti($array,0);$m-&gt;getMulti(['key1','key2']);$m-&gt;deleteMulti(['key1','key2']); 错误处理1234567// 上次操作的返回值$m-&gt;getResultCode()// 上次操作的返回信息$m-&gt;getResultMessage()]]></content>
      <categories>
        <category>Cache</category>
        <category>Memcached</category>
      </categories>
      <tags>
        <tag>Memcached</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 持久化 persistence]]></title>
    <url>%2Fcache%2Fredis%2Fpersistence.html</url>
    <content type="text"><![CDATA[本文介绍 Redis 持久化。 https://redis.io/topics/persistence http://www.redis.cn/topics/persistence.html 对比 文件体积 RDB 小，单一文件 安全性 AOF 安全性高，最多丢 1s 数据 恢复速度 RDB 快 RDB 快照 (Redis DataBase)该方式为默认方式。 RDB 方式的持久化是通过快照（snapshotting）完成的，当符合一定条件时 Redis 会自动将内存中的 所有 数据进行快照并存储在硬盘上。进行快照的条件可以由用户在配置文件中自定义，由两个参数构成：时间 和 改动的键的个数。当在指定的时间内被更改的键的个数大于指定的数值时就会进行快照。配置文件中已经预置了3个条件： 12345save 900 1 # 900秒内有至少1个键被更改则进行快照save 300 10 # 300秒内有至少10个键被更改则进行快照save 60 10000 # 60秒内有至少10000个键被更改则进行快照save "" # 禁用该功能 可以存在多个条件，条件之间是「或」的关系，只要满足其中一个条件，就会进行快照。如果想要禁用自动快照，只需要将所有的 save 参数删除即可。 Redis 默认会将快照文件存储在当前目录（可以自定义，在客户端使用 CONFIG GET dir 查看）的 dump.rdb 文件（可以自定义，在客户端使用 CONFIG GET dbfilename 查看）中。 配置 dir 和 dbfilename 两个参数可以分别指定快照文件的存储路径和文件名。 父进程在保存 RDB 文件时唯一要做的就是 fork 出一个子进程，然后这个子进程就会处理接下来的所有保存工作，父进程无须执行任何磁盘 I/O 操作 也可以手动执行 SAVE 命令 1redis 127.0.0.1:6379&gt; SAVE # 该命令将在 redis 备份目录中创建dump.rdb文件。 12345$cat dump.rdbREDIS0008 redis-ver4.0.1redis-bits@ctimeYused-mem aof-preamblerepl-id(484f9d49a700c4b9b136f0fd40d2d6e5a8460438 repl-offa;^foobarfoobar^KJ_U AOF 日志 (Append-only file)append only file 将 操作 + 数据 以格式化指令的方式追加到操作日志文件的尾部 12345678910111213appendonly yesappendfilename appendonly.aof# 当目前的 AOF 文件大小超过上一次重写时的 AOF 文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时的 AOF 文件大小为依据auto-aof-rewrite-percentage 100auto-aof-rewrite-min-size 64mb # 允许重写的最小AOF文件大小# appendfsync always # 每次执行写入都会执行同步，最安全也最慢appendfsync everysec # 每秒执行一次同步操作# appendfsync no # 不主动进行同步操作，而是完全交由操作系统来做（即每30秒一次），最快也最不安全 Redis 允许同时开启 AOF 和 RDB。 12345678910$cat appendonly.aof*2$6SELECT$10*3$3set$3 混合 RDB-AOF 持久化格式 4.0+先以 RDB 格式写入全量数据再追加增量日志 https://yq.aliyun.com/articles/193034 1aof-use-rdb-preamble yes 12345678910111213141516$cat appendonly.aofREDIS0008 redis-ver4.0.1redis-bits@ctimeYused-memP aof-preamblerepl-id(484f9d49a700c4b9b136f0fd40d2d6e5a8460438 repl-offsetfoobar?I Y*2$6SELECT$10*3$3set$3foo$3bar 前半段是 RDB 格式的全量数据后半段是 redis 命令格式的增量数据。 恢复如果需要恢复数据，只需将备份文件 dump.rdb 或 appendonly.aof 移动到启动配置文件中设置的 dir 目录并启动服务即可。 注意： 当配置文件启用 appendonly 时，redis 默认寻找 appendonly.aof 恢复数据，如果没有 aof 文件，则 redis 数据为空。 当需要使用 rdb 文件恢复数据时，启动配置文件需注释掉 #appendonly yes 参数（或者将参数值改为 no）。]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis string 类型]]></title>
    <url>%2Fcache%2Fredis%2Fstring.html</url>
    <content type="text"><![CDATA[可以是字符串、整数或浮点，统称为元素。对字符串操作，对整数类型加减。 append KEY value # 将 值追加到原值末尾 mset[nx] KEY1 value1 KEY2 value2 # 一次设置多个键的值 mget KEY1 KEY2 # 一次返回多个键的值 getset KEY NEW_VALUE # 设置新值，返回旧值 incr | decr KEY # 自增(减) 1 incrby | decrby KEY 20 # 自定义增量 incrbyfloat KEY 0.01 getrange KEY start end # 截取指定位置的字符串 -1 表示最后一个字符。 setrange KEY offset value # 从指定位置重写值 psetex KEY 1000 “Hello” # 单位 毫秒 setex KEY 60 “value” # 单位 秒 strlen KEY # 字符串长度]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis sorted set 有序集合类型]]></title>
    <url>%2Fcache%2Fredis%2Fsorted-set.html</url>
    <content type="text"><![CDATA[集合插入，按照分数范围超找，可以想象为学生成绩表 zadd zset1 10.1 value zcard zset1 zcount zset1 min max # 返回有序集 key 中， score 值在 min 和 max 之间(默认包括 score 值等于 min 或 max )的成员的数量 zincrby set1 key increment member zrange zset1 0 2 withscores # 返回有序集 key 中，指定区间内的成员 zrank zset1 val2 # 返回有序集 key 中成员 member 的排名 zrem zset member]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis set 类型]]></title>
    <url>%2Fcache%2Fredis%2Fset.html</url>
    <content type="text"><![CDATA[从集合 (set) 中插入或者删除元素，set 中不能有重复值 1sadd set1 12 13 14 srem set1 12 13 # 移除 scard set1 # 集合元素数量 sismember set1 13 # 判断 member 元素是否是集合 key 的成员 smembers set1 # 返回集合 key 中的所有成员 sdiff set1 set2 sdiffstore newset set1 set2 # 将比较结果放入新的集合 sinter set1 set2 # 交集 sinterstore newset set1 set2 # 将交集存入新的集合 sunion set1 set2 # 并集 sunionstore newset set2 set3 smove SRC_SET TARGET_SET “string” spop set1 # 移除并返回集合中的一个随机元素 srandmember set1 # 返回集合中的一个随机元素]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis list 类型]]></title>
    <url>%2Fcache%2Fredis%2Flist.html</url>
    <content type="text"><![CDATA[序列（list）两端推入、或弹出元素，修剪、查找、移除元素。 lpush list1 1 2 3 rpop list1 llen list1 lindex key index # 返回列表中下表为 index 的元素 lset key index value linsert key berore | after pivot value # 将值 value 插入到列表 key 当中，位于值 pivot 之前或之后。 lrange key start end # 返回列表 key 中指定区间内的元素，区间以偏移量 start 和 stop 指定 lrem key count value # 根据参数 count 的值，移除列表中与参数 value 相等的元素 ltrim key start end # 让列表只保留指定区间内的元素，不在指定区间之内的元素都将被删除]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis key 操作详解]]></title>
    <url>%2Fcache%2Fredis%2Fkey.html</url>
    <content type="text"><![CDATA[http://redisdoc.com/ http://redis.io/documentation 切换数据库 1SELECT 1 # redis 默认使用数据库 `0` 基本命令 set KEY VALUE del KEY KEY2 exists KEY expire KEY 30 # 单位为秒 pexpire KEY 1500 # 单位为毫秒 ttl key # 查看剩余生存时间 pttl KEY # 查看剩余生存时间，单位毫秒 persist KEY # 去掉生存时间，不删除 key expireat KEY 1355292000 # unix 时间戳 pexpireat KEY # 毫秒时间戳 keys * # 匹配数据库中所有 key migrate 127.0.0.1 6380 KEY DB_NAME TARGET_DB_NAME # 将 key 原子性地从当前实例传送到目标实例的指定数据库上，一旦传送成功， key 保证会出现在目标实例上，而当前实例上的 key 会被删除。 move KEY TARGET_DB_NAME # 将当前数据库的 key 移动到给定的数据库 db 当中 randomkey # 随机返回一个key rename KEY NEW_KEY_NAME renamenx # 当且仅当 newkey 不存在时，将 key 改名为 newkey nx =&gt; Not eXists sort keys [DESC] # 默认从小到大 DESC 从大到小 dump restore # 序列化给定的 KEY 数值类型type KEY none string list set zset hash]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis hash 类型]]></title>
    <url>%2Fcache%2Fredis%2Fhash.html</url>
    <content type="text"><![CDATA[1hset[nx] HASH1 KEY value hget HASH1 key1 hgetall HASH1 hmset hash1 key1 12 key2 1 hmget hash1 key1 key2 hdel hash1 key1 key2 hexists hash1 key1 hlen hash1 # 哈希表域中域的数量 hstrlen hash1 key # 返回哈希表中域的值的长度 hkeys hash1 # 这个指令只返回域 hvals hash1 # 这个指令只返回域的值 hincrby hash1 key1 10 # 可以为负数 hincrbyfloat hash1 key1 0.1 # 浮点增量]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis 使用详解]]></title>
    <url>%2Fcache%2Fredis%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：https://redis.io/ http://redisdoc.com/ https://redis.io/documentation https://redis.io/commands 安装下载，解压，进入文件夹 1234567$ make$ make install$ mkdir -p /usr/local/redis$ cp redis.conf /usr/local/redis/ 启动服务1$ redis-server /usr/local/redis/redis.conf 客户端1$ redis-cli 各编程语言客户端 https://redis.io/clients 关闭服务1$ redis-cli shutdown systemd/etc/systemd/system/redis.service 123456789101112131415[Unit] Description=Redis After=syslog.target network.target remote-fs.target nss-lookup.target [Service] Type=forking PIDFile=/var/run/redis.pid# 注意替换为你自己的实际路径ExecStart=/REDIS_PATH/redis-3.2.0/src/redis-server /usr/local/redis/redis.confExecReload=/bin/kill -s HUP $MAINPID ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true [Install] WantedBy=multi-user.target 相关链接 http://blog.csdn.net/nimasike/article/details/52471992]]></content>
      <categories>
        <category>Cache</category>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 配置文件详解]]></title>
    <url>%2Fdatabase%2Fmongodb%2Fconfig.html</url>
    <content type="text"></content>
      <categories>
        <category>DataBase</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 基本操作]]></title>
    <url>%2Fdatabase%2Fmongodb%2Fquickstart.html</url>
    <content type="text"><![CDATA[切换数据库use test 无需新建数据库，切换时若不存在则自动新建数据库。 查看数据库1$ show dbs 插入数据db.表名.方法 不指明 id 则自动插入 id db.test_collection.insert({x:1}) db.test_collection.insert({x:3,_id:1}) 查看表名show collections 查看表数据db.test_collection.find() db.test_collection.find().count() db.test_collection.find().skip(3).limit(2).sort({x:1}) 一次插入多条数据for(i=10;i&lt;100;i++)db.test_collection.insert({x:i}) 数据更新db.test_collection.update({x:1},{x:999}) 更新部分数据db.test_collection.insert({x:1,y:2,z:3}) db.test_collection.update({z:100},{$set:{y:99}}) 更新不存在数据db.test_collection.update({x:999},{x:1099},true) 更新多条数据db.test_collection.update({c:1},{$set:{c:2}},false,true) 数据删除db.test_collection.remove({c:2}) 删除表db.test_collection.drop() show tables 索引]]></content>
      <categories>
        <category>DataBase</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MongoDB 安装配置]]></title>
    <url>%2Fdatabase%2Fmongodb%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：https://www.mongodb.com/ MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。 配置文件1234567891011systemLog: destination: file path: /var/log/mongodb/mongo.log logAppend: truestorage: dbPath: /var/lib/mongodbprocessManagement: fork: truenet: bindIp: 127.0.0.1 port: 27017 启动12345$ mongod --config /usr/local/etc/mongod.conf# 客户端连接$ mongo 127.0.0.1:端口/数据库 关闭12use admindb.shutdownServer()]]></content>
      <categories>
        <category>DataBase</category>
        <category>MongoDB</category>
      </categories>
      <tags>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WordPress 使用详解]]></title>
    <url>%2Fcms%2Fwordpress%2FREADME.html</url>
    <content type="text"><![CDATA[安装 PHP MySQL 。 FTP错误在 WordPress 目录下找到 wp-config.php 文件，在最后一行加上 define(&#39;FS_METHOD&#39;, &quot;direct&quot;);]]></content>
      <categories>
        <category>CMS</category>
        <category>WordPress</category>
      </categories>
      <tags>
        <tag>WordPress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typecho 使用详解]]></title>
    <url>%2Fcms%2Ftypecho%2FREADME.html</url>
    <content type="text"><![CDATA[Typecho 是一款类似于 WordPress 的基于 PHP 的站点搭建工具。 nginx 配置12345678910111213141516server &#123; listen 80; server_name yourdomain.com; root /home/yourdomain/www/; index index.html index.htm index.php; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php$1 last; &#125; location ~ .*\.php(\/.*)*$ &#123; fastcgi_pass 127.0.0.1:9000; include fastcgi.conf; &#125;&#125; 相关链接 http://docs.typecho.org/faq]]></content>
      <categories>
        <category>CMS</category>
        <category>Typecho</category>
      </categories>
      <tags>
        <tag>Typecho</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo 使用详解]]></title>
    <url>%2Fcms%2Fhexo%2FREADME.html</url>
    <content type="text"><![CDATA[将 Hexo 博客系统所需知识大概说明一下。 Github注册 Github 账号，并新建 用户名.github.io 仓库。 Git安装 Git生成 SSH 公钥、密钥将 公钥 复制到 GitHub Node.js换源安装1$ npm install -g hexo-cli 初始化1234$ mkdir hexo$ hexo init &lt;folder&gt;$ cd &lt;folder&gt;$ npm install 配置git1$ npm install hexo-deployer-git --save 123deploy: type: git repo: git@github.com:khs1994/khs1994.github.io.git 你可能会配置多个仓库 12345deploy: type: git repo: aliyun: git@code.aliyun.com:khs1994/www.khs1994.git,master github: git@github.com:khs1994/khs1994.github.io.git,master 日常操作生成静态文件1$ hexo g hexo server12$ npm install hexo-server --save$ hexo server -p 8080 #-p 指定端口 发布到 GitHub12$ hexo g$ hexo d]]></content>
      <categories>
        <category>CMS</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C Linux 下的编译]]></title>
    <url>%2Fother%2Fc%2FREADME.html</url>
    <content type="text"><![CDATA[本文简要介绍了 C 语言的编译命令。 Hello World!1234567#include &lt;stdio.h&gt;int main()&#123; printf("Hello World!\n"); return 0;&#125; 基本编译命令123$ gcc a.c# 生成 a.out$ ./a.out 多个文件分而治之12//声明# include “max.c” 1234# 不声明,会发生警告信息$ gcc max.c hello.c -o main.out# 声明$ gcc hello.c 头文件与函数定义分离不经常变动的函数 生成静态库 12345$ gcc -c max.c -o max.o# hello.c 声明去掉$ gcc max.o hello.c# 可以将文件写为 头文件$ gcc max.o min.o hello.c Makefile1234567# 注释hello.out:max.o min.o hello.c gcc max.o min.o hello.c -o hello.outmax.o:max.c gcc -c max.cmin.o:min.c gcc -c min.c 指针与内存gdb 工具12$ gcc -g main.c -o main.out$ gdb ./main.out]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓依赖服务器 Nexus]]></title>
    <url>%2Fother%2Fandroid%2Fnexus.html</url>
    <content type="text"><![CDATA[Nexus 是一个基于 maven 的仓库管理的社区项目。主要的使用场景就是可以在局域网搭建一个 maven 私服，用来部署第三方公共构件或者作为远程仓库在该局域网的一个代理。 通过 Docker 启动12345$ docker run -d \ --name nexus \ -p 8081:8081 \ -v nexus-data:/nexus-data \ sonatype/nexus3 Android Studio 配置项目 buid.gradleallprojects { repositories { jcenter() // mavenLocal() } }appallprojects { repositories { maven { url &quot;https://nexus.khs1994.com/repository/com.khs1994.khs1994lib/&quot; } } }libuploadArchives { repositories.mavenDeployer() { repository(url:&quot;https://nexus.khs1994.com/repository/com.khs1994.khs1994lib/&quot;){ authentication(userName:&quot;khs1994&quot;, password:&quot;khs19941218&quot;) } pom.version=&quot;0.0.1&quot; pom.artifactId=&quot;khs1994lib&quot; pom.groupId=&quot;com.khs1994&quot; } }相关链接 官方网站 nexus Docker http://blog.csdn.net/l2show/article/details/48653949]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio Linux 安装错误的解决方法]]></title>
    <url>%2Fother%2Fandroid%2Fandroid-studio-linux32.html</url>
    <content type="text"><![CDATA[Android Studio 在 Linux 64 位安装 SDK 会提示错误。 This is important If you have 64-bitsystems, you will need to install some 32bit packages, because Android SDK is 32bit. Fedora123$ dnf install glibc.i686 glibc-devel.i686 \ libstdc++.i686 zlib-devel.i686 ncurses-devel.i686 \ libX11-devel.i686 libXrender.i686 libXrandr.i686 Ubuntu1$ sudo apt-get install libc6:i386 libncurses5:i386 libstdc++6:i386 lib32z1 相关链接 https://fedoraproject.org/wiki/HOWTO_Setup_Android_Development#Install_Android_SDK http://tools.android.com/tech-docs/linux-32-bit-libraries http://stackoverflow.com/questions/29112107/how-to-solve-unable-to-run-mksdcard-sdk-tool-when-installing-android-studio-on]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Golang 简单使用]]></title>
    <url>%2Fgolang%2FREADME.html</url>
    <content type="text"><![CDATA[官方网站：https://golang.org/ GitHub：https://github.com/golang 变量 $GOROOT go 安装路径 $GOPATH 路径列表，可以同时指定多个目录 用于指定除 $GOROOT 之外的包含 Go 项目源代码和二进制文件的目录。$ go install 和 go 工具会用到。 $GOPATH 作为编译后二进制的存放目的地和 import 包时的搜索路径。 $GOBIN $ go install 编译存放路径，不允许设置多个路径。 $GOOS $GOARCH 使用 $ go env 查看 go 相关环境变量。 目录结构src pkg bin 命令go installgo getgo build]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP 7.0 新特性]]></title>
    <url>%2Fphp%2Frelease%2F7.0%2FREADME.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/php/php-src/releases/tag/php-7.0.0 官方文档：http://cn2.php.net/manual/zh/migration70.php 部分列出 类型申明函数参数、返回值 string int float bool + 类名 接口 数组 回调类型 null 合并运算符 ??如果变量存在且值不为 NULL， 它就会返回自身的值，否则返回它的第二个操作数。 123$a = $_GET['user'] ?? 'default';$a = isset($_GET['user']) ? $_GET['user'] : 'nobody'; 太空船操作符当 $a 小于、等于或大于 $b 时它分别返回 -1、0 或 1 123echo 1 &lt;=&gt; 1; // 0echo 1 &lt;=&gt; 2; // -1echo 2 &lt;=&gt; 1; // 1 define 可定义常量数组use 分组12345use some\namespace\&#123; ClassA, ClassB, ClassC as C &#125;; 匿名类]]></content>
      <categories>
        <category>PHP</category>
        <category>Release</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ 简介]]></title>
    <url>%2Fphp%2Frabbitmq%2FREADME.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>PHP</category>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP SPL 库简介]]></title>
    <url>%2Fphp%2Fspl%2FREADME.html</url>
    <content type="text"><![CDATA[SPL 是 标准 PHP 库，用于解决典型问题的一组接口与类的集合。 数学建模、数据结构 数据怎么存储的问题 元素遍历 数据怎么查看的问题 通用方法（数组、集合大小） 自定义遍历 自动加载各种形式 回调函数、静态加载类 123456789spl_autoload_register("Test::autoload");spl_autoload_register(['Test','autoload']);spl_autoload_register(function($class)&#123;&#125;);spl_autoload_register('function_name');spl_autoload_register( [$autoload_function, $throw, $prepend]);]]></content>
      <categories>
        <category>PHP</category>
        <category>SPL</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>SPL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP GD 库简介]]></title>
    <url>%2Fphp%2Fbasic%2Fgd%2FREADME.html</url>
    <content type="text"><![CDATA[]]></content>
      <categories>
        <category>PHP</category>
        <category>GD</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>GD</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL 配置文件详解]]></title>
    <url>%2Fdatabase%2Fpostgresql%2Fconfig.html</url>
    <content type="text"></content>
      <categories>
        <category>DataBase</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PostgreSQL 基本用法]]></title>
    <url>%2Fdatabase%2Fpostgresql%2FREADME.html</url>
    <content type="text"></content>
      <categories>
        <category>DataBase</category>
        <category>PostgreSQL</category>
      </categories>
      <tags>
        <tag>PostgreSQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 存储引擎]]></title>
    <url>%2Fdatabase%2Fmysql%2Fengine.html</url>
    <content type="text"><![CDATA[存储引擎包括 InnoDB MyISAM Memory CSV Archive 对比设置默认存储引擎1default-storage-engine = InnoDB | MYISAM]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 导出数据 mysqldump 命令]]></title>
    <url>%2Fdatabase%2Fmysql%2Fmysqldump.html</url>
    <content type="text"><![CDATA[mysqldump 命令用于导出数据库。 123456789101112# 导出某数据库 只能是一个数据库，后边参数表示这个数据的表名# 导出多个数据库请使用下一条命令# 导出某数据库中的某表mysqldump [OPTIONS] database [tables] &gt; file.name# 导出指定数据库mysqldump [OPTIONS] --databases [OPTIONS] DB1 [DB2 DB3...]# 导出全部数据库mysqldump [OPTIONS] --all-databases [OPTIONS]]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 配置文件详解]]></title>
    <url>%2Fdatabase%2Fmysql%2Fconfig.html</url>
    <content type="text"><![CDATA[MySQL 配置文件详解。 GitHub：https://github.com/khs1994-docker/lnmp/blob/master/config/mysql/docker.cnf 官方文档: https://dev.mysql.com/doc/refman/8.0/en/mysqld-option-tables.html shell 变量 https://dev.mysql.com/doc/refman/8.0/en/environment-variables.html 配置文件加载顺序123$ mysql --verbose --help# 在输出结果中查看 错误设置123456789［client］default-character-set=utf8mb4［mysqld］# 5.5 之后不能在此处设置该选项# default-character-set=utf8mb4# 正确character-set-server=utf8mb4 字符集服务器级、数据库级、表级、列级和连接级。 https://www.2cto.com/database/201302/189920.html]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 连接 JOIN]]></title>
    <url>%2Fdatabase%2Fmysql%2Fjoin.html</url>
    <content type="text"><![CDATA[从多个表中读取数据，在 SELECT UPDATE DELETE 语句中使用 JOIN。 INNER JOIN 内连接（等值连接）获取两个表中字段匹配关系的记录 LEFT JOIN 左连接 获取左表所有记录，即使右表没有对应的匹配记录 RIGHT JOIN 右连接 与上边的相反 示例表1234567891011121314151617181920212223DROP TABLE tb1,tb2;CREATE TABLE `tb1`( `id` INT AUTO_INCREMENT , `title` VARCHAR(100) NOT NULL, `author` VARCHAR(100) NOT NULL, `data` DATE DEFAULT NULL, key (`id`));INSERT tb1 VALUES(null,'学习 MySQL','001','2018-01-01'), (null,'学习 PHP','001','2018-01-02'), (null,'学习 Java','002','2018-01-02'), (null,'学习 HTML','003','2018-01-03');CREATE TABLE `tb2`( `author` VARCHAR(100) NOT NULL, `num_count` INT NOT NULL);INSERT tb2 VALUES('001',20), ('002',21), ('003',22); 详解12345SELECT tb1.id,tb1.author,tb2.num_count FROM tb1 AS a INNER JOIN tb2 AS b ON a.author=b.author;SELECT tb1.id,tb1.author,tb2.num_count FROM tb1 a LEFT JOIN tb2 b ON a.author=b.author;SELECT tb1.id,tb1.author,tb2.num_count FROM tb1 a RIGHT JOIN tb2 b ON a.author=b.author; DELETE12345DELETE A FROM YSHA A LEFT JOIN YSHB B ON A.code=b.code WHERE b.code is NULLDELETE FROM YSHA WHERE NOT EXISTS(SELECT 1 FROM YSHB B WHERE YSHA.code=b.code)# 将 B 表中未使用的 A 表编号删除]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 查找数据 SELECT]]></title>
    <url>%2Fdatabase%2Fmysql%2Fselect.html</url>
    <content type="text"><![CDATA[1SELECT 字段1 AS 别名,tbl_name.字段2 FROM 表名 WHERE 条件 LIMIT N OFFSET 偏移量; WHERE IN NOT IN LIMIT OFFSET ORDER BY GROUP BY FETCH NEXT n IS NULL IS NOT NULL LIKE 1234567# 从第 2 条（0 为第一条）开始读（即，跳过第一条数据），返回 5 条数据SELECT * FROM tbl_name LIMIT 1,5;# 从第 2 条开始读（即，跳过前 1 条数据 ）SELECT * FROM tbl_name LIMIT 1 OFFSET 1; 条件12345SELECT 字段 FROM 表名 WHERE 条件;# LIKESELECT 字段 FROM 表名 WHERE LIKE '%COM' % 是通配符 去重1SELECT DISTINCT cl_name FROM tb_name; 排序1SELECT 字段 FROM 表名 ORDER BY 字段 [ ASC | DESC ]; ASC 升序 分组1234567SELECT 字段 FROM 表名 GROUP BY 字段;SELECT 字段 FROM 表名 GROUP BY 字段 WITH ROLLUP;# 分组条件 对符合数据的进行分组SELECT 字段 FROM 表名 GROUP BY 字段 HAVING 字段 &gt; 5; UNION用于连接两个以上的 SELECT 语句的结果组合到一个结果集合中，多个 SELECT 语句会删除重复的数据。 1mysql&gt; SELECT col_name,col_name2 FROM tb1 UNION [ ALL | DISTINCT ] SELECT col_name,col_name3 FROM tb2; SELECT 后边字段数量要一致。结果的列名为第一个 SELECT 的列名。 子查询1234567mysql&gt; SELECT * FROM tbl_name WHERE col = ANY (SELECT col2 FROM tbl_name2);# 子查询返回多条结果，必须使用以下关键字 ANY SOME ALL# [NOT] IN (subquery)mysql&gt; INSERT INTO tbl_name(col) SELECT col FROM tbl_name2; 多表更新12345mysql&gt; UPDATE tbl_references SET col=&#123;expr&#125;# UPDATE tbl_name AS tbl1 INNER JOIN tbl_name2 AS tbl2 ON col=col SET tbl1.col = tbl2.col;mysql&gt; CREATE tbl_name() SELECT * FROM tbl_name2;]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 索引 INDEX]]></title>
    <url>%2Fdatabase%2Fmysql%2Fmysql-index.html</url>
    <content type="text"><![CDATA[12[ UNIQUE | FULLTEXT | SPATIAL ] [ INDEX | KEY ][ 别名 ] ( col_name [(索引长度，仅字符串类型)] [ ASC | DESC ] ); 单列索引 即一个索引只包含单个列。 KEY [ index_name ] (col_name) 组合/复合 索引 即一个索引包含多个列。INDEX index_name (col_name1,col_name2) 普通索引 主键 primary key 唯一索引 unique INDEX index_name (col_name1,col_name2) 空间索引 (仅 MyISAM 引擎支持) 全文索引 fulltext KEY (仅 MyISAM 引擎支持) (只能创建在 CHAR、VARCHAR 或 TEXT 类型的字段上) MySQL 只对以下操作符才使用索引：&lt; &lt;= = &gt; &gt;= between in 以及某些时候的 like (不以通配符 % 或 _ 开头的情形，%a 不可以，a% 可以) 索引不会包含有 null 值的列 不要在列上进行运算 1SELECT * FROM table_name WHERE YEAR(column_name)&lt;2017; 原则 最左前缀 可以考虑使用索引的主要有两种类型的列：在 where 子句中出现的列，在 join 子句中出现的列 考虑列中值的分布，索引的列的基数越大，索引的效果越好 使用短索引，如果对字符串列进行索引，应该指定一个前缀长度，可节省大量索引空间，提升查询速度 不要过度索引 123456789SHOW INDEX FROM tbl_name;CREATE INDEX index_name ON tbl_name(col_name(长度));# 修改表结构 添加索引ALTER TABLE tbl_name ADD INDEX index_name(col_name);DROP INDEX index_name ON tbl_name; explain123456mysql&gt; explain select * from servers;+----+-------------+---------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key | key_len | ref | rows | Extra |+----+-------------+---------+------+---------------+------+---------+------+------+-------+| 1 | SIMPLE | servers | ALL | NULL | NULL | NULL | NULL | 1 | NULL |+----+-------------+---------+------+---------------+------+---------+------+------+-------+]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 插入/更新 INSERT UPDATE]]></title>
    <url>%2Fdatabase%2Fmysql%2Finsert_update.html</url>
    <content type="text"><![CDATA[1INSERT INTO 表名 VALUES() 1INSERT INTO 表名(字段1,字段2,...) VALUES() 1INSERT INTO 表名 SET 字段名=值; 将查询结果插入表中1INSERT INTO 表名 SELECT 更新1UPDATE tb_name SET 字段名=值 WHERE 条件;]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 函数]]></title>
    <url>%2Fdatabase%2Fmysql%2Ffunction.html</url>
    <content type="text"><![CDATA[函数相关内容。 字符函数字符连接CONCAT(&#39;a&#39;,&#39;b&#39;) 使用指定分隔符进行字符连接CONCAT_WS(&#39;-&#39;,&#39;a&#39;,&#39;b&#39;) 数字格式化FORMAT(1234.56,2) 大小写转化LOWER() UPPER() 获取左侧、右侧 字符LEFT(&#39;MYSQL&#39;,2) RIGHT(&#39;MYSQL&#39;,2) LENGTH() LTRIM() RTRIM() TRIM() 例子，删除前导的字符 TRIM(LEADING &#39;?&#39; FROM &#39;??MYSQL???&#39;) 结果为 MYSQL??? 字符串截取SUBSTRING(&#39;MYSQL&#39;,&#39;1&#39;,&#39;2&#39;) 结果 MY 模式匹配[NOT] LIKE % 任意字符 下划线 _ 任意一个字符 替换REPLACE(&#39;??MYSQL??&#39;,&#39;?&#39;,&#39;&#39;) 数值运算进一取整CEIL() 舍一取整FLOOR() 整数除法DIV 3 DIV 4 结果 0 取余 （取模）MOD 幂运算POWER(3,3) 结果 9 四舍五入ROUND(3.61,2) 数字截取TRUNCATE(125.89,0) 结果 125 比较运算符[NOT] BETWEEN ... AND ... 15 BETWEEN 1 AND 20 [NOT] IN() 10 IN(2,10,20) IS [NOT] NULL 日期时间函数NOW() CURDATE() CURTIME() DATE_ADD(&#39;2014-3-12&#39;,INTERVAL 365 DAY) 相差天数DATEDIFF(&#39;2014-3-12&#39;,&#39;2013-3-12&#39;) 日期格式化DATE_FORMATE(&#39;2014-3-12&#39;,&#39;%m/%d/$Y&#39;) 信息函数CONNECTION_ID() DATABASE() LAST_INSERT_ID() USER() VERSION() 聚合函数 平均数 AVG() COUNT() MAX() MIN() SUM() 加密函数 MD5() PASSWORD()(8.0 已废弃) 自定义函数创建函数1234567CREATE FUNCTION 函数名RETURNS&#123;STRING|INTEGER|REAL|DECIMAL&#125;函数体;# 删除函数DROP FUNCTION fun1; 举例123CREATE FUNCTION f1()RETURNS VARCHAR(30)RETURN DATA_FORMAT(NOW(),'%Y/%m/%d %H:%i:%s') 123CREATE FUNCTION f2(num1 SMALLINT UNSIGNED,num2 SMALLINT UNSIGNED)RETURNS FLOAT(10,2) UNSIGNEDRETURN (num1+num2)/2 函数体若为复合结构，则使用 BEGIAN END 1234567CREATE FUNCTION adduser(username VARCHAR(20))RETURNS INT UNSIGNEDBEGININSERT test() VALUES(username);LATEST_INSERT_ID()END//]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL DROP 指令]]></title>
    <url>%2Fdatabase%2Fmysql%2Fdrop.html</url>
    <content type="text"><![CDATA[DROP 指令可用于删除数据库、数据表等。 1234567DROP TABLE tb1;DROP DATABASE DB1;DROP USER 'username'@'host';DROP INDEX index_name ON tbl_name;]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 删除 DELETE]]></title>
    <url>%2Fdatabase%2Fmysql%2Fdelete.html</url>
    <content type="text"><![CDATA[1DELETE FROM tb_name WHERE 条件;]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL CREATE 指令]]></title>
    <url>%2Fdatabase%2Fmysql%2Fcreate.html</url>
    <content type="text"><![CDATA[CREATE 指令可用于创建数据库、数据表、函数等。 123456789101112131415mysql&gt; CREATE DATABASE [if not exists] db_name CHARACTER set utf8mb4;mysql&gt; USE db_name;mysql&gt; CREATE TABLE `tb1`( `id` INT AUTO_INCREMENT, `pid` INT UNSIGNED COMMENT '注释', `username` VARCHAR(20) UNIQUE NOT NULL, PRIMARY key(`id`), unique index index_name(col_name)) ENGINE=InnoDB auto_increment=100 DEFAULT CHARSET=utf8mb4;# 临时表 断开与数据库的连接后，临时表就会自动被销毁CREATE TEMPORARY TABLE tb1(); 函数请查看其它文章。]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 修改数据表 ALTER]]></title>
    <url>%2Fdatabase%2Fmysql%2Falter.html</url>
    <content type="text"><![CDATA[12345ALTER TABLE tbl_name AUTO_INCREMENT = 100;ALTER TABLE tbl_name ADD [COLUMN] 列名 列定义 位置;ALTER TABLE tbl_name MODIFY col_name 列定义 [ FIRST | AFTER 列名]; 修改列名称 CHANGE1ALTER TABLE tbl_name CHANGE 列名 新列名 列定义 位置; 数据表更名 RENAME123ALTER TABLE tbl_name RENAME [ TO | AS ] 新名称;RENAME TABLE tbl_name TO 新名称; 添加约束1ALTER TABLE tbl_name ADD PRIMARY KEY (列名); 1ALTER TABLE tbl_name ADD UNIQUE (列名); 1ALTER TABLE tbl_name ADD FOREIGN KEY (列名) REFERENCES 父表(列名); 1ALTER TABLE tbl_name ALTER 列名 SET DEFAULT 值; 删除默认约束1ALTER TABLE tbl_name ALTER 列名 DROP DEFAULT; 删除主键1ALTER TABLE tbl_name DROP PRIMARY KEY; 删除唯一约束123SHOW INDEXES FROM tbl_name;ALTER TABLE tbl_name DROP 索引; 删除外键约束123SHOW CREATE TABLE 表名;ALTER TABLE 表名 DROP FOREIGN KEY fk_symbol;]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Docker 配置 MySQL 主从集群]]></title>
    <url>%2Fdatabase%2Fmysql%2Fcluster.html</url>
    <content type="text"><![CDATA[使用 Docker Compose 启动一主两从的 MySQL 集群。 GitHub：https://github.com/khs1994-docker/lnmp/blob/master/docker-cluster.mysql.yml 类型 一主多从 多主一丛 （多源复制） 配置文件内容可以通过命令配置，这里以配置文件举例。 主服务器123[mysqld]log-bin = mysql-binserver-id = 1 从服务器12[mysqld]server-id = 10 关联节点下面了介绍手动执行的步骤，GitHub 中将这一步写入了 shell 脚本文件。 主服务器登录主服务器 12345CREATE USER 'backup'@'%' identified by 'mytest';GRANT REPLICATION SLAVE ON *.* to 'backup'@'%';SHOW master status; 记住 File、Position 的值。我查出来的是 mysql-bin.000004、312 从服务器登录从服务器 1234567change master to master_host='mysql_1',master_user='backup', master_password='mytest',master_log_file='mysql-bin.000004', master_log_pos=312,master_port=3306;start slave;show slave status; 测试在主服务器创建一个数据库 1create database test; 在从服务器查看数据库，发现已经存在了 test（与主服务器同步） 1show databases; More Information http://blog.csdn.net/qq362228416/article/details/48569293 http://blog.csdn.net/he90227/article/details/54140422]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 远程登录配置 （用户管理）]]></title>
    <url>%2Fdatabase%2Fmysql%2Fremote.html</url>
    <content type="text"><![CDATA[开启 MySQL 的远程登录需要一些配置，网上一些教程较陈旧，不适用于新版本。 GitHub：https://github.com/khs1994-docker/lnmp/issues/452 修订记录 2018/04/21 8.0.11+ GRANT 不会自动创建用户，不能修改用户密码 配置文件 my.conf默认的配置文件没有该配置(即默认监听所有 IP)，不排除有人增加了这项配置，所以首先看看这个配置项 1234567[mysqld]# bind-address=127.0.0.1bind-address=0.0.0.0# 或改为你自己的 IP, 0.0.0.0 表示监听全部 IP 远程登录 第一步 创建远程用户 第二步 赋予用户权限 CREATE USER 创建用户123mysql&gt; CREATE USER 'username'@'%','user2'@'%' IDENTIFIED WITH mysql_native_password BY 'password';# mysql&gt; IDENTIFIED WITH [ mysql_native_password | caching_sha2_password | sha256_password ] 无密码用户1mysql&gt; CREATE USER 'username'@'host'; GRANT 赋予用户权限授权时若用户不存在会新建用户（不适用于 8.0.11+，必须先创建用户，后授权 ） 以下语句中的 priv_type 必须替换为具体的权限名字。后边有详细介绍 123456789# mysql&gt; GRANT privileges ON databasename.tablename TO 'username'@'host' identified by 'password' WITH GRANT OPTION;mysql&gt; GRANT priv_type ON db_name.tbl_name TO 'username'@'host' WITH GRANT OPTION;mysql&gt; GRANT ALL ON *.* TO 'myuser'@'%' WITH GRANT OPTION;mysql&gt; GRANT ALL ON *.* TO 'myuser'@'192.168.1.3' WITH GRANT OPTION;mysql&gt; GRANT ALL ON dbname.tbname TO 'myuser'@'192.168.1.%' WITH GRANT OPTION; 1WITH GRANT OPTION; # 加上该选项则被授权用户，可以再次授权其他用户，否则不可以。 撤销权限1mysql&gt; REVOKE priv_type ON db_name.tbl_name FROM 'username'@'host','user2'@'host2'; 查看权限1mysql&gt; show grants for username@localhost; GRANT USAGE:mysql usage 权限就是空权限，默认 create user 的权限，只能连库，啥也不能干 权限可选项 privilegehttps://dev.mysql.com/doc/refman/8.0/en/grant.html 这里只是简单列出，具体请查看官方文档 Permissible Static Privileges for GRANT and REVOKE ALL [PRIVILEGES] ALTER ALTER ROUTINE CREATE CREATE TABLESPACE | TEMPORARY TABLES | USER | VIEW DELETE DROP EVENT EXECUTE FILE GRANT OPTION INDEX INSERT LOCK TABLES PROCESS PROXY REFERENCES RELOAD REPLICATION CLIENT | SLAVE SELECT SHOW DATABASES | VIEW SHUTDOWN SUPER TRIGGER UPDATE USAGE Permissible Dynamic Privileges for GRANT and REVOKE AUDIT ADMIN BINLOG ADMIN CONNECTION ADMIN ENCRYPTION KEY ADMIN FIREWALL ADMIN | USER GROUP REPLICATION ADMIN REPLICATION SLAVE ADMIN ROLE ADMIN SET USER ID SYSTEM VARIABLES ADMIN VERSION TOKEN ADMIN 修改密码1mysql&gt; ALTER USER IF EXISTS 'root'@'localhost','user2'@'host2' IDENTIFIED WITH mysql_native_password BY 'mytest'; 删除用户1mysql&gt; DROP USER IF EXISTS 'username'@'host','user2'@'host2'; 用户表全部信息1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162[ &#123; "Host": "%", "User": "node", "Select_priv": "Y", "Insert_priv": "N", "Update_priv": "N", "Delete_priv": "N", "Create_priv": "N", "Drop_priv": "N", "Reload_priv": "N", "Shutdown_priv": "N", "Process_priv": "N", "File_priv": "N", "Grant_priv": "N", "References_priv": "N", "Index_priv": "N", "Alter_priv": "N", "Show_db_priv": "N", "Super_priv": "N", "Create_tmp_table_priv": "N", "Lock_tables_priv": "N", "Execute_priv": "N", "Repl_slave_priv": "N", "Repl_client_priv": "N", "Create_view_priv": "N", "Show_view_priv": "N", "Create_routine_priv": "N", "Alter_routine_priv": "N", "Create_user_priv": "N", "Event_priv": "N", "Trigger_priv": "N", "Create_tablespace_priv": "N", "ssl_type": "", "ssl_cipher": &#123; "type": "Buffer", "data": [] &#125;, "x509_issuer": &#123; "type": "Buffer", "data": [] &#125;, "x509_subject": &#123; "type": "Buffer", "data": [] &#125;, "max_questions": 0, "max_updates": 0, "max_connections": 0, "max_user_connections": 0, "plugin": "mysql_native_password", "authentication_string": "*58F4612C3598D20A3C51A37D7B2643BF15806832", "password_expired": "N", "password_last_changed": "2018-03-15 00:10:34", "password_lifetime": null, "account_locked": "N", "Create_role_priv": "N", "Drop_role_priv": "N", "Password_reuse_history": null, "Password_reuse_time": null &#125;] 用户角色管理 （8.0+）将一组用户加入到某个角色，后续通过更改角色权限，就可以一次性操作多个用户 https://dev.mysql.com/doc/refman/8.0/en/roles.html 1234567891011mysql&gt; CREATE ROLE IF NOT EXISTS 'admin', 'developer', 'webapp'@'localhost';mysql&gt; DROP ROLE IF EXISTS 'webapp'@'localhost';mysql&gt; GRANT 'role' TO 'user'@'host';mysql&gt; GRANT priv_type ON db_name.tbl_name TO 'role';# 在向用户帐户授予角色时，当用户帐户连接到数据库服务器时，它不会自动使角色变为活动状态。mysql&gt; SET ROLE DEFAULT; 参考链接 http://blog.csdn.net/huaishu/article/details/50540814 https://www.yiibai.com/mysql/roles.html]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 数据类型]]></title>
    <url>%2Fdatabase%2Fmysql%2Ftypes.html</url>
    <content type="text"><![CDATA[MySQL 有三大类数据类型, 分别为 数字、日期\时间、字符串。 注意事项5.0 版本之后 varchar(M) 其中的 M 代表的是字符数，而不是字节数，和编码类型无关。无论是哪种编码都只能存 M 个字符，比如 M=10 那么他能存 10 个汉字或者存 10 个英文字母。 JSON 类型1234CREATE TABLE tb1( `id` BIGINT, `json` JSON); 数值类型TINYINT 8 位 SMALLINT 16 位 MEDIUMINT 24 位 INT INTEGER 32 位 BIGINT 64 位 浮点型FLOAT 32 位 DOUBLE 64 位 DECIMAL(M,D) 日期时间类型DATA 3 字节 YYYY-MM-DD TIME 3 字节 HH:MM:SS YEAR 1 字节 YYYY DATATIME 8 字节 YYYY-MM-DD HH:MM:SS TIMESTAMP 4 字节 字符串CHAR 0-255 字节 VARCHAR 0-65535 字节 变长 TINYBLOB 0-255 字节 TINTTEXT 0-255 字节 BLOB 0-65535 字节 TEXT 0-65535 字节 MEDIUMBLOB 0-16 777 215 字节 MEDIUMTEXT 0-16 777 215 字节 LONGBLOB 0-4 294 967 295 字节 LONGTEXT 0-4 294 967 295 字节 BINARY VARBINARY 存储二进制字符串 用法说明BINARY 保存二进制字符串，它保存的是字节而不是字符，没有字符集限制 BLOB 变长 保存二进制数据 比如 图片 音频 视频 TEXT 保存字符数据 比如 文本]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 初级命令]]></title>
    <url>%2Fdatabase%2Fmysql%2FREADME.html</url>
    <content type="text"><![CDATA[本文列举了一些初级的 MySQL 命令。 字段规则小写 + 下划线 user_name 基本概念 表头(header): 每一列的名称; 列(row): 具有相同数据类型的数据的集合; 行(col): 每一行用来描述某个人/物的具体信息; 值(value): 行的具体信息, 每个值必须与该列的数据类型相同; 键(key): 表中用来识别某个特定的人\物的方法, 键的值在当前列中具有唯一性。 字符集修改配置文件1234567891011[client]default-character-set = utf8mb4[mysql]default-character-set = utf8mb4[mysqld]character-set-client-handshake = FALSEcharacter-set-server = utf8mb4collation-server = utf8mb4_unicode_ciinit_connect='SET NAMES utf8mb4' 查看字符集123456789101112131415161718SHOW VARIABLES WHERE Variable_name LIKE 'character\_set\_%' OR Variable_name LIKE 'collation%';# 以下为原始配置信息，修改后的配置请自行查看+--------------------------+-------------------+| Variable_name | Value |+--------------------------+-------------------+| character_set_client | utf8 || character_set_connection | utf8 || character_set_database | latin1 || character_set_filesystem | binary || character_set_results | utf8 || character_set_server | latin1 || character_set_system | utf8 || collation_connection | utf8_general_ci || collation_database | latin1_swedish_ci || collation_server | latin1_swedish_ci |+--------------------------+-------------------+ 常见指令1$ mysql -uroot -pmytest -D test -D 指定数据库 -h 指定主机 -P 指定端口 12345678910111213# 切换数据库、数据表等mysql&gt; USE# UNION 将多个 SELECT 结果组合到一起mysql&gt; SELECT country FROM tb1 UNION SELECT country FROM tb2 ORDER BY country; # 结果没有重复值mysql&gt; SELECT country FROM tb1 UNION ALL SELECT country FROM tb2 ORDER BY country; # 结果有重复值# 正则表达式 REGEXPmysql&gt; SELECT ... WHERE name REGEXP '^st'; 查看123456789101112131415mysql&gt; SHOW DATABASES;mysql&gt; SHOW TABLES;mysql&gt; SHOW TABLES FROM db_name;mysql&gt; &#123; SHOW COLUMNS FROM | DESCRIBE | DESC &#125; tbl_name;mysql&gt; SHOW CREATE DATABASE db_name;mysql&gt; SHOW CREATE TABLE tbl_name;mysql&gt; SHOW warnings;mysql&gt; SHOW engines\G; 约束NULL NOT NULL AUTO_INCREMENT UNSIGNED PRIMARY KEY 或 KEY UNIQUE KEY DEFAULT FOREIGN KEY REFERENCES 外键约束FOREIGN KEY 1234mysql&gt; CREATE TABLE 表名( pid 定义, FOREIGN KEY (pid) REFERENCES 父表 (字段) [参照操作];); 参照操作CASCADE SET NULL ON DELETE RESTRICT 元数据123456789mysql&gt; SELECT VERSION();mysql&gt; SELECT DATABASE();mysql&gt; SELECT USER();mysql&gt; SHOW STATUS; # 服务器状态mysql&gt; SHOW VARIABLES; # 服务器配置变量 事务保证数据库的完整性 原子性 要么成功，要么不成功。 一致性 事务开始之前和结束之后，数据库的完整性没有被破坏。 隔离性 防止多个事务并发执行时由于交叉执行而导致的数据的不一致，分为 读未提交(READ UNCOMMITTED) 读提交(READ COMMITTED) 可重复读(REPEATABLE READ) 串行化(SERIALIZABLE)。 持久性 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。 BEGIN START TRANSACTION 显式的开启一个事务。 COMMIT 提交事务，并使对数据库进行的所有修改称为永久性的。 ROLLBACK 回滚 结束事务，并撤销正在进行的所有未提交的修改。 SAVEPOINT 创建一个保存点。 RELEASE SAVEPOINT 删除保存点。 ROLLBACK TO 回滚到某个保存点。 SET TRANSACTION 设置事务的隔离级别。 并发控制当多个连接对记录进行修改时保证数据的一致性和完整性。 锁共享锁（读锁）同一时间段内，多个用户可以读取同一资源，读取过程中数据不会发生任何变化。 排它锁（写锁）在任何时候只能有一个用户写入资源，当进行写锁时会阻塞其他的读锁或者写锁操作。 锁颗粒表锁 行锁]]></content>
      <categories>
        <category>DataBase</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Django 初始化配置]]></title>
    <url>%2Fpython%2Fdjango%2FREADME.html</url>
    <content type="text"><![CDATA[创建工程 1$ django-admin startproject myblog 创建应用 分隔功能，一个功能对应一个应用 1$ python3 manage.py startapp blog 在 settings.py 中添加应用 1234INSTALLED_APPS = [...'blog',] 启动服务 测试使用，后续使用 Nginx 1$ python3 manage.py runserver 模板在应用目录下新建 Templates 文件夹存放 HTML 文件 生成数据表12345678910111213$ python3 manage.py makemigrations blog$ python3 manage.py migrate# 查看SQL语句$ python3 manage.py sqlmigrate blog 0001# 创建用户$ python3 manage.py createsuperuser# 静态资源 修改 settings.py 1234567# 新文件夹STATIC_ROOT = "/var/www/example.com/static/"# 转移文件$ python3 manage.py collectstatic 官方指南：https://docs.djangoproject.com/en/1.11/howto/static-files/ Nginx 配置安装 uwsgi1$ python3 -m pip install uwsgi 配置文件方式启动uwsgi.ini 12345678910111213141516171819202122232425# myweb_uwsgi.ini file[uwsgi]# Django-related settings#http = :8010socket = :8010# the base directory (full path)chdir = /Users/khs1994/WorkSpace/PycharmProjects/django_demo/# Django s wsgi filemodule = django_demo.wsgi# process-related settings# mastermaster = true# maximum number of worker processesprocesses = 4# ... with appropriate permissions - may be needed# chmod-socket = 664# clear environment on exitvacuum = truebuffer-size = 32768 1$ uwsgi --ini uwsgi.ini Nginx 配置官方文档：https://www.nginx.com/resources/wiki/start/topics/examples/djangofastcgi/ 1234567891011121314151617181920server &#123; listen 80; server_name django.tkhs1994.com; charset utf-8; location / &#123; include uwsgi_params; uwsgi_pass 127.0.0.1:8010; uwsgi_param UWSGI_SCRIPT untitled.wsgi; uwsgi_param UWSGI_CHDIR /Users/khs1994/WorkSpace/PycharmProjects/untitled; index index.html index.htm; client_max_body_size 35m; # http代理，根据 ini 配置文件端口指定的协议进行选择 #proxy_pass http://127.0.0.1:8010/; #proxy_set_header Host $host; #proxy_set_header X-Real-IP $remote_addr; #proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; #proxy_set_header X-Forwarded-Proto "http"; &#125;&#125;]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python MySQL 使用详解]]></title>
    <url>%2Fpython%2Fmysql.html</url>
    <content type="text"><![CDATA[GitHub：https://github.com/PyMySQL/PyMySQL 1$ pip install pymysql 相关链接]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 面向对象]]></title>
    <url>%2Fpython%2Foop.html</url>
    <content type="text"><![CDATA[本文介绍了 Python3 面向对象编程 12345678910111213141516171819202122232425class A(object): # () 括号里表示 类 A 继承于 object, 可以多继承 (B, C, D) i = 1 # 属性 __a = 2 # 私有属性 def __init__(self,age): # 构造函数 self.name = 'tom' self.age = age def f(self, v): # 方法，第一个参数必须为 self print(v) def __f2(self): print('私有方法') def __del__(self): print('析构函数')a = A(1)print(a.name)print(a.age)a.f(1)]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python3 基本语法]]></title>
    <url>%2Fpython%2Fbasic.html</url>
    <content type="text"><![CDATA[本文介绍了 Python3 的基本语法 1print('Hello World!') 定义变量12345678910111213141516171819202122232425262728a = 1b = 'a' + 'b'c = True # Falsed = "&#123;a&#125;".format(a=a) # 字符串内包含变量del a'''注释'''"""注释"""print('''多行''')print('\n') # 输出 空行print(r'\n') # 原样输出 \nprint('1', end=" ") # 默认输出自动换行，加上 end=" " 表示不换行 获取用户输入1a = input('please input : ') 获取脚本参数12345sys.argv[0] # 脚本名称sys.argv[1] # 第一个参数len(sys.argv)-1 # 参数个数 函数123def fun_name(a=1, b=2): print(a) pass 匿名函数1sum = lambda arg1, arg2: arg1+arg2 流程控制123456if True: print('')elif a = 1: print('')else: print('') 12while True: print('1') 1for in 数据类型 List [1, 2, 3] Tuple (1, 2, 3) 元组的元素不能修改 Set {1, 2, 3} 无序不重复元素 Direct {‘name’:’tom’, ‘age’:18} 错误与异常123456try: print(a)except NameError as e: print(e)else: print('没有错误发生')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python 安装配置]]></title>
    <url>%2Fpython%2FREADME.html</url>
    <content type="text"><![CDATA[本文介绍了 Python 的编译安装方法以及 pip 的使用。 安装12345$ wget https://www.python.org/ftp/python/3.6.2/Python-3.6.2.tgz$ cd$ ./configure --prefix=/usr/local/python$ make$ make install pippip 是 Python 包管理工具，安装 Python 包非常方便 pip 下载安装配置1234567$ mkdir ~/.pip$ vi ~/.pip/pip.conf[global]index-url = https://pypi.douban.com/simple[list] format=columns 安装12345678910111213141516171819# 安装 setuptools$ wget "url" --no-check-certificate$ tar -xzvf default.tar.gz$ cd setuptools* # 依据你的解压目录名而定$ python setup.py install# 安装 pip$ wget "url" --no-check-certificate$ tar -xzvf pip-1.5.4.tar.gz$ cd pip-1.5.4$ python setup.py install pip 使用 注意，现在可能更常用的是 Python3，为了与 Python2 区分，你可能需要将以下命令中的 pip 换为 pip3。 搜索包1$ pip search SomePackage 安装包1$ pip install SomePackage 查看包详情1$ pip show SomePackage 查看已安装的包1$ pip list 检查哪些包有可用的更新 1$ pip list --outdated 升级包1$ pip install --upgrade SomePackage 卸载包1$ pip uninstall SomePackage 更多的用法请通过 pip --help 查看。 相关链接 http://blog.csdn.net/u013066730/article/details/54580948]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js]]></title>
    <url>%2Fhtml%2Fjs%2Fvue.html</url>
    <content type="text"><![CDATA[Vue 简单示例 123$ npm install --global @vue/cli$ vue create my-project-name 12&lt;p&gt;Using mustaches: &#123;&#123; rawHtml &#125;&#125;&lt;/p&gt;&lt;p&gt;Using v-html directive: &lt;span v-html="rawHtml"&gt;&lt;/span&gt;&lt;/p&gt; 123456789101112131415161718&lt;div id="app"&gt; &#123;&#123; message &#125;&#125;&lt;/div&gt;&lt;script&gt;let vm = new Vue(&#123; el: '#app', // 与哪个元素绑定 data: &#123; message: 'Hello Vue!' &#125;&#125;);vm.message = 'Hello World';vm.$data;vm.$el;&lt;/script&gt; v-bind绑定元素属性 123456&lt;span v-bind:title="message"&gt;&lt;!-- 简写 --&gt;&lt;a :href="url"&gt;url&lt;/a&gt;&lt;!-- 上面的语法表示 active 这个 class 存在与否将取决于数据属性 isActive 的值 --&gt;&lt;span v-bind:class="&#123; active: isActive, 'text-danger': hasError&#125;"&gt;&lt;/span&gt; v-if这里，v-if 指令将根据表达式 seen 的值的真假来插入/移除 &lt;p&gt; 元素。 1&lt;p v-if="seen"&gt;现在你看到我了&lt;/p&gt; v-for1234567891011121314151617181920&lt;div id="app-4"&gt; &lt;ol&gt; &lt;li v-for="todo in todos"&gt; &#123;&#123; todo.text &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app-4', data: &#123; todos: [ &#123; text: '学习 JavaScript' &#125;, &#123; text: '学习 Vue' &#125;, &#123; text: '整个牛项目' &#125; ] &#125;&#125;)&lt;/script&gt; v-on事件监听器 事件与方法绑定 123&lt;button v-on:click="reverseMessage"&gt;逆转消息&lt;/button&gt;&lt;!-- 简写 --&gt;&lt;button @clink="reverseMessage"&gt;逆转消息&lt;/button&gt; v-model实现表单输入和应用状态之间的双向绑定。 12345678910111213&lt;div id="app-6"&gt; &lt;p&gt;&#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;input v-model="message"&gt;&lt;/div&gt;&lt;script&gt;new Vue(&#123; el: '#app-6', data: &#123; message: 'Hello Vue!' &#125;&#125;)&lt;/script&gt; 组件1234Vue.component('todo-item',&#123; props: ['todo'] template: '&lt;li&gt;&#123;&#123;todo.text&#125;&#125;&lt;/li&gt;'&#125;); 计算属性1234567891011121314151617181920212223&lt;p&gt;&#123;&#123;prop&#125;&#125;&lt;/p&gt;new Vue(&#123; computed: &#123; prop()&#123; return ''; &#125;, // getter setter prop2: &#123; get()&#123; &#125;, set(newValue)&#123; &#125; &#125; &#125;, methods: &#123; prop()&#123; return ''; &#125; &#125;&#125;); 与 methods 区别 计算属性是基于它们的依赖进行缓存的。只在相关依赖发生改变时它们才会重新求值。 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 侦听属性 观察和响应 Vue 实例上的数据变动 12345678new Vue(&#123; watch: &#123; // 当 first 值变动时，执行 firstName(val)&#123; this.fullName = val + '111'; &#125; &#125;&#125;)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React.js]]></title>
    <url>%2Fhtml%2Fjs%2Freact.html</url>
    <content type="text"></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>React.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2Fhtml%2Fjs%2Fajax.html</url>
    <content type="text"><![CDATA[AJAX Asynchronous JavaScript and XML 异步的 JavaScript 和 XML。 慕课网：https://www.imooc.com/video/5644 跨域 （同源策略） https://zhuanlan.zhihu.com/p/35404847 123456789Access-Control-Allow-Origin *Access-Control-Allow-Methods "GET"Access-Control-Allow-Headers *Access-Control-Max-Age 3600# Cookie 跨域*-Origin 值必须为请求地址Access-Control-Allow-Credentials "true" NGINX 配置解决跨域 1234567add_header Access-Control-Allow-Methods *;add_header Access-Control-Allow-Max-Age 3600;add_header Access-Control-Allow-Credentials true;add_header Access-Control-Allow-Origin $http_origin;add_header Access-Control-Allow-Headers$http_access_control_request_headers; 简单请求与非简单请求 简单请求 GET HEAD POST 且 请求 header 无自定义头 且 Content-Type 为 text/plain multipart/from-data application/x-www-form-urlencoded 非简单请求 PUT DELETE JSON 格式的 AJAX 有自定义头 简单请求 先发送，后验证 非简单请求 先发送 OPTION 请求，通过验证再发送请求 1. 创建 XMLHttpRequest 对象 （XHR）12345&lt;button id="search"&gt;按钮名字&lt;/button&gt;&lt;p id="return"&gt; 服务器返回的数据会出现在这里&lt;/p&gt; 1234document.getElementById("search").onclick=function()&#123; xmlHttp=new XMLHttpRequest(); // ...&#125; 2. 发送请求 open send1234567xmlHttp.open("method", "url", true); // 第三个参数为 async,默认为 true// 设置 headerxmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");xmlHttp.send("strring"); 3. 获取响应123456789// 字符串形式的响应document.getElementById("return").innerHTML=xmlHttp.responseText;// xml 形式的响应xmlDoc=xmlHttp.responseXML;// 之后解析 XML 其他方法12345.statusText 以文本形式返回 HTTP 信息.getAllResponseHeader() 获取所有响应报头.getResponseHeader() 查询某个报头的值 判断状态之后再操作 DOM123456789xmlHttp.onreadystatechange=function()&#123; if (xmlHttp.readyState == 4 &amp;&amp; xmlHttp.status == 200) &#123; // 做一些事情 document.getElementById("return").innerHTML=xmlHttp.responseText; &#125;&#125; 0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 JSON 解析1JSON.parse("JSON 字符串"); jQuery http://www.w3school.com.cn/jquery/ajax_ajax.asp 12345678910111213141516171819202122232425$(document).ready(function()&#123; $("#search").click(function()&#123; $.ajax(&#123; type: "GEt", url: "url", dataType:"json", beforeSend: function(xhr) &#123; xhr.setRequestHeader("Access-Toke"); &#125;, headers: &#123; 'Access-Token':$.cookie('access_token') &#125;, data:&#123; // post 数据 name:1 &#125;, success:function(data)&#123; alter(data); &#125;, error:function()&#123; alert("发生错误"); &#125; &#125;) &#125;)&#125;) 跨域]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery]]></title>
    <url>%2Fhtml%2Fjs%2Fjquery.html</url>
    <content type="text"><![CDATA[12345678910111213$(selector).action();$.method();$(document).ready(function($) &#123;&#125;);jQuery(document).ready(function($) &#123;&#125;); 1234567891011121314151617181920212223242526272829303132333435$(this).hide(); 当前元素// 元素$("p").show(); 所有 &lt;p&gt; 元素$("p:first").toggle(); 第一个 &lt;p&gt; 元素 显示被隐藏的元素，并隐藏已显示的元素$("ul li:first") 选取第一个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素$("ul li:first-child") 选取每个 &lt;ul&gt; 元素的第一个 &lt;li&gt; 元素// class$("p.test").hide(); class="test" 的 &lt;p&gt; 元素// id$("#test").hide(); id="test" 的元素// 属性$("[href]").hide();$("a[target = '_blank']")$("a[target != '_blank']")// 类型$(":button") 选取所有 type="button" 的 &lt;input&gt; 元素 和 &lt;button&gt; 元素$("tr:even") 偶数位置的 &lt;tr&gt; 元素$("tr:odd") 奇数位置的 &lt;tr&gt; 元素 DOM创建元素1let p = $("&lt;p&gt;&lt;/p&gt;").text('文本'); 设置属性1p.attr('k','v'); 设置文本1p.text('文本'); 设置 CSS1p.css('k','v'); 事件 click dblclick mouseenter 当鼠标指针穿过元素时 mouseleave 当鼠标指针离开元素时 mousedown 当鼠标指针移动到元素上方，并按下鼠标按键时 mouseup 当在元素上松开鼠标按钮时 hover keypress 在键盘上按下一个按键，并产生一个字符时发生 keydown keyup在键盘上按下某键时发生 用户松开某一个按键时触发 submit change focus blur 当元素获得焦点时 load resize scroll unload 淡入淡出1234567fadeIn() 淡入已隐藏的元素fadeOut() 淡出可见元素fadeToggle() 在 fadeIn() 与 fadeOut() 方法之间进行切换fadeTo() 渐变为给定的不透明度（值介于 0 与 1 之间）。 滑动12345slideDowm() 向下滑动元素slideUp() 向上滑动元素slideToggle() 链1$("#p1").css("color","red").slideUp(2000).slideDown(2000); 捕获内容1234567$("#p").html() 所选元素的文本内容$("#p").text() 所选元素的内容$("#p").val() 表单字段的值$("#p").attr() 获取属性值 添加元素1234567append() 在被选元素的结尾插入内容prepend() 开头after() 之后before() 之前 删除元素123remove() 删除被选元素（及其子元素）empty() 从被选元素中删除子元素 获取并设置 CSS 类12345addClass() 向被选元素添加一个或多个类removeClass() 从被选元素删除一个或多个类toggleClass() 对被选元素进行添加/删除类的切换操作 尺寸123456789101112131415width()height()innerWidth()innerHeight()outerWidth()outerWidth(true)outerHeight()outerHeight(true)]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>JQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 对象]]></title>
    <url>%2Fhtml%2Fjs%2Fobject.html</url>
    <content type="text"><![CDATA[JavaScript 中的所有事物都是对象：字符串、数值、数组、函数… 对象创建1234567let obj = Object.create(&#123; x:1, // 对象属性 firstName: 'x', methodName: function () &#123; // 对象方法 return this.firstName + " " + this.lastName; &#125;&#125;); 12345678910111213141516171819obj.x; // 通过 . 访问obj["y"]; // 通过中括号访问obj.methodName(); // 调用方法delete obj.x; // 删除属性for (let variable in object) &#123; if (object.hasOwnProperty(variable)) &#123; &#125;&#125;'x' in obj; // true'toString' in obj; // true 会查找原型链上的属性obj.hasOwnProperty('x'); //trueobj.hasOwnProperty('toString'); //false 不会查找原型链上的属性 原型链1234567891011function foo() &#123;&#125;foo.prototype.z = 3;let obj = new foo();obj.x = 2;obj.y = 3;obj.z // 3 解构赋值12345678910111213141516171819let [x, y, z] = ['hello', 'JavaScript', 'ES6']; // 同 PHP list($a)=[1]let [x, [y, z]] = ['hello', ['JavaScript', 'ES6']]; // 嵌套let [, , z] = ['hello', 'JavaScript', 'ES6']; // 忽略前两个元素，只对z赋值第三个元素var person = &#123; name: '小明', age: 20, gender: 'male', passport: 'G-12345678', school: 'No.4 middle school'&#125;;// 把 passport 属性赋值给变量id:let &#123;name, passport:id&#125; = person;// 如果 person 对象没有 single 属性，默认赋值为 true:var &#123;name, single=true&#125; = person; 对象详解日期对象123456789let myDate=new Date(); // 可以在括号中定义初始值document.write(myDate); // 打印当前时间myDate.getFullYear(); // 输出、设置年份myDate.setFullYear(2013);myDate.getDay(); // 返回星期，整数 0 代表星期日 字符串对象12345678910111213141516171819obj.charAt(index); // 返回指定位置的字符// 返回指定字符串(substring)在某个字符串(obj)中首次出现的位置// 从 startPos 开始检索obj.indexOf(substring, startPos);obj.split(separator, limit); // 将字符串(obj)用(separator)分割并返回数组obj.substring(startPos, stopPos) // 截取指定位置的字符串obj.substring(7) // 若只有一个值，则返回从该位置直到结束obj.substring(2,6);obj.substr(startPos, length); // 从指定位置提取指定长度的字符串obj.toUpperCase(); // 字符串转换成大写 Math向上取整 1Math.ceil(0.8); // 返回 1 JSON123JSON.stringify(); // 对象 -&gt; jsonJSON.parse(); // json -&gt; 对象]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 与 HTML 相关的内容]]></title>
    <url>%2Fhtml%2Fjs%2Fhtml.html</url>
    <content type="text"><![CDATA[123&lt;script src="main.js"&gt;&lt;/script&gt;&lt;script&gt; let a=1; document.write(a);&lt;/script&gt; 获取元素对象 1let obj = document.getElementById('id'); // 还可以 ByClassName / ByName 输出 输出到 HTNL document.write(1) 会重写整个 HTML 文档 输出到控制台 console.log(&quot;Hello&quot;) 输出到 html 元素 obj.innerHTML(&quot;Hello&quot;) 弹窗警告 alert(&#39;Hello&#39;) 确认对话框 confirm(1) 123confirm(a);let b = confirm(a); // 若用户点击确认，则返回 true，此时变量 b 的值为 true prompt 提问文本对话框，可以输入文本 1234prompt(str1,str2); // 若用户点击确定，文本框中的内容将作为函数返回值，点击取消，将返回 null// str1: 要显示在消息对话框中的文本，不可修改// str2：文本框中的内容，可以修改 设置 CSS123456789let obj = document.getElementById('id');obj.innerHTML="Hello";obj.style.display = 'none' ; // block 隐藏 显示obj.style.color="red"; // 设置样式 CSSobj.style.fontSize="20"; 设置属性1234567891011// obj 变量接上部分let b = obj.className; // 获取、设置元素的 classobj.className = "className";obj.getAttribute('class'); // 获取元素属性obj.setAttribute('class', 'new_value'); // 设置元素属性obj.innerHTML('内容'); // 设置文本 事件HTML 页面完成加载(onload) HTML input 字段改变时 HTML 按钮被点击 onclick 鼠标单击事件onmouseover 鼠标经过事件onmouse 鼠标移开事件onmouseout 从一个 HTML 元素移开鼠标onchange HTML 元素改变onkeydown 按下键盘按键onload 页面完成加载123&lt;some-HTML-element onclick="fun_name()"&gt;&lt;button onclick="this.innerHTML=Date()"&gt;现在的时间是?&lt;/button&gt; 浏览器对象window1234567window.open()window.close()window.moveTo() // 移动当前窗口window.resize() // 调整当前窗口的尺寸 cookie1document.cookie="key=value; expires=Thu, 01 Jan 1970 00:00:00 GMT" 计时器12345678910// 增加计时器，返回整数let int = setInterval(代码,交互时间); // 单位毫秒clearInterval(id_of_setInterval); // 取消计时器setTimeout(代码,延迟时间); // 页面载入之后延迟指定时间后，去执行一次表达式，仅执行一次，和上边一样，返回整数clearTimeout(id_of_setTimeout); // 取消 history 历史123456789window.history.[属性|方法]; // window 可省略history.length; // 返回浏览器历史列表中的 URL 数量。history.back(); // 返回前一个页面history.go(-1); // 下边的代码等同于 backhistory.forward(); // 倒退之后，回到倒退之前的页面 相当于 go(1) location 解析网页 URL1234location.[属性|方法];location.host; // 返回或设置主机名+端口号location.href; // 完整 URL navigator 有关浏览器的信息Navigator 对象包含有关浏览器的信息，通常用于检测浏览器与操作系统的版本。 12345navigator.appVersion; // 返回浏览器的平台和版本信息navigator.platform; // 返回浏览器的操作系统平台navigator.userAgent; // 返回用户代理头的字符串表示(就是包括浏览器版本信息等的字符串) screen123window.screen.属性;screen.availHeight; // 窗口可以使用的屏幕高度，单位像素]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础]]></title>
    <url>%2Fhtml%2Fjs%2FREADME.html</url>
    <content type="text"><![CDATA[JavaScript 基础语法介绍，基于 ES6。 必须启用严格模式 123'use strict'// code 数据类型(6 种) Number String Boolean Array null undefined Object 包含 function Date Array 1let x = new Number; 类型转换123String(123);(123).toString() 类型检测123456789typeof 100 // numberobj instanceof Object // obj 是不是 ObjectObject.prototype.toString.apply([]); // [object Array]// constructor// duck type 隐式转换123"37" - 7 // 30"37" + 7 // 377 基础语法 一行或多行 字符串和变量写在一起 1234`your name is $&#123;name&#125;``hello JS` 常量 const PI=3.14; // 同 PHP 变量 let a; a = 1 a = &#39;Hello World !&#39; let const 严禁使用 var 特例 var a = (1,2,3); // 取右边的数值 a = 3 连接符 + 换行 12document.write("hello \World !") 调试123let x = 15 * 5;debugger;document.getElementbyId("demo").innerHTML = x; 变量提升123456789a = 1;console.log(a); // 可以正常输出console.log(b); // 报错var a;var b = 1; // 声明的同时赋值，变量不会提升 变量作用域函数外部声明，函数内部可以调用，反之不行。 特例：如果变量在函数内没有声明（即，没有使用 var 关键字），该变量为全局变量 123456// 此处可调用 carName 变量function myFunction() &#123; carName = "Volvo"; // 此处可调用 carName 变量&#125; 函数12345678function fun1(a, b = 3) &#123; // ES6 才允许函数默认值 console.log(a); console.log(b); argument[0]; // 包含函数参数的数组 return a; // 函数返回值&#125;fun1(1, 2); // 调用函数 在函数表达式存储在变量后，变量也可作为一个函数使用： 12let x = function (a, b) &#123;return a * b&#125;;let z = x(4, 3); 函数参数可变参数 ES6 同 PHP12345function f(...a)&#123; // 遍历 a&#125;f(1,2,3,4); 自调用函数123(function () &#123; let x = "Hello!!"; // 我将调用自己&#125;)(); 闭包12 高阶函数一个函数接收另一个函数作为参数，这种函数就称之为高阶函数 箭头函数1234567891011121314151617181920212223242526272829x =&gt; x * xfunction (x) &#123; return x * x;&#125;x =&gt; &#123; if (x &gt; 0) &#123; return x * x; &#125; else &#123; return - x * x; &#125;&#125;// 两个参数:(x, y) =&gt; x * x + y * y// 无参数:() =&gt; 3.14// 可变参数:(x, y, ...rest) =&gt; &#123; var i, sum = x + y; for (i=0; i&lt;rest.length; i++) &#123; sum += rest[i]; &#125; return sum;&#125; 包装对象123let a = 'a';let obj = new String('a'); 数组1234567891011let myArray = new Array();let myArray = new Array(1,2,3);let myArray = [1,2,3]; // 同 PHPmyArray[0] = 80; // 数组赋值myArray.length; // 数组长度myArray.sort() // 数组排序 数组合并123let a = [1, 2, 3];let b = ['hello', ...a]; 流程控制if while 同 PHP break continue 1234567switch (expression) &#123; case expression: // 这里是恒等 === break; default:&#125; 123for (let i = 0; i &lt; array.length; i++) &#123; array[i]&#125; 12345for (let variable in object) &#123; if (object.hasOwnProperty(variable)) &#123; &#125;&#125; 123do &#123;&#125; while (true); 错误处理1234567try &#123; throw "test"&#125; catch (e) &#123; console.log(e);&#125; finally &#123; console.log('finally');&#125; 严格模式 &#39;use strict&#39;提供更强的错误检查。 123function functionName() &#123; 'use strict'&#125; 不允许用 with delete 参数、函数名会报错 对象字面量重复属性报错 {x:1,x:2} 等等。]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS 预处理器 Less Cass Stylus]]></title>
    <url>%2Fhtml%2Fcss%2Fless_sass.html</url>
    <content type="text"><![CDATA[Sass Less Stylus 安装12345$ npm install -g less$ gem install sass$ npm install -g stylus Less导入12@import "main"; // main.less 如果为 less 文件，后缀可省略@import "typo.css"; 变量12345678910@a: 1;#header&#123; color: @a; // comments /** * comments */&#125; 混合嵌套运算123@a: 5cm - 1cm;// + - * / 内置函数作用域Sass有两种格式的后缀名，这里以 .scss 后缀为例 12]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS]]></title>
    <url>%2Fhtml%2Fcss%2FREADME.html</url>
    <content type="text"><![CDATA[CSS 简要教程 换行1word-wrap: break-word; 123&lt;style type="text/css"&gt; /*注释*/&lt;/style&gt; 位置 内联式 1&lt;p style="color:red"&gt; &lt;/p&gt; 嵌入式 写在当前 HTML 中 外部式 1&lt;link href="main.css" rel="stylesheet" type="text/css" /&gt; 选择器1234567891011121314151617181920212223242526272829303132333435363738394041.类名&#123;&#125;/* ID 选择器 */#id&#123;&#125;/* 子选择器 第一代子元素 */.food&gt;li&#123;&#125;/* 包含后代选择器 */.first span&#123;&#125;/* &gt; 作用于元素的第一代后代，空格 作用于元素的所有后代 *//* 伪类选择器 */a:hover&#123;&#125;/* 通用选择器 */* &#123; color: red!important; /*重要性 具有最高权值*/&#125;/* 分组选择符 */h1,span&#123;&#125; CSS 属性字体font-family font-size font-weight 字体粗细 font-style: italic 斜体 颜色color 文字1234span &#123; text-decoration:underline; /* 下划线 */ text-decoration:line-through; /* 删除线 */&#125; text-indent 缩进 line-height 行高 letter-spacing 文字间隔，英文字母之间的间隔 word-spacing 单词间距 text-align:center 对齐 元素分类 display块状元素display:block &lt;div&gt; &lt;p&gt; 每个块级元素都从新的一行开始，并且其后的元素也另起一行。 元素的高度、宽度、行高以及顶和底边距都可设置。 元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 内联元素（行内元素）display:inline &lt;a&gt; &lt;span&gt; 和其他元素都在一行上；元素的高度、宽度及顶部和底部边距不可设置；元素的宽度就是它包含的文字或图片的宽度，不可改变。 内联块状元素display:inline-block 和其他元素都在一行上；元素的高度、宽度、行高以及顶和底边距都可设置。 &lt;img&gt; &lt;input&gt; 盒模型border 边框 padding 填充 margin 边界 布局模型流动模型flow 网页默认的布局模型。 浮动模型float 实现让两个块状元素并排显示。 123div&#123; float: left;&#125; 层模型 positionlayer position:absolute 绝对定位 position:relative 相对定位 相对定位 相对的是 它原本在文档流中的位置而进行的偏移 position:fixed 固定定位 例如页面浮动广告 绝对定位 与 相对定位 结合使用 绝对定位找到了自己的父类之后，要看这个父类是否进行了相对定位，没有相对定位的话就不会找这个父类来定位。 子绝父相 绝对定位的参考点，如果用top描述，那么定位参考点就是页面的左上角，而不是浏览器的左上角： 如果用bottom描述，那么就是浏览器首屏窗口尺寸，对应的页面的左下角：]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 协议]]></title>
    <url>%2Fphp%2Fhttp%2FREADME.html</url>
    <content type="text"><![CDATA[HTTP 属于应用层协议，在传输层使用 TCP 协议，在网络层使用 IP 协议。 无状态：无状态是指协议对于事务处理没有记忆能力。 无连接：限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。 面向连接 OSI 网络七层协议 应用层 HTTP 表示层 SSL 会话层 SSH 传输层 TCP 网络层 IP 数据链路层 WiFi 802.11 物理层 以太网, IEEE 802.2 头部属性Accept 指定客户端能够接收的内容类型 Accept: text/plain, text/html Accept-Charset 浏览器可以接受的字符编码集。 Accept-Charset: iso-8859-5 Accept-Encoding 指定浏览器可以支持的web服务器返回内容压缩编码类型。 Accept-Encoding: compress, gzip Accept-Language 浏览器可接受的语言 Accept-Language: en,zh Accept-Ranges 可以请求网页实体的一个或者多个子范围字段 Accept-Ranges: bytes Authorization HTTP授权的授权证书 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 指定请求和响应遵循的缓存机制 Cache-Control: no-cache Connection 表示是否需要持久连接。（HTTP 1.1默认进行持久连接）Connection: close Cookie HTTP请求发送时，会把保存在该请求域名下的所有cookie值一起发送给web服务器。 Cookie: $Version=1; Skin=new; Set-Cookie Set-Cookie: delPer=1; expires=Fri, 24-Jul-2048 11:34:43 GMT Content-Length 请求的内容长度 Content-Length: 348 Content-Encoding Content-Encoding: gzip Content-Type 请求的与实体对应的MIME信息 Content-Type: application/x-www-form-urlencoded Date 请求发送的日期和时间 Date: Tue, 15 Nov 2010 08:12:31 GMT Expect 请求的特定的服务器行为 Expect: 100-continue From 发出请求的用户的Email From: user@email.com Host 指定请求的服务器的域名和端口号 Host: www.zcmhi.com If-Match 只有请求内容与实体相匹配才有效 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 如果请求的部分在指定时间之后被修改则请求成功，未被修改则返回 304 代码 If-Modified-Since Sat, 29 Oct 2010 19:43:31 GMT If-None-Match 如果内容未改变返回304代码，参数为服务器先前发送的Etag，与服务器回应的Etag比较判断是否改变 If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果实体未改变，服务器发送客户端丢失的部分，否则发送整个实体。参数也为Etag If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 只在实体在指定时间之后未被修改才请求成功 If-Unmodified-Since: Sat, 29 Oct 2010 19:43:31 GMT Max-Forwards 限制信息通过代理和网关传送的时间 Max-Forwards: 10 Pragma 用来包含实现特定的指令 Pragma: no-cache Proxy-Authorization 连接到代理的授权证书 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 只请求实体的一部分，指定范围 Range: bytes=500-999 Referer 先前网页的地址，当前请求网页紧随其后,即来路 Referer: http://www.zcmhi.com/archives/71.html TE 客户端愿意接受的传输编码，并通知服务器接受接受尾加头信息 TE: trailers,deflate;q=0.5 Upgrade 向服务器指定某种传输协议以便服务器进行转换（如果支持） Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent User-Agent的内容包含发出请求的用户信息 User-Agent: Mozilla/5.0 (Linux; X11) Via 通知中间网关或代理服务器地址，通信协议 Via: 1.0 fred, 1.1 nowhere.com (Apache/1.1) Warning 关于消息实体的警告信息 Warn: 199 Miscellaneous warning 请求、响应消息组成 四部分 请求行（状态行）HTTP 协议版本号 状态码 状态消息 请求头部（消息报头） 空行 请求数据（响应正文） 1234567GET /test HTTP/1.1 # 请求行HTTP/1.1 200 OK # 响应状态行Date: Fri, 22 May 2018 06:07:08 GMTContent-Type: text/html; charset=UTF-8Connection: keep-alive请求数据（相应正文） url协议 域名 端口 虚拟目录 文件名 锚（#XXX）参数（?xxx=xxx） 方法 get post head delete put 虽然也是更新资源，但要求前端提供的一定是一个完整的资源对象。在指明的 URL 下存储一个文档 patch 对已知资源进行局部更新。 options 状态码 1xx 表示通知消息，如请求收到了或者正在进行处理 2xx 表示成功，如接受或知道了 3xx 表示重定向，如要完成请求还要继续采取行动 4xx 表示客户的差错，如请求由错误的语法或不能完成 5xx 表示服务器差错 地址栏键入网址回车之后的过程 DNS 网址-&gt;IP 通过 IP + 端口 和服务器建立 TCP 连接 浏览器发出读取文件的 HTTP 请求，该请求报文作为 TCP 三次握手的第三个报文的数据发送给服务器 服务器做出响应，把相应的 html 文件发给浏览器 释放 TCP 连接 浏览器解析 HTML，显示内容。 IPIP 协议主要解决网络路由和寻址问题。 TCP 控制传输协议TCP 协议主要解决如何在 IP 层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。 面向连接的、可靠的 三次握手 A 首先向 B 发出连接请求报文段，这个时候首部中的同步位 SYN=1，同时选择一个初始的序号 x。此时报文段不能携带数据。此时 A 进入到 SYN_SENT (同步已发送)状态。 B 收到连接请求报文，同意建立连接，向 A 发出确认。确认报文中，SYN 和 ACK 都置 1，确认号是 x+1,与此同时，自己选择一个初始序号 y,这个报文也不能携带数据。此时B进入 SYN_RCVD（同步收到）状态。 A 收到 B 的确认后，还要给 B 确认。这时可以携带数据，A 进入到 ESTABLISHED 状态。这就是三次握手的过程。 四次挥手 A 的应用进程向其 TCP 发出连接释放报文段，主动关闭 TCP 连接。A 进入FIN_WAIT1（终止等待1）状态 然后 B 确认，B 进入 CLOSE_WAIT(关闭等待)状态。此时 TCP 处于半关闭状态，A 已经没有数据要发送了，如果 B 仍要发送数据，B 仍然接收。 A 收到 B 的确认后，就进入FIN_WAIT2（终止等待2）状态，等待 B 发出连接释放报文。 如果 B 已经没有向 A 发送的数据，则 B 发送请求释放报文，B 进入 LAST_ACK（最后确认）阶段，等待 A 的确认。 A 在收到 B 的请求后，要发出确认，然后进入 TIME_WAIT（时间等待）状态。此时，连接还未释放，必须等待时间等待计时器设定的时间的2MSL后，A才进入CLOSED状态。 UDP 用户数据报协议 无连接、不可靠 长连接 短链接 HTTP/1.0 中默认使用短连接。每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话 HTTP/1.1 起，默认使用长连接，用以保持连接特性。Keep-Alive 不会永久保持连接，它有一个保持时间，在 WEB 服务器中进行设定。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML DOM]]></title>
    <url>%2Fhtml%2Fdom.html</url>
    <content type="text"><![CDATA[DOM 文档对象模型。 节点 元素 即 标签 Element 1 文本 &lt;a&gt;文本&lt;/a&gt; Text 3 属性 &lt;a href=&quot;&quot;&gt;&lt;/a&gt; Attr 2 注释节点 Comment 8 文档节点 Document 9 文档类型节点 DocumentType 10 &lt;!DOCTYPE html&gt; 文档片段节点 DocumentFragment 11 Javascript123456789obj.nodeNameobj.nodeValueobj.attributes[0].nodeName | nodeValue // 获取元素节点值及属性值obj.childNodes[0].nodeName | nodeValue // 获取文本节点值及文本值document.doctype.nodeName | nodeValue // 获取文档类型节点值及类型]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 表单]]></title>
    <url>%2Fhtml%2Fform.html</url>
    <content type="text"><![CDATA[HTML 表单 1234&lt;form method="post" action=" "&gt;&lt;label for="id" &gt;用户名&lt;/label&gt;&lt;input type="text" name=" " id="id" value=" "&gt; &lt;/input&gt;&lt;/form&gt; input type文本 text 密码 password 单选框 radio name 属性一致 复选框 checkbox name 属性一致 下拉列表框 123&lt;select&gt; &lt;option&gt;&lt;/option&gt;&lt;/select&gt; 下拉列表框 多选 1&lt;select multiple="multiple"&gt; &lt;/select&gt; 提交 submit 撤销输入 reset]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML 标签]]></title>
    <url>%2Fhtml%2FREADME.html</url>
    <content type="text"><![CDATA[列举 HTML 标签。 12345678910111213&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;script src="url"&gt;&lt;/script&gt; &lt;link href="main.css" rel="stylesheet" type="text/css" /&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;!--注释--&gt;&lt;/body&gt;&lt;/html&gt; head123&lt;meta charset="utf-8"&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; 标签空格 &amp;nbsp; 引用 &lt;q&gt; &lt;/q&gt; 大段引用 &lt;blockquote&gt; &lt;/blockquote&gt; 强调 &lt;em&gt; &lt;/em&gt; &lt;strong&gt; &lt;/strong&gt; 地址 &lt;address&gt; &lt;/address&gt; 代码 &lt;code&gt; &lt;/code&gt; &lt;pre&gt; &lt;/pre&gt; 无序列表 &lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 有序列表 &lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt; 表格 123456789&lt;table&gt; &lt;caption&gt; &lt;/caption&gt;&lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt; 链接 123&lt;a href="url" title="title" target="_blank"&gt; &lt;/a&gt;&lt;a href="mailto:khs1994@khs1994.com"&gt;khs1994@khs1994.com&lt;/a&gt; 图片 1&lt;img src=" " alt=" " title=" " /&gt;]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
</search>
